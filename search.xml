<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Physics-informed neural networks:Translation Part I</title>
    <url>/2021/05/07/10.1016j.jcp.2018.10.045_a/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>原文地址：<a href="https://www.sciencedirect.com/science/article/pii/S0021999118307125">PINN：深度学习框架下求解含有非线性偏微分方程的正问题、反问题</a><br>doi:<a href="http://sci-hub.ren/10.1016/j.jcp.2018.10.045">10.1016/j.jcp.2018.10.045</a></p>
<h1 id="ABSTRACT"><a href="#ABSTRACT" class="headerlink" title="ABSTRACT"></a>ABSTRACT</h1><p>本文介绍了PINN（Physics-informed neural networks，物理信息神经网络），其能够在解决监督学习任务的同时遵守由一般的非线性偏微分方程描述的物理约束。在这项工作中，我们主要从数据驱动解和偏微分方程的数据驱动解两方面探讨。根据可用数据的性质和排列（nature and arrangement），我们设计了两种不同类型的算法，即连续时间模型和离散时间模型。第一类模型形成了一族数据高效(data-efficient)的时空函数逼近器（spatio-temporal function approximators），而后一类模型能以任意精度的隐式Runge-Kutta时间递推格式（with unlimited number of stages）。通过流体、量子力学、反应扩散系统和非线性浅水波的传播等一系列经典问题，证明了该框架的有效性。</p>
<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>随着可用数据量和计算资源的爆炸式增长，机器学习与数据挖掘的最新成果在不同领域的应用产生了变革性影响，流入图像识别<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="A. Krizhevsky, I. Sutskever, G.E. Hinton, Imagenet classifification with deep convolutional neural networks, in: Advances in Neural Information Processing Systems, 2012, pp. 1097–1105.
">[1]</span></a></sup>、认知科学<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="B.M. Lake, R. Salakhutdinov, J.B. Tenenbaum, Human-level concept learning through probabilistic program induction, Science 350 (2015) 1332–1338.
">[2]</span></a></sup>、基因组学<sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="B. Alipanahi, A. Delong, M.T. Weirauch, B.J. Frey, Predicting the sequence specifificities of DNA- and RNA-binding proteins by deep learning, Nat. Biotechnol. 33 (2015) 831–838. 
">[3]</span></a></sup>等。然而，在分析复杂的物理、生物或工程系统的过程中，数据采集的成本往往过高，有时我们不得不使用有限的信息作出决策。在这种小数据环境下，绝大多数最先进的机器学习技术（如深度/卷积/递归神经网络）缺乏鲁棒性，无法保证收敛性。<br>乍一看，训练一个神经网络，使其能够从几个可能是高维的输入和输出中学习到非线性映射是非常幼稚的。在许多物理和生物系统建模相关的案例中，往往存在有大量的先验知识，而这些知识还没有应用于现有的机器学习中。假设它是控制系统随时间变化的动力学物理定律，或一些已经经过经验验证的规则或其他领域的专业知识，这些先验信息可以作为正则化约束，将解限制在可以接受的范围内（例如，在不可压缩流体中，舍弃任何违背质量守恒定律的不现实的流动解）。将这种结构化信息编码为学习算法会放大算法所看到的数据中的信息含量，使其能够快速地向正确方向收敛，并且即使只有少数训练数据也能获得较好的泛化性。<br>近期许多研究<sup id="fnref:4"><a href="#fn:4" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="M. Raissi, P. Perdikaris, G.E. Karniadakis, Inferring solutions of differential equations using noisy multi-fifidelity data, J. Comput. Phys. 335 (2017) 736–746.
">[4]</span></a></sup><sup id="fnref:5"><a href="#fn:5" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="M. Raissi, P. Perdikaris, G.E. Karniadakis, Machine learning of linear differential equations using Gaussian processes, J. Comput. Phys. 348 (2017) 683–693.
">[5]</span></a></sup><sup id="fnref:6"><a href="#fn:6" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="H. Owhadi, Bayesian numerical homogenization, Multiscale Model. Simul. 13 (2015) 812–828.
">[6]</span></a></sup>已经展示了如何利用结构化先验信息构建数据高效和物理可靠（physical-informed）的模型。这里，我们利用高斯过程回归（Gaussian Process Regression）<sup id="fnref:7"><a href="#fn:7" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="C.E. Rasmussen, C.K. Williams, Gaussian Processes for Machine Learning, vol. 1, MIT Press, Cambridge, 2006.
">[7]</span></a></sup>设计了一个适合于给定线性算子的函数表示，其能够准确推断解并为多个数学物理问题提供不精确的解。在推理和系统辨识的背景下，Raissi 等人<sup id="fnref:8"><a href="#fn:8" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="M. Raissi, P. Perdikaris, G.E. Karniadakis, Numerical Gaussian processes for time-dependent and non-linear partial differential equations, 2017, arXiv: 1703.10230.
">[8]</span></a></sup><sup id="fnref:9"><a href="#fn:9" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="M. Raissi, G.E. Karniadakis, Hidden physics models: machine learning of nonlinear partial differential equations, 2017, arXiv:1708.00588.
">[9]</span></a></sup>在后续研究中提出了非线性问题的推广。尽管高斯过程在编码先验信息时具有灵活性和数学优雅性，但其对非线性问题的处理有两个重要的限制。首先，在<sup id="fnref:8"><a href="#fn:8" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="M. Raissi, P. Perdikaris, G.E. Karniadakis, Numerical Gaussian processes for time-dependent and non-linear partial differential equations, 2017, arXiv: 1703.10230.
">[8]</span></a></sup><sup id="fnref:9"><a href="#fn:9" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="M. Raissi, G.E. Karniadakis, Hidden physics models: machine learning of nonlinear partial differential equations, 2017, arXiv:1708.00588.
">[9]</span></a></sup>中，作者必须在时间上对任何非线性项进行局部线性化，从而限制了所提出方法在离散时域的适用性，并损害了它们在强非线性状态下预测的准确性。其次，高斯过程回归的贝叶斯性质有一定的先验假设，这些假设可能限制模型的表达能力，并产生鲁棒性/脆性（robustness/brittleness）问题，特别是对于非线性问题的处理<sup id="fnref:10"><a href="#fn:10" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="H. Owhadi, C. Scovel, T. Sullivan, et al., Brittleness of Bayesian inference under fifinite information in a continuous world, Electron. J. Stat. 9 (2015) 1–79.
">[10]</span></a></sup>。</p>
<h1 id="Problem-setup"><a href="#Problem-setup" class="headerlink" title="Problem setup"></a>Problem setup</h1><p>在这项工作中，我们采取了一种不同的方法：利用深度神经网络和它们众所周知的作为普适函数逼近器的能力<sup id="fnref:11"><a href="#fn:11" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="K. Hornik, M. Stinchcombe, H. White, Multilayer feedforward networks are universal approximators, Neural Netw. 2 (1989) 359–366.
">[11]</span></a></sup>。在这种情况下，我们可以直接处理非线性问题，而无需任何先验假设，线性化，或局部时间递推。我们利用自动微分技术的最新发展<sup id="fnref:12"><a href="#fn:12" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="A.G. Baydin, B.A. Pearlmutter, A.A. Radul, J.M. Siskind, Automatic differentiation in machine learning: a survey, 2015, arXiv:1502.05767.
">[12]</span></a></sup>——这是科学计算中最有用但可能利用不足的技术之一——根据输入坐标和模型参数对神经网络进行微分，以获得物理可靠的神经网络。这类神经网络被约束为遵守任何对称性、不变性或守恒原理，这些原理源于控制观测数据的物理定律，如一般的时间相关和非线性偏微分方程所模拟的那样。这种简单而强大的结构使我们能够解决计算科学中的一大类问题，并引入了一种潜在的变革性技术，从而开发出新的数据高效和物理可靠的学习机，新的偏微分方程数值解算器，以及用于模型反演和系统辨识的数据驱动方法。<br>为此，我们的手稿分为两部分，旨在介绍我们在两大类问题背景下的发展：数据驱动的偏微分方程解和数据驱动的偏微分方程求解。论文相关的代码和数据集地址<a href="https://github%20.com%20/maziarraissi%20/PINNs">Github</a>。在这项工作中，我们只使用了相对简单的深度前馈神经网络结构，其具有双曲正切激活函数，并且没有额外的正则化（例如，L1/L2惩罚、Dropout等）。手稿中的每个数值例子都附有关于我们所采用的神经网络结构的详细讨论，以及关于其训练过程的详细信息（例如优化器、学习率等）。最后，附录A和附录B中提供了一系列全面的系统研究，旨在证明所提出方法的性能。<br>在这项工作中，我们考虑一般形式的参数化和非线性偏微分方程</p>
<script type="math/tex; mode=display">u_t+\mathcal{N}[u;\lambda]=0,x\in\Omega,t\in[0,T] \tag{1}</script><p>其中，$u(t, x)$表示隐式解（latent, hidden），$\mathcal{N}[·;\lambda]$为以$\lambda$为参数的非线性算子，$\Omega$为$\R^N$的子集。上述公式表示了数学物理中的一系列问题，包括守恒定律、扩散过程、平流-扩散-反应系统以及动力学方程等。本文以一维空间中的Burgers方程<sup id="fnref:13"><a href="#fn:13" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="C. Basdevant, M. Deville, P. Haldenwang, J. Lacroix, J. Ouazzani, R. Peyret, P. Orlandi, A. Patera, Spectral and fifinite difference solutions of the Burgers equation, Comput. Fluids 14 (1986) 23–41.
">[13]</span></a></sup>为例，其中$\mathcal{N}[u;\lambda]=\lambda_1uu_x-\lambda_2u_{xx}$、$\lambda=(\lambda_1,\lambda_2)$，下标表示对时间或空间的偏微分。考虑到系统的噪声测量，我们对以下两种情况下的解感兴趣：<br>1.给定模型参数$\lambda$，怎样描述系统的隐态$u(t, x)$；此类问题涉及到推理、滤波、平滑或者数据驱动的偏微分方程求解<sup id="fnref:4"><a href="#fn:4" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="M. Raissi, P. Perdikaris, G.E. Karniadakis, Inferring solutions of differential equations using noisy multi-fifidelity data, J. Comput. Phys. 335 (2017) 736–746.
">[4]</span></a></sup><sup id="fnref:8"><a href="#fn:8" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="M. Raissi, P. Perdikaris, G.E. Karniadakis, Numerical Gaussian processes for time-dependent and non-linear partial differential equations, 2017, arXiv: 1703.10230.
">[8]</span></a></sup></p>
<ol>
<li>模型参数$\lambda$为何值时能够最好地描述观测数据;第二类问题涉及到学习、系统识别、数据驱动的偏微分方程反问题<sup id="fnref:5"><a href="#fn:5" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="M. Raissi, P. Perdikaris, G.E. Karniadakis, Machine learning of linear differential equations using Gaussian processes, J. Comput. Phys. 348 (2017) 683–693.
">[5]</span></a></sup><sup id="fnref:9"><a href="#fn:9" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="M. Raissi, G.E. Karniadakis, Hidden physics models: machine learning of nonlinear partial differential equations, 2017, arXiv:1708.00588.
">[9]</span></a></sup><sup id="fnref:14"><a href="#fn:14" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="S.H. Rudy, S.L. Brunton, J.L. Proctor, J.N. Kutz, Data-driven discovery of partial differential equations, Sci. Adv. 3 (2017).
">[14]</span></a></sup>。<h1 id="3-Data-driven-solutions-of-partial-differential-equations"><a href="#3-Data-driven-solutions-of-partial-differential-equations" class="headerlink" title="3 Data-driven solutions of partial differential equations"></a>3 Data-driven solutions of partial differential equations</h1>首先我们来看如何利用数据驱动的方式计算偏微分方程的解：<script type="math/tex; mode=display">u_t+\mathcal{N}[u]=0,x\in\Omega,t\in[0,T] \tag{2}</script>其中，$u(t, x)$表示隐式解（latent, hidden），$\mathcal{N}[·;\lambda]$为以$\lambda$为参数的非线性算子，$\Omega$为$\R^N$的子集。在如下章节中，我们提出了两种不同的算法，分别命名连续时间模型和离散时间模型。分别通过不同的基准问题来突出它们的特性和性能。在我们研究的第二部分（下一节），我们将注意力转移到偏微分方程的数据驱动发现问题上<sup id="fnref:5"><a href="#fn:5" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="M. Raissi, P. Perdikaris, G.E. Karniadakis, Machine learning of linear differential equations using Gaussian processes, J. Comput. Phys. 348 (2017) 683–693.
">[5]</span></a></sup><sup id="fnref:9"><a href="#fn:9" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="M. Raissi, G.E. Karniadakis, Hidden physics models: machine learning of nonlinear partial differential equations, 2017, arXiv:1708.00588.
">[9]</span></a></sup><sup id="fnref:14"><a href="#fn:14" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="S.H. Rudy, S.L. Brunton, J.L. Proctor, J.N. Kutz, Data-driven discovery of partial differential equations, Sci. Adv. 3 (2017).
">[14]</span></a></sup>。<h2 id="3-1-连续时间模型"><a href="#3-1-连续时间模型" class="headerlink" title="3.1 连续时间模型"></a>3.1 连续时间模型</h2>我们定义$f(t, x)$由方程$2$左侧给出，即<script type="math/tex; mode=display">f:=u_t+\mathcal{N}[u] \tag{3}</script>然后用神经网络逼近$u(t, x)$。这个假设和方程$3$共同构成了一个PINN $f(t, x)$。该网络可通过链式求导法则[12]，并且与网络表示$u(t, x)$具有相同的参数，尽管由于微分算子$N$的作用而具有不同的激活函数。神经网络$u(t, x)$和$f(t, x)$之间的共享参数可通过最小化均方误差（MSE）函数来学习。<script type="math/tex; mode=display">MSE = MSE_u+MSE_f\tag{4}</script>其中<script type="math/tex; mode=display">MSE_u=\frac{1}{N_u}\sum_{i=1}^{N_u} \mid u(t^i_u, x^u_i)-u^i \mid^2</script><script type="math/tex; mode=display">MSE_f=\frac{1}{N_f}\sum_{i=1}^{N_u} \mid f(t_f^i, x^f_i) \mid^2</script>这里，$\lbrace t_{u}^{i}, x_{u}^{i}, u^{i} \rbrace$表示$u(t, x)$的初始和边界训练数据，$\lbrace t_{f}^{i}, x_{f}^{i}\rbrace$表示$f(t, x)$的collocations points。损失函数$MSE_u$对应初始和边界数据，$MSE_f$在配置点的有限集合上加强了方程$2$所施加的结构（？？？？）。尽管在以前的研究<sup id="fnref:15"><a href="#fn:15" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="I.E. Lagaris, A. Likas, D.I. Fotiadis, Artifificial neural networks for solving ordinary and partial differential equations, IEEE Trans. Neural Netw. 9 (1998) 987–1000.
">[15]</span></a></sup><sup id="fnref:16"><a href="#fn:16" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="D.C. Psichogios, L.H. Ungar, A hybrid neural network-fifirst principles approach to process modeling, AIChE J. 38 (1992) 1499–1511.
">[16]</span></a></sup>中已经探讨了使用物理定律约束神经网络的类似想法，但在这里我们使用现代计算工具重新讨论了它们，并将它们应用于与时间相关的非线性偏微分方程描述等更具挑战性的动力学问题中。<br>在这里，我们强调这一工作与文献中现有的机器学习在计算物理中的应用之间的重要区别。Wang等人<sup id="fnref:17"><a href="#fn:17" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="J.-X. Wang, J. Wu, J. Ling, G. Iaccarino, H. Xiao, A comprehensive physics-informed machine learning framework for predictive turbulence modeling, 2017, arXiv:1701.07102.
">[17]</span></a></sup>最近在湍流建模的背景下也使用了术语“物理信息机器学习”。<sup id="fnref:18"><a href="#fn:18" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Y. Zhu, N. Zabaras, Bayesian deep convolutional encoder-decoder networks for surrogate modeling and uncertainty quantifification, 2018, arXiv:1801. 06879.
">[18]</span></a></sup><sup id="fnref:19"><a href="#fn:19" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="T. Hagge, P. Stinis, E. Yeung, A.M. Tartakovsky, Solving differential equations with unknown constitutive relations as recurrent neural networks, 2017, arXiv:1710.02242.
">[19]</span></a></sup><sup id="fnref:20"><a href="#fn:20" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="R. Tripathy, I. Bilionis, Deep UQ: learning deep neural network surrogate models for high dimensional uncertainty quantifification, 2018, arXiv:1802. 00850.
">[20]</span></a></sup><sup id="fnref:21"><a href="#fn:21" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="P.R. Vlachas, W. Byeon, Z.Y. Wan, T.P. Sapsis, P. Koumoutsakos, Data-driven forecasting of high-dimensional chaotic systems with long-short term memory networks, 2018, arXiv:1802.07486.
">[21]</span></a></sup><sup id="fnref:22"><a href="#fn:22" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="E.J. Parish, K. Duraisamy, A paradigm for data-driven predictive modeling using field inversion and machine learning, J. Comput. Phys. 305 (2016) 758–774.
">[22]</span></a></sup><sup id="fnref:23"><a href="#fn:23" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="K. Duraisamy, Z.J. Zhang, A.P. Singh, New approaches in turbulence and transition modeling using data-driven techniques, in: 53rd AIAA Aerospace Sciences Meeting, 2018, p. 1284.
">[23]</span></a></sup><sup id="fnref:24"><a href="#fn:24" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="J. Ling, A. Kurzawski, J. Templeton, Reynolds averaged turbulence modelling using deep neural networks with embedded invariance, J. Fluid Mech. 807 (2016) 155–166.
">[24]</span></a></sup><sup id="fnref:25"><a href="#fn:25" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Z.J. Zhang, K. Duraisamy, Machine learning methods for data-driven turbulence modeling, in: 22nd AIAA Computational Fluid Dynamics Conference, 2015, p. 2460.
">[25]</span></a></sup><sup id="fnref:26"><a href="#fn:26" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="M. Milano, P. Koumoutsakos, Neural network modeling for near wall turbulent flow, J. Comput. Phys. 182 (2002) 1–26.
">[26]</span></a></sup><sup id="fnref:27"><a href="#fn:27" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="P. Perdikaris, D. Venturi, G.E. Karniadakis, Multififidelity information fusion algorithms for high-dimensional systems and massive data sets, SIAM J. Sci. Comput. 38 (2016) B521–B538.
">[27]</span></a></sup><sup id="fnref:28"><a href="#fn:28" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="R. Rico-Martinez, J. Anderson, I. Kevrekidis, Continuous-time nonlinear signal processing: a neural network based approach for gray box identification, in: Neural Networks for Signal Processing IV. Proceedings of the 1994 IEEE Workshop, IEEE, 1994, pp. 596–605.
">[28]</span></a></sup><sup id="fnref:29"><a href="#fn:29" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="J. Ling, J. Templeton, Evaluation of machine learning algorithms for prediction of regions of high Reynolds averaged Navier Stokes uncertainty, Phys. Fluids 27 (2015) 085103.
">[29]</span></a></sup>等也使用了物理系统预测建模的机器学习方法。所有这些方法都使用机器学习算法，例如支持向量机、随机森林、高斯过程和前馈/卷积/递归神经网络，仅仅将这些算法作为“黑盒子”来使用，即只建立了模型但模型所代表的的物理含义不明。如上所述，本文工作旨在更进一步，为基础微分算子重新构造“定制”激活函数和“定制”损失函数。这使我们能够在理解和欣赏自动微分在深度学习领域中所起的关键作用的同时打开机器学习的黑匣子。一般来说，自动微分，特别是反向传播算法，是目前训练深度模型的主要方法，其通过对模型的参数（如权重和偏差）求导。在这里，我们与使用深度学习中完全相同的自动微分技术求取PINN相对于输入空间坐标和时间的导数，其中的物理过程由偏微分方程所描述。我们观察到，这种结构化方法引入了一种正则化机制，允许我们使用相对简单的前馈神经网络结构，并用少量数据对其进行训练。这个简单想法的有效性可能与Lin、Tegmark和Rolnick<sup id="fnref:30"><a href="#fn:30" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="H.W. Lin, M. Tegmark, D. Rolnick, Why does deep and cheap learning work so well? J. Stat. Phys. 168 (2017) 1223–1247.
">[30]</span></a></sup>提出的评论有关，并提出了许多有趣的问题，有待在未来的研究中定量解决。感谢<sup id="fnref:15"><a href="#fn:15" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="I.E. Lagaris, A. Likas, D.I. Fotiadis, Artifificial neural networks for solving ordinary and partial differential equations, IEEE Trans. Neural Netw. 9 (1998) 987–1000.
">[15]</span></a></sup><sup id="fnref:16"><a href="#fn:16" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="D.C. Psichogios, L.H. Ungar, A hybrid neural network-fifirst principles approach to process modeling, AIChE J. 38 (1992) 1499–1511.
">[16]</span></a></sup><sup id="fnref:31"><a href="#fn:31" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="R. Kondor, N-body networks: a covariant hierarchical neural network architecture for learning atomic potentials, 2018, arXiv:1803.01588.
">[31]</span></a></sup><sup id="fnref:32"><a href="#fn:32" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="R. Kondor, S. Trivedi, On the generalization of equivariance and convolution in neural networks to the action of compact groups, 2018, arXiv:1802. 03690.
">[32]</span></a></sup><sup id="fnref:33"><a href="#fn:33" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="M. Hirn, S. Mallat, N. Poilvert, Wavelet scattering regression of quantum chemical energies, Multiscale Model. Simul. 15 (2017) 827–863.
">[33]</span></a></sup><sup id="fnref:34"><a href="#fn:34" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="S. Mallat, Understanding deep convolutional networks, Philos. Trans. R. Soc. A 374 (2016) 20150203.
">[34]</span></a></sup>等人为本文所提供的灵感。<br>在所有数据驱动求解偏微分方程的例子中，训练数据$N_u$的总数<br>相对较小（几百点到几千点），我们选择使用L-BFGS优化所有损失函数，L-BFGS是一种基于拟牛顿、全批次梯度的优化算法<sup id="fnref:35"><a href="#fn:35" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="D.C. Liu, J. Nocedal, On the limited memory BFGS method for large scale optimization, Math. Program. 45 (1989) 503–528.
">[35]</span></a></sup>。对于更大的数据集，如下一章节中讨论的数据驱动模型，可以使用随机梯度下降及其变种等计算效率更高的小批量优化算法<sup id="fnref:36"><a href="#fn:36" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="I. Goodfellow, Y. Bengio, A. Courville, Deep Learning, MIT Press, 2016.
">[36]</span></a></sup><sup id="fnref:37"><a href="#fn:37" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="D. Kingma, J. Ba, Adam: a method for stochastic optimization, 2014, arXiv:1412.6980.
">[37]</span></a></sup>。尽管理论上不能保证这个过程收敛到一个全局极小值，但我们的经验证据表明，如果给定的偏微分方程是适定的且其解是唯一的，在神经网络结构表达能力充分且有足够数量的配置点$N_f$的前提下我们的方法能够达到良好的预测精度。这一观察结果与方程$4$的均方误差损失所导致的优化景观密切相关，并定义了一个与深度学习的最新理论发展同步的研究开放问题<sup id="fnref:38"><a href="#fn:38" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="A. Choromanska, M. Henaff, M. Mathieu, G.B. Arous, Y. LeCun, The loss surfaces of multilayer networks, in: Artifificial Intelligence and Statistics, pp. 192–204.
">[38]</span></a></sup><sup id="fnref:39"><a href="#fn:39" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="R. Shwartz-Ziv, N. Tishby, Opening the black box of deep neural networks via information, 2017, arXiv:1703.00810.
">[39]</span></a></sup>。为此，我们将使用本文提供的一系列系统敏感性研究来测试所提出方法的稳健性（见附录A和B）。<h3 id="3-1-1-例子（Schrodinger-equation）"><a href="#3-1-1-例子（Schrodinger-equation）" class="headerlink" title="3.1.1 例子（Schrodinger equation）"></a>3.1.1 例子（Schrodinger equation）</h3>这个例子旨在强调我们的方法在处理周期性边界条件、复值解以及控制不同类型非线性偏微分方程中的能力。一维非线性薛定谔方程是研究量子力学系统的经典方程，包括非线性波在光纤和/或波导中的传播、玻色-爱因斯坦凝聚和等离子体波。在光学中，非线性项来源于给定材料的强度相关折射率效应。类似地，玻色-爱因斯坦凝聚的非线性项是N体系统的平均场相互作用的结果。非线性薛定谔方程和周期性边界条件由下式给出<script type="math/tex; mode=display">ih_t+0.5h_{xx}+\mid h \mid^{2}h=0, x\in[-5, 5], t\in[0, \pi/2] \tag{5}</script><script type="math/tex; mode=display">h(0, x)=2sech(x)</script><script type="math/tex; mode=display">h(t, -5)=h(t, 5)</script><script type="math/tex; mode=display">h_x(t, -5)=h_x(t, 5)</script>其中$h(t, x)$为复值解。我们定义$f(t, x)$由下式给出<script type="math/tex; mode=display">f:=ih_t+0.5h_{xx}+\mid h \mid^{2}h</script>然后在$h(t, x)$之前设置一个复值神经网络。事实上，如果将$u$和$v$分别表示$h$的实部和虚部，相当于建立了一个多输出神经网络$h(t, x)=[u(t, x) v(t, x)]$，这就形成了复值多输出PINN-$f(t, x)$。$h(t, x)$和$f(t, x)$的共享参数可以通过最小化如下目标函数来优化得到<script type="math/tex; mode=display">MSE = MSE_0+MSE_b+MSE_f\tag{6}</script><script type="math/tex; mode=display">MSE_0=\frac{1}{N_0}\sum_{i=1}^{N_0}\mid h(0, x_0^{i})-h_0^i\mid^2</script><script type="math/tex; mode=display">MSE_b=\frac{1}{N_b}\sum_{i=1}^{N_b}(\mid h^i( t_b^{i}, -5)-h^i(t_b^i, 5)\mid^2+\mid h^i_x(t^i_b, -5)-h^i_x(t^i_b, 5) \mid^2)</script><script type="math/tex; mode=display">MSE_f = \frac{1}{N_f}\sum_{i=1}^{N_f}\mid f(t_f^{i}, x^i_f)\mid^2</script>这里，$\lbrace x^i_0, h^i_0\rbrace_{i=1}^{N_0}$表示初始值，$\lbrace t_b^i \rbrace_{i=1}^{N_b}$表示边界上的collocation points，$\lbrace t_f^i, x_f^i \rbrace_{i=1}^{N_f}$表示$f(t, x)$上的collocation points。因此，$MSE_0$表示初始数据上的$loss$，$MSE_b$表示周期性边界条件，$MSE_f$为惩罚项，在collocation points上不满足薛定谔方程。<br>为了评估我们的方法的准确性，我们用传统的光谱方法模拟了方程$5$以创建高分辨率数据集。特别地，设初始状态$h(0,x)=2sech(x)$且假设周期性边界条件$h(t -5)=h(t, 5)$，$h_x(t, -5)=h_x(t, 5)$。使用Chebfun package<sup id="fnref:40"><a href="#fn:40" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="T.A. Driscoll, N. Hale, L.N. Trefethen, Chebfun Guide, 2014.
">[40]</span></a></sup>的pectral Fourier discretization with 256 modes和显式$Runge–Kutta$时间积分器以时间间隔$\Delta t=\pi/2·10^-6$对公式$5$积分到时间$t=\pi/2$。通过以上数据驱动设置，我们记录latent function $h(t,x)$在$t=0$时的测量值$\lbrace x^i_0, h^i_0 \rbrace_{i=1}^{N_0}$。特别地，训练集包含从高分辨率数据集中随机选取的$N_0=50$个数据点，以及$N_b=50$ 个配置点$\lbrace t^i_b \rbrace^{N_b}_{i=1}$以确保满足周期边界条件。此外，我们还假设$N_f=20,000$个随机采样配置点以确保方程$5$在解空间内。所有随机采样点的空间位置均通过空间填充Latin Hypercude 采样策略获得<sup id="fnref:41"><a href="#fn:41" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="M. Stein, Large sample properties of simulations using Latin hypercube sampling, Technometrics 29 (1987) 143–151.
">[41]</span></a></sup>。<br>我们的最终目标是推断薛定谔方程$5$在整个时空域的解$h(t, x)$。我们选择使用深度为5、每层包含100个神经元以及激活函数为双曲正切的神经网络来表示latent function$h(t, x) = [u(t, x) v(t,x)]$。一般来说，神经网络应该具有足够的近似能力以满足$u(t, x)$的复杂性。尽管可以采用更系统的处理流程，如贝叶斯优化<sup id="fnref:42"><a href="#fn:42" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="J. Snoek, H. Larochelle, R.P. Adams, Practical bayesian optimization of machine learning algorithms, in: Advances in Neural Information Processing Systems, 2012, pp. 2951–2959.
">[42]</span></a></sup>，以微调神经网络的设计，但在缺乏理论误差/收敛估计的情况下，神经结构/训练过程和基本微分方程的复杂性之间的相互作用仍然不清楚。评估预测解的准确性的一个可行途径是采用贝叶斯方法并监测预测后验分布的方差，但这超出了目前工作的范围，这是今后的研究方向。<br>在这个例子中，我们的设置旨在强调所提出方法相对于过拟合问题的鲁棒性。具体来讲，公式$6$中的$MSE_f$这一项起到了正则化的作用，它对不满足方程$5$的解起到惩罚的作用。因此，在物理系统中经常遇到数据采集成本非常高的情况，而PINN可以采用小样本容量的数据集进行训练。图1总结了我们的实验结果。特别的，图1上图展示了预测的时空解$\mid h(t, x) \mid=\sqrt{u^2({t, x})+v^2({t, x})}$的幅值，以及初始和边界训练数据的位置。使用测试数据获得预测误差，实测$L_2$误差为$1.97·10^{-3}$。预测解的更详细评估如图1的底部图例所示。特别地，我们在$t=0.59，0.79，0.98$的不同时刻对精确解和预测解进行了比较。基于物理信息的神经网络只需要少量的初始数据，就可以准确地捕捉薛定谔方程复杂的非线性特性。<br>到目前为止，连续时间神经网络模型的一个潜在局限性是，为了在整个时空域中实施物理信息约束，需要使用大量的配置点$N_f$。尽管在一维和二维情况中没有太大问题，但它可能会在高维问题中出现问题，因为全局执行物理约束（例如上述偏微分方程）所需的配置点总数将呈指数增长。尽管可以在一定程度上利用稀疏网格或准蒙特卡罗采样方案来解决这一限制<sup id="fnref:43"><a href="#fn:43" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="H.-J. Bungartz, M. Griebel, Sparse grids, Acta Numer. 13 (2004) 147–269.
">[43]</span></a></sup><sup id="fnref:44"><a href="#fn:44" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="I.H. Sloan, H. Wo´zniakowski, When are quasi-Monte Carlo algorithms effiffifficient for high dimensional integrals? J. Complex. 14 (1998) 1–33.
">[44]</span></a></sup>，但在下一节中，我们提出了一种不同的方法，通过引入更结构化的神经网络表示，利用经典的$Runge-Kutta$时间递推方案来规避配置点的需要<sup id="fnref:45"><a href="#fn:45" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="A. Iserles, A First Course in the Numerical Analysis of Differential Equations, vol. 44, Cambridge University Press, 2009.
">[45]</span></a></sup>。<br><img src="/2021/05/07/10.1016j.jcp.2018.10.045_a/fig01.png" alt="fig01"><h2 id="3-2-离散时间模型"><a href="#3-2-离散时间模型" class="headerlink" title="3.2 离散时间模型"></a>3.2 离散时间模型</h2>对方程$2$应用$q$阶Runge-Kutta方法得到以下公式：<script type="math/tex; mode=display">\begin{align}
\notag
&u^{n+c_i}=u^n-\Delta t\sum_{j=1}^q a_ij\mathcal{N}[u^{n+c_j}], i=1,...,q, \\\\
\notag
&u^{n+1}=u^n-\Delta t \sum_{j=1}^q b_j \mathcal{N}[u^{n+c_j}]. 
\end{align}\tag 7</script></li>
</ol>
<p>其中，$u^{n+c_j}(x)=u(t^n+c_j\Delta t, x)$（$j=1,…,q$）。这一通用格式封装了显式和隐式时间递推格式，该格式取决于参数${a_ij, b_j, c_j}$。公式$7$可以被等价地表示为：</p>
<script type="math/tex; mode=display">u^n=u^n_i, i=1,...,q,\\
u^n=u^n_{q+1} \tag{8}</script><p>其中:</p>
<script type="math/tex; mode=display">\begin{align}
\notag
&u^n_j:=u^{n+c_i}+\Delta t \sum^q_{j=1}a_ij \mathcal{N}[u^{n+c_j}], i=1,...,q \\\\
&u^n_{q+1}:=u^{n+1}+\Delta t \sum^q_{j=1}b_j \mathcal{N}[u^{n+c_j}] 
\end{align}\tag{9}</script><p>我们将多输出神经网络置于以下公式之前</p>
<script type="math/tex; mode=display">[u^{n+c_1}(x),...,u^{n+c_q}(x), u^{n+1}(x)] \tag{10}</script><p>上述先验信息以及公式$9$共同构成了以$x$为输入、以公式$11$为输出的PINN：</p>
<script type="math/tex; mode=display">[u^n_1(x),...,u^n_q(x), u^{n}_{q+1}(x)] \tag{11}</script><h3 id="3-2-1-例子（Allen-Cahn方程）"><a href="#3-2-1-例子（Allen-Cahn方程）" class="headerlink" title="3.2.1 例子（Allen-Cahn方程）"></a>3.2.1 例子（Allen-Cahn方程）</h3><p>这个例子旨在强调以上提出的离散时间模型处理不同类型非线性偏微分方程的能力。为此，让我们考虑Allen-Cahn和周期边界条件</p>
<script type="math/tex; mode=display">u_t-0.0001u_{xx}+5u^3-5u=0, x\in [-1, 1], t \in[0, 1]</script><script type="math/tex; mode=display">u(0, x)=x^2cos(\pi x)</script><script type="math/tex; mode=display">u(t, -1)=u(t, 1) \tag{12}</script><script type="math/tex; mode=display">u_x(t, -1)=u_x(t,1)</script><p>Allen-Cahn方程是反散-扩散系统的著名方程。它描述了多组分合金体系的相分离过程，包括有序-无序转变。对于Allen-Cahn方程，公式$9$中的非线性算子为</p>
<script type="math/tex; mode=display">\mathcal{N}[u^{n+c_j}]=-0.0001u_{xx}^{n+c_j}+5(u^{n+c_j})^3-5u^{n+c_j}</script><p>公式$10$和$11$中的共享参数可通过最小化平方误差（公式$13$）学习来得到</p>
<script type="math/tex; mode=display">SSE=SSE_n+SSE_b</script><p>其中，</p>
<script type="math/tex; mode=display">SSE_n=\sum_{j=1}^{q+1} \sum_{i=1}^{N_n} \mid u_j^n(x^{n,i}-u^{n, i}) \mid ^2</script><script type="math/tex; mode=display">\begin{align}
\notag
SSE_b&=\sum_{i=1}^q\mid u^{n+c_i}(-1)-u^{n+c_i}(1)\mid ^2+
\mid u^{n+1}(-1)-u^{n+1}(1) \mid ^2 \\\\
\notag
&+\sum_{i=1}^q \mid u^{n+c_i}_x(-1)-u^{n+c_i}_x(1) \mid ^2 +
\mid u_x^{n+1}(-1)-u^{n+1}_x(1)\mid ^2.
\end{align}</script><p> $\lbrace x^{n, i}, u^{n, i}\rbrace _{i=1}^{N_n}$表示$t^n$时刻的数据。<br> 在经典的数值分析中，受显式格式的稳定性约束或隐式公式的计算复杂性约束，时间步长通常被限制为较小值。随着Runge–Kutta阶数$q$增加，这些限制变得更加严格，并且对于大多数实际问题，需要进行数千到数百万个时间步长以达到最终时间。与经典方法形成鲜明对比的是，这里我们可以使用隐式Runge–Kutta格式，其中包含任意阶数，需要额外付出的成本非常小。这使得我们能够在保证稳定性和高预测精度的同时采取非常大的时间步长，所以允许我们仅通过一次递推就完成整个时空域求解。<br> 在这个例子中，我们使用传统光谱法模拟$Allen-Cahn$方程得到了训练数据和测试数据。具体来讲，设初始条件为$u(0, x)=x^2cos(\pi x)$，周期性边界条件$u(t, -1)=u(t, 1)$和$u_x(t, -1)=u_x(t, 1)$，使用Chebfun包<sup id="fnref:40"><a href="#fn:40" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="T.A. Driscoll, N. Hale, L.N. Trefethen, Chebfun Guide, 2014.
">[40]</span></a></sup>以512modes的傅里叶光谱离散和四阶显式$Runge-Kutta$时间积分器（$\Delta t=10^{-5}$）对公式$12$积分到$t=1.0$。<br>训练集包含$N_n=200$个从精确解中随机抽取的初始数据点，我们的目标是使用$\Delta t =0.8$的一次递推来预测$t=0.9$的解。为此，我们设计了一个包含4个隐藏层和每层200个神经元的PINN，输出则预测了101个感兴趣的数据，其中包含$q=100$的Runge-Kutta阶数$u^{n+c_i}(x), i=1,..,q$以及最终时刻的解$u^{n+1}_x$。该方案的理论误差估计预测了$O(\Delta t^{2q})$<sup id="fnref:45"><a href="#fn:45" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="A. Iserles, A First Course in the Numerical Analysis of Differential Equations, vol. 44, Cambridge University Press, 2009.
">[45]</span></a></sup>的时间误差累积，在我们的例子中，其转化为低于机器精度的误差，即，$\Delta ^{2q}=0.8200≈ 10^{−20}$。据我们所知，这是第一次使用这种高阶隐式$Runge-Kutta$格式。值得注意的是，从$t=0.1$的光滑初始数据出发，我们可以在一个时间步长内预测t=0.9的近似不连续解，其相对$L_2$误差为$6.99·10−3$，如图2所示。这种误差完全归因于神经网络逼近$u(t, x)$的能力，以及误差平方和允许对训练数据进行插值的程度。<br>控制离散时间算法性能的关键参数是龙格库塔算法的阶数$q$和时间步长$\Delta t$。正如我们在附录A和附录B中提供的系统研究中所证明的，低阶方法，例如对应于经典梯形规则的情况$q=1$，以及对应于四阶$Gauss–Legendre$方法的情况$q=2$，不能保留它们对大时间步长的预测精度，因此，需要将其拆分成多个小时间步长。另一方面，将$Runge–Kutta$阶数设置为32个甚至更高，允许我们采取非常大的时间步长，并在不牺牲预测准确性的情况下使用一次地推有效地解决问题。此外，该方法能够充分保证数值稳定性，因为隐式$Gauss–Legendre$是唯一一类无论阶数如何都保持A-stable的时间递推格式，因此非常适合于刚性问题<sup id="fnref:45"><a href="#fn:45" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="A. Iserles, A First Course in the Numerical Analysis of Differential Equations, vol. 44, Cambridge University Press, 2009.
">[45]</span></a></sup>。这些特性对于实现如此简单的算法来说是前所未有的，并且说明了我们离散时间方法的一个关键亮点。</p>
<span id="more"></span>
<p><details><summary>参考文献</summary></details></p>
<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">A. Krizhevsky, I. Sutskever, G.E. Hinton, Imagenet classifification with deep convolutional neural networks, in: Advances in Neural Information Processing Systems, 2012, pp. 1097–1105.<a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">B.M. Lake, R. Salakhutdinov, J.B. Tenenbaum, Human-level concept learning through probabilistic program induction, Science 350 (2015) 1332–1338.<a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">B. Alipanahi, A. Delong, M.T. Weirauch, B.J. Frey, Predicting the sequence specifificities of DNA- and RNA-binding proteins by deep learning, Nat. Biotechnol. 33 (2015) 831–838.<a href="#fnref:3" rev="footnote"> ↩</a></span></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">M. Raissi, P. Perdikaris, G.E. Karniadakis, Inferring solutions of differential equations using noisy multi-fifidelity data, J. Comput. Phys. 335 (2017) 736–746.<a href="#fnref:4" rev="footnote"> ↩</a></span></li><li id="fn:5"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">5.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">M. Raissi, P. Perdikaris, G.E. Karniadakis, Machine learning of linear differential equations using Gaussian processes, J. Comput. Phys. 348 (2017) 683–693.<a href="#fnref:5" rev="footnote"> ↩</a></span></li><li id="fn:6"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">6.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">H. Owhadi, Bayesian numerical homogenization, Multiscale Model. Simul. 13 (2015) 812–828.<a href="#fnref:6" rev="footnote"> ↩</a></span></li><li id="fn:7"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">7.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">C.E. Rasmussen, C.K. Williams, Gaussian Processes for Machine Learning, vol. 1, MIT Press, Cambridge, 2006.<a href="#fnref:7" rev="footnote"> ↩</a></span></li><li id="fn:8"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">8.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">M. Raissi, P. Perdikaris, G.E. Karniadakis, Numerical Gaussian processes for time-dependent and non-linear partial differential equations, 2017, arXiv: 1703.10230.<a href="#fnref:8" rev="footnote"> ↩</a></span></li><li id="fn:9"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">9.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">M. Raissi, G.E. Karniadakis, Hidden physics models: machine learning of nonlinear partial differential equations, 2017, arXiv:1708.00588.<a href="#fnref:9" rev="footnote"> ↩</a></span></li><li id="fn:10"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">10.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">H. Owhadi, C. Scovel, T. Sullivan, et al., Brittleness of Bayesian inference under fifinite information in a continuous world, Electron. J. Stat. 9 (2015) 1–79.<a href="#fnref:10" rev="footnote"> ↩</a></span></li><li id="fn:11"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">11.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">K. Hornik, M. Stinchcombe, H. White, Multilayer feedforward networks are universal approximators, Neural Netw. 2 (1989) 359–366.<a href="#fnref:11" rev="footnote"> ↩</a></span></li><li id="fn:12"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">12.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">A.G. Baydin, B.A. Pearlmutter, A.A. Radul, J.M. Siskind, Automatic differentiation in machine learning: a survey, 2015, arXiv:1502.05767.<a href="#fnref:12" rev="footnote"> ↩</a></span></li><li id="fn:13"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">13.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">C. Basdevant, M. Deville, P. Haldenwang, J. Lacroix, J. Ouazzani, R. Peyret, P. Orlandi, A. Patera, Spectral and fifinite difference solutions of the Burgers equation, Comput. Fluids 14 (1986) 23–41.<a href="#fnref:13" rev="footnote"> ↩</a></span></li><li id="fn:14"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">14.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">S.H. Rudy, S.L. Brunton, J.L. Proctor, J.N. Kutz, Data-driven discovery of partial differential equations, Sci. Adv. 3 (2017).<a href="#fnref:14" rev="footnote"> ↩</a></span></li><li id="fn:15"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">15.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">I.E. Lagaris, A. Likas, D.I. Fotiadis, Artifificial neural networks for solving ordinary and partial differential equations, IEEE Trans. Neural Netw. 9 (1998) 987–1000.<a href="#fnref:15" rev="footnote"> ↩</a></span></li><li id="fn:16"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">16.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">D.C. Psichogios, L.H. Ungar, A hybrid neural network-fifirst principles approach to process modeling, AIChE J. 38 (1992) 1499–1511.<a href="#fnref:16" rev="footnote"> ↩</a></span></li><li id="fn:17"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">17.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">J.-X. Wang, J. Wu, J. Ling, G. Iaccarino, H. Xiao, A comprehensive physics-informed machine learning framework for predictive turbulence modeling, 2017, arXiv:1701.07102.<a href="#fnref:17" rev="footnote"> ↩</a></span></li><li id="fn:18"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">18.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">Y. Zhu, N. Zabaras, Bayesian deep convolutional encoder-decoder networks for surrogate modeling and uncertainty quantifification, 2018, arXiv:1801. 06879.<a href="#fnref:18" rev="footnote"> ↩</a></span></li><li id="fn:19"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">19.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">T. Hagge, P. Stinis, E. Yeung, A.M. Tartakovsky, Solving differential equations with unknown constitutive relations as recurrent neural networks, 2017, arXiv:1710.02242.<a href="#fnref:19" rev="footnote"> ↩</a></span></li><li id="fn:20"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">20.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">R. Tripathy, I. Bilionis, Deep UQ: learning deep neural network surrogate models for high dimensional uncertainty quantifification, 2018, arXiv:1802. 00850.<a href="#fnref:20" rev="footnote"> ↩</a></span></li><li id="fn:21"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">21.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">P.R. Vlachas, W. Byeon, Z.Y. Wan, T.P. Sapsis, P. Koumoutsakos, Data-driven forecasting of high-dimensional chaotic systems with long-short term memory networks, 2018, arXiv:1802.07486.<a href="#fnref:21" rev="footnote"> ↩</a></span></li><li id="fn:22"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">22.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">E.J. Parish, K. Duraisamy, A paradigm for data-driven predictive modeling using field inversion and machine learning, J. Comput. Phys. 305 (2016) 758–774.<a href="#fnref:22" rev="footnote"> ↩</a></span></li><li id="fn:23"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">23.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">K. Duraisamy, Z.J. Zhang, A.P. Singh, New approaches in turbulence and transition modeling using data-driven techniques, in: 53rd AIAA Aerospace Sciences Meeting, 2018, p. 1284.<a href="#fnref:23" rev="footnote"> ↩</a></span></li><li id="fn:24"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">24.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">J. Ling, A. Kurzawski, J. Templeton, Reynolds averaged turbulence modelling using deep neural networks with embedded invariance, J. Fluid Mech. 807 (2016) 155–166.<a href="#fnref:24" rev="footnote"> ↩</a></span></li><li id="fn:25"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">25.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">Z.J. Zhang, K. Duraisamy, Machine learning methods for data-driven turbulence modeling, in: 22nd AIAA Computational Fluid Dynamics Conference, 2015, p. 2460.<a href="#fnref:25" rev="footnote"> ↩</a></span></li><li id="fn:26"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">26.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">M. Milano, P. Koumoutsakos, Neural network modeling for near wall turbulent flow, J. Comput. Phys. 182 (2002) 1–26.<a href="#fnref:26" rev="footnote"> ↩</a></span></li><li id="fn:27"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">27.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">P. Perdikaris, D. Venturi, G.E. Karniadakis, Multififidelity information fusion algorithms for high-dimensional systems and massive data sets, SIAM J. Sci. Comput. 38 (2016) B521–B538.<a href="#fnref:27" rev="footnote"> ↩</a></span></li><li id="fn:28"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">28.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">R. Rico-Martinez, J. Anderson, I. Kevrekidis, Continuous-time nonlinear signal processing: a neural network based approach for gray box identification, in: Neural Networks for Signal Processing IV. Proceedings of the 1994 IEEE Workshop, IEEE, 1994, pp. 596–605.<a href="#fnref:28" rev="footnote"> ↩</a></span></li><li id="fn:29"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">29.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">J. Ling, J. Templeton, Evaluation of machine learning algorithms for prediction of regions of high Reynolds averaged Navier Stokes uncertainty, Phys. Fluids 27 (2015) 085103.<a href="#fnref:29" rev="footnote"> ↩</a></span></li><li id="fn:30"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">30.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">H.W. Lin, M. Tegmark, D. Rolnick, Why does deep and cheap learning work so well? J. Stat. Phys. 168 (2017) 1223–1247.<a href="#fnref:30" rev="footnote"> ↩</a></span></li><li id="fn:31"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">31.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">R. Kondor, N-body networks: a covariant hierarchical neural network architecture for learning atomic potentials, 2018, arXiv:1803.01588.<a href="#fnref:31" rev="footnote"> ↩</a></span></li><li id="fn:32"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">32.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">R. Kondor, S. Trivedi, On the generalization of equivariance and convolution in neural networks to the action of compact groups, 2018, arXiv:1802. 03690.<a href="#fnref:32" rev="footnote"> ↩</a></span></li><li id="fn:33"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">33.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">M. Hirn, S. Mallat, N. Poilvert, Wavelet scattering regression of quantum chemical energies, Multiscale Model. Simul. 15 (2017) 827–863.<a href="#fnref:33" rev="footnote"> ↩</a></span></li><li id="fn:34"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">34.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">S. Mallat, Understanding deep convolutional networks, Philos. Trans. R. Soc. A 374 (2016) 20150203.<a href="#fnref:34" rev="footnote"> ↩</a></span></li><li id="fn:35"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">35.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">D.C. Liu, J. Nocedal, On the limited memory BFGS method for large scale optimization, Math. Program. 45 (1989) 503–528.<a href="#fnref:35" rev="footnote"> ↩</a></span></li><li id="fn:36"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">36.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">I. Goodfellow, Y. Bengio, A. Courville, Deep Learning, MIT Press, 2016.<a href="#fnref:36" rev="footnote"> ↩</a></span></li><li id="fn:37"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">37.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">D. Kingma, J. Ba, Adam: a method for stochastic optimization, 2014, arXiv:1412.6980.<a href="#fnref:37" rev="footnote"> ↩</a></span></li><li id="fn:38"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">38.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">A. Choromanska, M. Henaff, M. Mathieu, G.B. Arous, Y. LeCun, The loss surfaces of multilayer networks, in: Artifificial Intelligence and Statistics, pp. 192–204.<a href="#fnref:38" rev="footnote"> ↩</a></span></li><li id="fn:39"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">39.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">R. Shwartz-Ziv, N. Tishby, Opening the black box of deep neural networks via information, 2017, arXiv:1703.00810.<a href="#fnref:39" rev="footnote"> ↩</a></span></li><li id="fn:40"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">40.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">T.A. Driscoll, N. Hale, L.N. Trefethen, Chebfun Guide, 2014.<a href="#fnref:40" rev="footnote"> ↩</a></span></li><li id="fn:41"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">41.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">M. Stein, Large sample properties of simulations using Latin hypercube sampling, Technometrics 29 (1987) 143–151.<a href="#fnref:41" rev="footnote"> ↩</a></span></li><li id="fn:42"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">42.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">J. Snoek, H. Larochelle, R.P. Adams, Practical bayesian optimization of machine learning algorithms, in: Advances in Neural Information Processing Systems, 2012, pp. 2951–2959.<a href="#fnref:42" rev="footnote"> ↩</a></span></li><li id="fn:43"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">43.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">H.-J. Bungartz, M. Griebel, Sparse grids, Acta Numer. 13 (2004) 147–269.<a href="#fnref:43" rev="footnote"> ↩</a></span></li><li id="fn:44"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">44.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">I.H. Sloan, H. Wo´zniakowski, When are quasi-Monte Carlo algorithms effiffifficient for high dimensional integrals? J. Complex. 14 (1998) 1–33.<a href="#fnref:44" rev="footnote"> ↩</a></span></li><li id="fn:45"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">45.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">A. Iserles, A First Course in the Numerical Analysis of Differential Equations, vol. 44, Cambridge University Press, 2009.<a href="#fnref:45" rev="footnote"> ↩</a></span></li><li id="fn:46"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">46.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">T. Von Kármán, Aerodynamics, vol. 9, McGraw-Hill, New York, 1963.<a href="#fnref:46" rev="footnote"> ↩</a></span></li><li id="fn:47"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">47.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">G. Karniadakis, S. Sherwin, Spectral/hp Element Methods for Computational Fluid Dynamics, Oxford University Press, 2013.<a href="#fnref:47" rev="footnote"> ↩</a></span></li><li id="fn:48"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">48.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">T. Dauxois, Fermi, Pasta, Ulam and a mysterious lady, 2008, arXiv:0801.1590.<a href="#fnref:48" rev="footnote"> ↩</a></span></li><li id="fn:49"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">49.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">M. Abadi, A. Agarwal, P. Barham, E. Brevdo, Z. Chen, C. Citro, G.S. Corrado, A. Davis, J. Dean, M. Devin, et al., Tensorflow: large-scale machine learning on heterogeneous distributed systems, 2016, arXiv:1603.04467.<a href="#fnref:49" rev="footnote"> ↩</a></span></li><li id="fn:50"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">50.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">S.L. Brunton, J.L. Proctor, J.N. Kutz, Discovering governing equations from data by sparse identifification of nonlinear dynamical systems, Proc. Natl. Acad. Sci. 113 (2016) 3932–3937.<a href="#fnref:50" rev="footnote"> ↩</a></span></li></ol></div></div><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>文献翻译</category>
      </categories>
      <tags>
        <tag>深度学习与计算地球物理</tag>
      </tags>
  </entry>
  <entry>
    <title>Physics-informed neural networks:Translation Part II</title>
    <url>/2021/05/14/10.1016j.jcp.2018.10.045_b/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>原文地址：<a href="https://www.sciencedirect.com/science/article/pii/S0021999118307125">PINN：深度学习框架下求解含有非线性偏微分方程的正问题、反问题</a><br>doi:<a href="http://sci-hub.ren/10.1016/j.jcp.2018.10.045">10.1016/j.jcp.2018.10.045</a></p>
<h1 id="Data-driven-discovery-of-partial-differential-equations"><a href="#Data-driven-discovery-of-partial-differential-equations" class="headerlink" title="Data-driven discovery of partial differential equations"></a>Data-driven discovery of partial differential equations</h1><p>在我们研究的当前部分，我们将注意力转移到数据驱动的偏微分方程发现问题上<sup id="fnref:5"><a href="#fn:5" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="M. Raissi, P. Perdikaris, G.E. Karniadakis, Machine learning of linear differential equations using Gaussian processes, J. Comput. Phys. 348 (2017) 683–693.
">[5]</span></a></sup><sup id="fnref:9"><a href="#fn:9" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="M. Raissi, G.E. Karniadakis, Hidden physics models: machine learning of nonlinear partial differential equations, 2017, arXiv:1708.00588.
">[9]</span></a></sup><sup id="fnref:14"><a href="#fn:14" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="S.H. Rudy, S.L. Brunton, J.L. Proctor, J.N. Kutz, Data-driven discovery of partial differential equations, Sci. Adv. 3 (2017).
">[14]</span></a></sup>。在第$4.1$节和第$4.2$节中，我们提出了两种不同类型的算法，即连续时间模型和离散时间模型，并通过各种规范问题(canonical problems)的视角强调了它们的性质和性能。</p>
<h1 id="4-1-连续时间模型"><a href="#4-1-连续时间模型" class="headerlink" title="4.1 连续时间模型"></a>4.1 连续时间模型</h1><p>首先，让我们回忆方程$1$并和$3.1$节相类似定义$f(t,x)$由公式$1$左侧给定，即</p>
<script type="math/tex; mode=display">f:=u_t+\mathcal{N}[u:\lambda]\tag{14}</script><p>我们继续使用深度神经网络近似$u(t, x)$。此假设以及公式$14$构建了一个PINN。该网络可以通过使用自动微分来对方程的不同部分应用链式法则推导出来<sup id="fnref:12"><a href="#fn:12" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="A.G. Baydin, B.A. Pearlmutter, A.A. Radul, J.M. Siskind, Automatic differentiation in machine learning: a survey, 2015, arXiv:1502.05767.
">[12]</span></a></sup>。值得注意的是，微分算子$\lambda$的参数变为了PINN$f(t,x)$的参数。</p>
<h2 id="4-1-1-例子（Naiver-Stokes方程）"><a href="#4-1-1-例子（Naiver-Stokes方程）" class="headerlink" title="4.1.1 例子（Naiver-Stokes方程）"></a>4.1.1 例子（Naiver-Stokes方程）</h2><p>我们的下一个例子涉及到不可压缩流体流动的现实场景，由无处不在的Navier-Stokes方程所描述。Naiver-Stokes方程描述了许多具有科学和工程意义的物理现象。它们可以用来模拟天气、洋流、管道中的水流和机翼周围的气流。完整和简化的Navier-Stokes方程有助于飞机和汽车的设计、血液流动的研究、电站的设计、污染物扩散的分析以及许多其他应用。让我们考虑二维的Navier-Stokes方程：</p>
<script type="math/tex; mode=display">u_t+\lambda_1(uu_x+vu_y)=-p_x+\lambda_2(u_{xx}+u_{yy})</script><script type="math/tex; mode=display">v_t+\lambda_1(uv_x+uv_y)=-p_y+\lambda_2(v_{xx}+v_{yy}) \tag{15}</script><p>其中，$u(t, x, y)$表示速度场的$x$分量，$v(t, x, y)$表示速度场$y$分量，$p(t, x, y)$表示压力。$\lambda=(\lambda_1, \lambda_2)$为未知参数。通过在无散度函数集合中搜索$Naiver-Stokes$方程的解，即：</p>
<script type="math/tex; mode=display">u_x+v_y=0\tag{16}</script><p>这个额外的方程是描述流体质量守恒的不可压缩流体的连续性方程。我们假设</p>
<script type="math/tex; mode=display">u=\psi_y, v=-\psi_x</script><p>$\psi(t, x, y)$为隐函数。在此假设下，能够自动满足连续方程$16$。给定速度场的噪声测量</p>
<script type="math/tex; mode=display">\lbrace t^i, x^i, y^i, u^i, v^i\rbrace^N_{i=1}</script><p>我们希望学习到参数$\lambda$以及压力场$p(t, x, y)$。<br>定义$f(t, x, y)$和$g(t, x, y)$为：</p>
<script type="math/tex; mode=display">f:=u_t+\lambda_1(uu_x+vu_y)+p_x-\lambda_2(u_{xx}+u_{yy})</script><script type="math/tex; mode=display">g:=v_t+\lambda_1(uv_x+vv_y)+p_y-\lambda_2(v_{xx}+v_{yy})</script><p>然后使用有两个输出的神经网络近似$[\psi(t, x, y) p(t, x, y)]$。此先验假设以及公式$17$、$18$构成了PINN网络$[f(t, x, y) g(t, x, y)]$。$Navier-Stokes$算子的参数$\lambda$以及神经网络$[\psi(t, x, y), p(t, x, y)]$和$[f(t, x, y), g(t, x, y)]$的参数可以通过最小化均方误差函数$19$来训练得到。</p>
<script type="math/tex; mode=display">MSE:=\frac{1}{N} \sum_{i=1}^N(\mid u(t^i, x^i, y^i)-u^i \mid^2+\mid v(t^i, x^i, y^i)-v^i\mid^2) \\\\ +\frac{1}N \sum_{i=1}^N(\mid f(t^i, x^i, y^i)\mid^2+\mid g(t^i, x^i, y^i)\mid ^2) \tag{19}</script><p> 这里我们讨论不可压缩流体通过圆柱体的问题，aproblem known to exhibit rich dynamic behavior and transitions for different regimes of theReynolds number $Re=u_\infty D/v$。假设一个无量纲自由流体速度为$u_\infty=1$,圆柱直径$D=1$，运动黏度$v=0.01$，该系统呈现周期性稳态行为，其特征是圆柱wake中的不对称涡旋脱落模式，即$Karman vortex street$<sup id="fnref:46"><a href="#fn:46" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="T. Von Kármán, Aerodynamics, vol. 9, McGraw-Hill, New York, 1963.
">[46]</span></a></sup>。<br> 为生成针对该问题的高分辨率数据集，我们采用了光谱/hp元素求解器$NekTar$<sup id="fnref:47"><a href="#fn:47" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="G. Karniadakis, S. Sherwin, Spectral/hp Element Methods for Computational Fluid Dynamics, Oxford University Press, 2013.
">[47]</span></a></sup>。具体来说，将解空间在空间域离散为包含412个三角形元素的曲面细分，在每个元素中，解都被近似为十阶分层半正交$Jacobi$多项式展开式的线性组合。我们假设左边界有均匀的自由流体速度剖面，在圆柱体下游25直径处的右边界施加零压力流出条件，并在上下边界$[-15, 25]\times[-8, 8]$的区域添加周期边界条件。我们是用三阶刚性稳定方法对公式$15$进行积分，直到该系统达到周期稳定状态，如图3(a)所示。在接下来的内容中，与这个稳态解相对应的数据集的一小部分将被用于模型训练，而剩余数据则用于模型预测。为简单起见，我们选择将采样限制在圆柱体下游的矩形区域，如图3(a)所示。<br><img src="/2021/05/14/10.1016j.jcp.2018.10.045_b/fig03.png" alt="fig03"><br>给定动沿流向$u(t, x, y)$和横向$v(t, x , y)$速度分量上的散射和势噪声数据，我们的目标是确定未知参数$\lambda_1$和$\lambda_2$，并定性地、准确地重建圆柱wake中的整个压力场$p(t, x, y)$，该场只能被识别为常数。为此，我们随机从高分辨率数据中进行降采样来得到训练数据。为了突出我们的方法在散射和稀疏数据中的学习能力，我们选取了$N=5,000$。仅相当于图3(b)所示的可用数据总数1%的数据。此外，我们还绘制了模型训练后预测速度分量$u(t, x, y)$和$v(t, x, y)$的代表性快照。这里使用的神经网络包含9层，每层20个神经元。<br>此例子结果的总结如图4所示。我们发现，即使训练数据中有非常多的噪声，PINN依旧能够非常准确地确定未知参数$\lambda_1$、$\lambda_2$。具体来说，对于无噪声的训练数据，估计误差$\lambda_1$和$\lambda_2$分别为$0.078\%$和$4.67\%$。当训练数据中包含$1\%$的不相关高斯噪声时，预测仍然是鲁棒的，两系数的预测误差分别为$0.17\%$和$5.70\%$。<br>一个更有趣的结果来自于该网络在没有任何关于压力本身的训练数据的情况下对整个压力场$p(t, x, y)$的高精度定性预测能力。与精确压力场的对比如图4所示。精确压力场和预测压力场之间的大小差异是由不可压缩Navier–Stokes系统的本质所决定的，因为压力场只有在一个常数以内才可被识别。通过利用基础物理从辅助测量值中推断出感兴趣的连续变量值，这是PINN所提供的更强能力的表现，展示了它们在求解高维度反问题中的潜力。<br>到目前为止，我们均假设数据点在整个时空域中可用。在许多实际情况下，人们可能只能在不同的时刻观察系统。在下一节中，我们将介绍一种不同的方法，该方法仅使用两个数据快照来解决数据驱动的发现问题。我们将看到，通过利用经典的Runge-Kutta时间递推方案，人们可以构建离散时间的PINN，即使数据快照之间的时间间隔非常大，其也可以保持较高的预测精度。</p>
<h1 id="4-2-离散时间模型"><a href="#4-2-离散时间模型" class="headerlink" title="4.2 离散时间模型"></a>4.2 离散时间模型</h1><p>对公式$1$应用$q$阶Runge-Kutta方法得到以下公式</p>
<script type="math/tex; mode=display">u^{n+c_i}=u^n-\Delta t \sum_{j=1}^qa_ij \mathcal{N}[u^{n+c_j}; \lambda], i=1,...,q,</script><script type="math/tex; mode=display">u^{n+1}=u^{n}-\Delta t \sum_{j=1}^{q}b_j \mathcal{N}[u^{n+c_j};\lambda] \tag{20}</script><p>其中，$u^{n+c_j}(x)=u(t^n+c_j\Delta t, x)$是系统在$t^n+c_j$($j=1,…,q$)时刻的隐藏状态。该通用形式包含了显式和隐式的时间递推格式，该格式取决于参数$\lbrace {a_ij, b_j, c_j}\rbrace$的选取。公式$20$可等价为：</p>
<script type="math/tex; mode=display">u^n=u_i^n, i=1....,q,\\
u^{n+1}=u_i^{n+1},i=1,...,q \tag{21}</script><p>其中</p>
<script type="math/tex; mode=display">u_i^n:=u^{n+c_i}+\Delta t \sum_{j=1}^{q}a_{ij}\mathcal{N}[c^{n+c_j};\lambda],i=1,...,q,</script><script type="math/tex; mode=display">u_i^{n+1}:=u^{n+c_i}+\Delta t \sum_{j=1}^{q}(a_ij-b_j) \mathcal{N}[u^{n+c_j};\lambda], i=1,...,q \tag{22}</script><p>将多输出神经网络置于</p>
<script type="math/tex; mode=display">[u^{n+c_1}(x),...,u^{n+c_q}(x)] \tag{23}</script><p>之前，<br>先验假设以及公式$22$形成了两个PINN：</p>
<script type="math/tex; mode=display">[u_1^n(x),...,u_q^n(x), u_{q+1}^n(x)] \tag{24}</script><p>以及</p>
<script type="math/tex; mode=display">[u_1^{n+1}(x),...,u_q^{n+1}(x),u_{q+1}^{n+1}(x)] \tag{25}</script><p>给定两个不同时刻$t^n$和$t^{n+1}$的时间切片$\lbrace x^n,  u^n \rbrace$和$\lbrace x^{n+1}, u^{n+1} \rbrace$，神经网络$23$、$24$和$25$的共享参数以及微分算子的参数$\lambda$可以通过最小化平方误差$26$得到。</p>
<script type="math/tex; mode=display">SSE=SSE_n+SSE_n+1 \tag{26}</script><p>其中</p>
<script type="math/tex; mode=display">SSE_n:=\sum_{j=1}^q \sum_{i=1}^{N_n}  \mid u_j^n(x^{n, i})-u^{n, i}\mid^2</script><script type="math/tex; mode=display">SSE_{n+1}:=\sum_{j=1}^n \sum_{i=1}^{N_{n+1}} \mid u_j^{n+1}(x^{n+1,i}-u^{n+1,i})\mid ^2</script><script type="math/tex; mode=display">x^n=\lbrace x^{n,i} \rbrace _{i=1}^{N_n}, u^n=\lbrace u^{n, i} \rbrace _{i=1}^{N_n}</script><h3 id="4-2-1-例子"><a href="#4-2-1-例子" class="headerlink" title="4.2.1 例子"></a>4.2.1 例子</h3><p>我们的最后一个例子旨在强调所提出的框架在处理涉及高阶导数的偏微分方程的能力。这里，我们考虑浅水表面上波浪的数学模型；$Korteweg–de Vries(KdV)$方程。这个方程也可以看作是带有dispersive项的Burgers方程。KdV方程与物理问题有几方面联系：它描述了长一维波在许多物理环境中的演化。这种物理环境包括具有弱非线性恢复力的浅水波、密度分层海洋中的长内波（long internal waves）、等离子体中的离子声波和晶格上的声波。此外，$KdV$方程是连续极限下$Fermi-Pasta-Ulam$问题<sup id="fnref:48"><a href="#fn:48" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="T. Dauxois, Fermi, Pasta, Ulam and a mysterious lady, 2008, arXiv:0801.1590.
">[48]</span></a></sup>中弦的控制方程。$KdV$公式如下:</p>
<script type="math/tex; mode=display">u_t+\lambda_1uu_x+\lambda_2u_{xxx} = 0 \tag{27}</script><p>$(\lambda_1, \lambda_2)$为未知参数。对于KdV方程，公式$22$中的非线性算子由以下公式给定：</p>
<script type="math/tex; mode=display">\mathcal{N}[u^{n+c_j}]=\lambda_1 u^{n+c_j}u_x^{n+c_j}-\lambda_2u_{xxx}^{n+c_j}</script><p>公式$23$、$24$、$25$的共享参数以及KdV方程的参数$\lambda=(\lambda_1, \lambda_2)$可以通过最小化平方误差公式$26$得到。<br>我们通过使用传统谱方法模拟公式$27$来得到训练数据和测试数据。具体来讲，初始边界条件为$u(0, x)=cos(\pi x)$以及周期性边界条件，使用$Chebfun$包以512个modes的谱傅里叶离散以及四阶显式$Runge-Kutta$时间积分器以离散时间步长$\Delta t=10^{-6}$对公式$27$积分到$t=1.0$。利用该数据集，我们提取$t^n=0.2$和$t^{n+1}=0.8$的两个解的切片，并使用$N_n=199$和$N_{n+1}=201$对其进行随机降采样来生成训练集。然后我们利用这些数据来训练离散时间PINN，loss函数平方误差为$26$，优化器为L-BFGS<sup id="fnref:35"><a href="#fn:35" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="D.C. Liu, J. Nocedal, On the limited memory BFGS method for large scale optimization, Math. Program. 45 (1989) 503–528.
">[35]</span></a></sup>。网络架构包括4个隐藏层，每层有50个神经元，以及一个用于预测q阶Runge-Kutta解（即$u^{n+c_j}(x)$）的输出层（$j=1,…,q$）其中，q是生成及其精度阶时间误差累积的经验值，其由以下公式决定：</p>
<script type="math/tex; mode=display">q=0.5log\epsilon /log(\Delta t)</script><p>该例子的时间步长为$\Delta t = 0.6$。<br>实验结果如图5所示。在顶部图例中，我们给出了精确解$u(t, x)$，以及用于训练的两个数据快照的位置。在中间的图例中给出了精确解和训练数据的更详细的概述。方程$27$的复杂非线性动力学是如何导致两个快照之间的解的形式存在显著差异的是需要我们注意的地方。尽管存在这些差异，并且两个训练快照之间存在较大的时间间隔，但是无论训练数据是否被噪声破坏，我们的方法都能够正确确定未知参数。具体来说，对于无噪声的训练数据，估计误差$\lambda_1$和$\lambda_2$分别为$0.023\%$和$0.006\%$，而训练数据中噪声为$1\%$的情况返回的误差分别为$0.057\%$和$0.017\%$。</p>
<span id="more"></span>
<p><details></details></p>
<summary>参考文献</summary>


<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">A. Krizhevsky, I. Sutskever, G.E. Hinton, Imagenet classifification with deep convolutional neural networks, in: Advances in Neural Information Processing Systems, 2012, pp. 1097–1105.<a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">B.M. Lake, R. Salakhutdinov, J.B. Tenenbaum, Human-level concept learning through probabilistic program induction, Science 350 (2015) 1332–1338.<a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">B. Alipanahi, A. Delong, M.T. Weirauch, B.J. Frey, Predicting the sequence specifificities of DNA- and RNA-binding proteins by deep learning, Nat. Biotechnol. 33 (2015) 831–838.<a href="#fnref:3" rev="footnote"> ↩</a></span></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">M. Raissi, P. Perdikaris, G.E. Karniadakis, Inferring solutions of differential equations using noisy multi-fifidelity data, J. Comput. Phys. 335 (2017) 736–746.<a href="#fnref:4" rev="footnote"> ↩</a></span></li><li id="fn:5"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">5.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">M. Raissi, P. Perdikaris, G.E. Karniadakis, Machine learning of linear differential equations using Gaussian processes, J. Comput. Phys. 348 (2017) 683–693.<a href="#fnref:5" rev="footnote"> ↩</a></span></li><li id="fn:6"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">6.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">H. Owhadi, Bayesian numerical homogenization, Multiscale Model. Simul. 13 (2015) 812–828.<a href="#fnref:6" rev="footnote"> ↩</a></span></li><li id="fn:7"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">7.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">C.E. Rasmussen, C.K. Williams, Gaussian Processes for Machine Learning, vol. 1, MIT Press, Cambridge, 2006.<a href="#fnref:7" rev="footnote"> ↩</a></span></li><li id="fn:8"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">8.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">M. Raissi, P. Perdikaris, G.E. Karniadakis, Numerical Gaussian processes for time-dependent and non-linear partial differential equations, 2017, arXiv: 1703.10230.<a href="#fnref:8" rev="footnote"> ↩</a></span></li><li id="fn:9"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">9.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">M. Raissi, G.E. Karniadakis, Hidden physics models: machine learning of nonlinear partial differential equations, 2017, arXiv:1708.00588.<a href="#fnref:9" rev="footnote"> ↩</a></span></li><li id="fn:10"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">10.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">H. Owhadi, C. Scovel, T. Sullivan, et al., Brittleness of Bayesian inference under fifinite information in a continuous world, Electron. J. Stat. 9 (2015) 1–79.<a href="#fnref:10" rev="footnote"> ↩</a></span></li><li id="fn:11"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">11.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">K. Hornik, M. Stinchcombe, H. White, Multilayer feedforward networks are universal approximators, Neural Netw. 2 (1989) 359–366.<a href="#fnref:11" rev="footnote"> ↩</a></span></li><li id="fn:12"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">12.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">A.G. Baydin, B.A. Pearlmutter, A.A. Radul, J.M. Siskind, Automatic differentiation in machine learning: a survey, 2015, arXiv:1502.05767.<a href="#fnref:12" rev="footnote"> ↩</a></span></li><li id="fn:13"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">13.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">C. Basdevant, M. Deville, P. Haldenwang, J. Lacroix, J. Ouazzani, R. Peyret, P. Orlandi, A. Patera, Spectral and fifinite difference solutions of the Burgers equation, Comput. Fluids 14 (1986) 23–41.<a href="#fnref:13" rev="footnote"> ↩</a></span></li><li id="fn:14"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">14.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">S.H. Rudy, S.L. Brunton, J.L. Proctor, J.N. Kutz, Data-driven discovery of partial differential equations, Sci. Adv. 3 (2017).<a href="#fnref:14" rev="footnote"> ↩</a></span></li><li id="fn:15"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">15.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">I.E. Lagaris, A. Likas, D.I. Fotiadis, Artifificial neural networks for solving ordinary and partial differential equations, IEEE Trans. Neural Netw. 9 (1998) 987–1000.<a href="#fnref:15" rev="footnote"> ↩</a></span></li><li id="fn:16"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">16.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">D.C. Psichogios, L.H. Ungar, A hybrid neural network-fifirst principles approach to process modeling, AIChE J. 38 (1992) 1499–1511.<a href="#fnref:16" rev="footnote"> ↩</a></span></li><li id="fn:17"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">17.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">J.-X. Wang, J. Wu, J. Ling, G. Iaccarino, H. Xiao, A comprehensive physics-informed machine learning framework for predictive turbulence modeling, 2017, arXiv:1701.07102.<a href="#fnref:17" rev="footnote"> ↩</a></span></li><li id="fn:18"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">18.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">Y. Zhu, N. Zabaras, Bayesian deep convolutional encoder-decoder networks for surrogate modeling and uncertainty quantifification, 2018, arXiv:1801. 06879.<a href="#fnref:18" rev="footnote"> ↩</a></span></li><li id="fn:19"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">19.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">T. Hagge, P. Stinis, E. Yeung, A.M. Tartakovsky, Solving differential equations with unknown constitutive relations as recurrent neural networks, 2017, arXiv:1710.02242.<a href="#fnref:19" rev="footnote"> ↩</a></span></li><li id="fn:20"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">20.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">R. Tripathy, I. Bilionis, Deep UQ: learning deep neural network surrogate models for high dimensional uncertainty quantifification, 2018, arXiv:1802. 00850.<a href="#fnref:20" rev="footnote"> ↩</a></span></li><li id="fn:21"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">21.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">P.R. Vlachas, W. Byeon, Z.Y. Wan, T.P. Sapsis, P. Koumoutsakos, Data-driven forecasting of high-dimensional chaotic systems with long-short term memory networks, 2018, arXiv:1802.07486.<a href="#fnref:21" rev="footnote"> ↩</a></span></li><li id="fn:22"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">22.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">E.J. Parish, K. Duraisamy, A paradigm for data-driven predictive modeling using field inversion and machine learning, J. Comput. Phys. 305 (2016) 758–774.<a href="#fnref:22" rev="footnote"> ↩</a></span></li><li id="fn:23"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">23.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">K. Duraisamy, Z.J. Zhang, A.P. Singh, New approaches in turbulence and transition modeling using data-driven techniques, in: 53rd AIAA Aerospace Sciences Meeting, 2018, p. 1284.<a href="#fnref:23" rev="footnote"> ↩</a></span></li><li id="fn:24"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">24.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">J. Ling, A. Kurzawski, J. Templeton, Reynolds averaged turbulence modelling using deep neural networks with embedded invariance, J. Fluid Mech. 807 (2016) 155–166.<a href="#fnref:24" rev="footnote"> ↩</a></span></li><li id="fn:25"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">25.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">Z.J. Zhang, K. Duraisamy, Machine learning methods for data-driven turbulence modeling, in: 22nd AIAA Computational Fluid Dynamics Conference, 2015, p. 2460.<a href="#fnref:25" rev="footnote"> ↩</a></span></li><li id="fn:26"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">26.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">M. Milano, P. Koumoutsakos, Neural network modeling for near wall turbulent flow, J. Comput. Phys. 182 (2002) 1–26.<a href="#fnref:26" rev="footnote"> ↩</a></span></li><li id="fn:27"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">27.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">P. Perdikaris, D. Venturi, G.E. Karniadakis, Multififidelity information fusion algorithms for high-dimensional systems and massive data sets, SIAM J. Sci. Comput. 38 (2016) B521–B538.<a href="#fnref:27" rev="footnote"> ↩</a></span></li><li id="fn:28"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">28.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">R. Rico-Martinez, J. Anderson, I. Kevrekidis, Continuous-time nonlinear signal processing: a neural network based approach for gray box identification, in: Neural Networks for Signal Processing IV. Proceedings of the 1994 IEEE Workshop, IEEE, 1994, pp. 596–605.<a href="#fnref:28" rev="footnote"> ↩</a></span></li><li id="fn:29"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">29.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">J. Ling, J. Templeton, Evaluation of machine learning algorithms for prediction of regions of high Reynolds averaged Navier Stokes uncertainty, Phys. Fluids 27 (2015) 085103.<a href="#fnref:29" rev="footnote"> ↩</a></span></li><li id="fn:30"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">30.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">H.W. Lin, M. Tegmark, D. Rolnick, Why does deep and cheap learning work so well? J. Stat. Phys. 168 (2017) 1223–1247.<a href="#fnref:30" rev="footnote"> ↩</a></span></li><li id="fn:31"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">31.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">R. Kondor, N-body networks: a covariant hierarchical neural network architecture for learning atomic potentials, 2018, arXiv:1803.01588.<a href="#fnref:31" rev="footnote"> ↩</a></span></li><li id="fn:32"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">32.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">R. Kondor, S. Trivedi, On the generalization of equivariance and convolution in neural networks to the action of compact groups, 2018, arXiv:1802. 03690.<a href="#fnref:32" rev="footnote"> ↩</a></span></li><li id="fn:33"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">33.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">M. Hirn, S. Mallat, N. Poilvert, Wavelet scattering regression of quantum chemical energies, Multiscale Model. Simul. 15 (2017) 827–863.<a href="#fnref:33" rev="footnote"> ↩</a></span></li><li id="fn:34"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">34.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">S. Mallat, Understanding deep convolutional networks, Philos. Trans. R. Soc. A 374 (2016) 20150203.<a href="#fnref:34" rev="footnote"> ↩</a></span></li><li id="fn:35"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">35.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">D.C. Liu, J. Nocedal, On the limited memory BFGS method for large scale optimization, Math. Program. 45 (1989) 503–528.<a href="#fnref:35" rev="footnote"> ↩</a></span></li><li id="fn:36"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">36.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">I. Goodfellow, Y. Bengio, A. Courville, Deep Learning, MIT Press, 2016.<a href="#fnref:36" rev="footnote"> ↩</a></span></li><li id="fn:37"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">37.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">D. Kingma, J. Ba, Adam: a method for stochastic optimization, 2014, arXiv:1412.6980.<a href="#fnref:37" rev="footnote"> ↩</a></span></li><li id="fn:38"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">38.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">A. Choromanska, M. Henaff, M. Mathieu, G.B. Arous, Y. LeCun, The loss surfaces of multilayer networks, in: Artifificial Intelligence and Statistics, pp. 192–204.<a href="#fnref:38" rev="footnote"> ↩</a></span></li><li id="fn:39"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">39.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">R. Shwartz-Ziv, N. Tishby, Opening the black box of deep neural networks via information, 2017, arXiv:1703.00810.<a href="#fnref:39" rev="footnote"> ↩</a></span></li><li id="fn:40"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">40.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">T.A. Driscoll, N. Hale, L.N. Trefethen, Chebfun Guide, 2014.<a href="#fnref:40" rev="footnote"> ↩</a></span></li><li id="fn:41"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">41.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">M. Stein, Large sample properties of simulations using Latin hypercube sampling, Technometrics 29 (1987) 143–151.<a href="#fnref:41" rev="footnote"> ↩</a></span></li><li id="fn:42"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">42.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">J. Snoek, H. Larochelle, R.P. Adams, Practical bayesian optimization of machine learning algorithms, in: Advances in Neural Information Processing Systems, 2012, pp. 2951–2959.<a href="#fnref:42" rev="footnote"> ↩</a></span></li><li id="fn:43"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">43.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">H.-J. Bungartz, M. Griebel, Sparse grids, Acta Numer. 13 (2004) 147–269.<a href="#fnref:43" rev="footnote"> ↩</a></span></li><li id="fn:44"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">44.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">I.H. Sloan, H. Wo´zniakowski, When are quasi-Monte Carlo algorithms effiffifficient for high dimensional integrals? J. Complex. 14 (1998) 1–33.<a href="#fnref:44" rev="footnote"> ↩</a></span></li><li id="fn:45"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">45.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">A. Iserles, A First Course in the Numerical Analysis of Differential Equations, vol. 44, Cambridge University Press, 2009.<a href="#fnref:45" rev="footnote"> ↩</a></span></li><li id="fn:46"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">46.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">T. Von Kármán, Aerodynamics, vol. 9, McGraw-Hill, New York, 1963.<a href="#fnref:46" rev="footnote"> ↩</a></span></li><li id="fn:47"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">47.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">G. Karniadakis, S. Sherwin, Spectral/hp Element Methods for Computational Fluid Dynamics, Oxford University Press, 2013.<a href="#fnref:47" rev="footnote"> ↩</a></span></li><li id="fn:48"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">48.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">T. Dauxois, Fermi, Pasta, Ulam and a mysterious lady, 2008, arXiv:0801.1590.<a href="#fnref:48" rev="footnote"> ↩</a></span></li><li id="fn:49"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">49.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">M. Abadi, A. Agarwal, P. Barham, E. Brevdo, Z. Chen, C. Citro, G.S. Corrado, A. Davis, J. Dean, M. Devin, et al., Tensorflow: large-scale machine learning on heterogeneous distributed systems, 2016, arXiv:1603.04467.<a href="#fnref:49" rev="footnote"> ↩</a></span></li><li id="fn:50"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">50.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">S.L. Brunton, J.L. Proctor, J.N. Kutz, Discovering governing equations from data by sparse identifification of nonlinear dynamical systems, Proc. Natl. Acad. Sci. 113 (2016) 3932–3937.<a href="#fnref:50" rev="footnote"> ↩</a></span></li></ol></div></div><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>文献翻译</category>
      </categories>
      <tags>
        <tag>深度学习与计算地球物理</tag>
      </tags>
  </entry>
  <entry>
    <title>Wavelet Deep Neural Network for Stripe Noise Removal</title>
    <url>/2021/05/21/10.1109ACCESS.2019.2908720/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>基于小波深度神经网络的条纹噪声去除<br>原文地址：<a href="https://ieeexplore.ieee.org/document/8678750/authors#authors">https://ieeexplore.ieee.org/document/8678750/authors#authors</a><br>doi：10.1109/ACCESS.2019.2908720</p>
<h1 id="ABSRTACT"><a href="#ABSRTACT" class="headerlink" title="ABSRTACT"></a>ABSRTACT</h1><p>在红外成像系统中，条纹噪声会严重影响图像质量。现有的去条纹算法在噪声抑制、细节保持和实时性等方面仍存在较大的困难，阻碍了其在光谱成像和信号处理领域的应用。为了解决这一问题，本文从变换域的角度提出了一种新颖的小波深层神经网络，它充分考虑了条纹噪声的固有特性和不同小波子带系数之间的互补信息，以较低的计算量准确估计噪声。此外，还定义了一种特殊的方向正则化器，使场景细节与条纹噪声分离更彻底，细节恢复更准确。大量的模拟和真实数据实验表明，本文提出的方法在定量和定性评价上都优于几种经典的去条带方法。</p>
<h1 id="INTRODUCTION"><a href="#INTRODUCTION" class="headerlink" title="INTRODUCTION"></a>INTRODUCTION</h1><p>红外图像在遥感、医学诊断、视觉跟踪、物联网传感等领域有着广泛的应用<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="A. Jara et al., ‘‘Joint de-blurring and nonuniformity correction method for infrared microscopy imaging,’’ Infr. Phys. Technol., vol. 90, pp. 199–206, May 2018.
">[1]</span></a></sup><sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Y. Cao and Y. Li, ‘‘Strip non-uniformity correction in uncooled long-wave infrared focal plane array based on noise source characterization,’’ Opt. Commun., vol. 339, pp. 236–242, Mar. 2015.
">[2]</span></a></sup><sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Y. Huang, C. He, H. Fang, and X. Wang, ‘‘Iteratively reweighted unidirectional variational model for stripe non-uniformity correction,’’ Infr. Phys. Technol., vol. 75, pp. 107–116, Mar. 2016.
">[3]</span></a></sup><sup id="fnref:4"><a href="#fn:4" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="C. Chen, X. Liu, H.-H. Chen, M. Li, and L. Zhao, ‘‘A rear-end collision risk evaluation and control scheme using a Bayesian network model,’’ IEEE Trans. Intell. Transp. Syst., vol. 20, no. 1, pp. 264–284, Jan. 2019.
">[4]</span></a></sup>。由于硬件制作工艺的限制，探测器对同一辐照度的光电响应可能不完全一致，导致观测结果上叠加了固定条纹噪声，严重降低了红外成像系统的灵敏度<sup id="fnref:5"><a href="#fn:5" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="R. Lai, G. Yue, and G. Zhang, ‘‘Total variation based neural network regression for nonuniformity correction of infrared images,’’ Symmetry, vol. 10, no. 5, p. 157, 2018.
">[5]</span></a></sup><sup id="fnref:6"><a href="#fn:6" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="R. Lai, J. Guan, Y. Yang, and A. Xiong, ‘‘Spatiotemporal adaptive nonuniformity correction based on BTV regularization,’’ IEEE Access, vol. 7, pp. 753–762, 2019.
">[6]</span></a></sup><sup id="fnref:7"><a href="#fn:7" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="K. Liang, C.Yang, L. Peng, and B. Zhou, ‘‘Nonuniformity correction based on focal plane array temperature in uncooled long-wave infrared cameras without a shutter,’’ Appl. Opt., vol. 56, no. 4, pp. 884–889, 2017.
">[7]</span></a></sup>。因此，在去除条纹噪声的同时保持真实场景的结构是非常关键的。条纹噪声衰减模型可以表示为</p>
<script type="math/tex; mode=display">y(i, j)=x(i, j)+n(i, j)</script><p>其中$y(i,j)$、$x(i, j)$和$n(i, j)$分别表示观测响应、理想响应和由位于$(i,j)$的探测器所产生的条纹状噪声。<br>近年来，基于不同框架的算法被提出用于条纹噪声去噪。大体可以将这些方法分为三种：（1）基于先验信息类方法；（2）基于统计学方法；（3）深度学习方法。<sup id="fnref:8"><a href="#fn:8" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="X. Jian, R. Lu, Q. Guo, and G.-P. Wang, ‘‘Single image non-uniformity correction using compressive sensing,’’ Infr. Phys. Technol., vol. 76, pp. 360–364, May 2016.
">[8]</span></a></sup><sup id="fnref:9"><a href="#fn:9" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="S. Rong, H. Zhou, D. Zhao, K. Cheng, K. Qian, and H. Qin, ‘‘Infrared fix pattern noise reduction method based on shearlet transform,’’ Infr. Phys. Technol., vol. 91, pp. 243–249, Jun. 2018.
">[9]</span></a></sup>基于先验信息方法，主要有块匹配（block-matching）和3D滤波（BM3D）<sup id="fnref:10"><a href="#fn:10" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="K. Dabov, A. Foi, and K. Egiazarian, ‘‘Video denoising by sparse 3D transform-domain collaborative filtering,’’ in Proc. Eur. Signal Process. Conf., Poznan, Poland, Sep. 2007, pp. 145–149.
">[10]</span></a></sup>、TV(Total variation)<sup id="fnref:11"><a href="#fn:11" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="L. I. Rudin, S. Osher, and E. Fatemi, ‘‘Nonlinear total variation based noise removal algorithms,’’ Phys. D, Nonlinear Phenomena, vol. 60, nos. 1–4, pp. 259–268, 1992.
">[11]</span></a></sup>，导向滤波(guided filter, GF)<sup id="fnref:12"><a href="#fn:12" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="K. He, J. Sun, and X. Tang, ‘‘Guided image filtering,’’ IEEE Trans. Pattern Anal. Mach. Intell., vol. 35, no. 6, pp. 1397–1409, Jun. 2013.
">[12]</span></a></sup>，$non-local means(NLM)$滤波<sup id="fnref:13"><a href="#fn:13" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="H. Li and C. Y. Suen, ‘‘A novel non-local means image denoising method based on grey theory,’’ Pattern Recognit., vol. 49, pp. 237–248, Jan. 2016.
VOLUME 7, 2019
">[13]</span></a></sup>以及低秩正则化<sup id="fnref:14"><a href="#fn:14" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Y. Chang, L. Yan, T. Wu, and S. Zhong, ‘‘Remote sensing image stripe noise removal: From image decomposition perspective,’’ IEEE Trans. Geosci. Remote Sens., vol. 54, no. 12, pp. 7018–7031, Dec. 2016.
">[14]</span></a></sup>等，但是这些方法在消除条纹噪声时也会无差别地消除图片的细节信息，如此一来可能会在输出图片中产生假象。基于统计学的方法，例如$histogram equalization(MHE)$<sup id="fnref:15"><a href="#fn:15" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Y. Tendero, J. Gilles, S. Landeau, and J. M. Morel, ‘‘Efficient single image non-uniformity correction algorithm,’’ Proc. SPIE, vol. 7834, Oct. 2010, Art. no. 78340E.
">[15]</span></a></sup>等，在相邻列中引入冗余信息来消除条纹噪声，这种方法只适用于较弱的条纹噪声。当前，基于深度学习的方法被广泛应用于图像处理领域，均表现出非凡的效果。Kuang等提出了三层条纹噪声消除卷积神经网络$SNRCNN$，直接将条纹去噪视为图像去噪和超分辨率<sup id="fnref:19"><a href="#fn:19" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="S. G. Chang, B. Yu, and M. Vetterli, ‘‘Adaptive wavelet thresholding for image denoising and compression,’’ IEEE Trans. Image Process., vol. 9, no. 9, pp. 1532–1546, Sep. 2000.
">[19]</span></a></sup>，但并没有考虑条纹噪声的具体特性，因此很难在去除条纹噪声的同时保留高频细节信息。为了消除这一限制，He等提出了具有更大感受野的$DLSNUC$模型来达到更好的消除效果<sup id="fnref:17"><a href="#fn:17" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Z. He, Y. Cao, Y. Dong, J. Yang, Y. Cao, and C.-L. Tisse, ‘‘Single-imagebased nonuniformity correction of uncooled long-wave infrared detectors: A deep-learning approach,’’ Appl. Opt., vol. 57, no. 18, pp. D155–D164, 2018.
">[17]</span></a></sup>。Xiao等提出$ICSRN$，其将CNN中的局部信息和全局信息结合起来以更好地保留边缘信息。但是仍然很难处理强条纹噪声。总结来讲，现有的深度学习去条纹方法只提取了图像在时间域的信息而忽视了其在时频域的冗余信息，因此限制了条纹去噪算法的应用。<br>过去一段时期内，基于转换域的图像处理方法被广泛应用<sup id="fnref:19"><a href="#fn:19" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="S. G. Chang, B. Yu, and M. Vetterli, ‘‘Adaptive wavelet thresholding for image denoising and compression,’’ IEEE Trans. Image Process., vol. 9, no. 9, pp. 1532–1546, Sep. 2000.
">[19]</span></a></sup><sup id="fnref:20"><a href="#fn:20" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="A. L. da Cunha, J. Zhou, and M. N. Do, ‘‘The nonsubsampled contourlet transform: Theory, design, and applications,’’ IEEETrans. Image Process., vol. 15, no. 10, pp. 3089–3101, Oct. 2006.
">[20]</span></a></sup>。在此基础上，Huang等提出了超分辨率网络来预测图像在小波域的缺失细节信息<sup id="fnref:21"><a href="#fn:21" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="H. Huang, R. He, Z. Sun, and T. Tan, ‘‘Wavelet-SRNet: A wavelet-based CNN for multi-scale face super resolution,’’ in Proc. IEEE Conf. CVPR, Honolulu, HI, USA, Oct. 2017, pp. 1689–1697.
">[21]</span></a></sup>；Kang等利用$Contourlet$变换分析图像特征，在CT图像去噪方面取得了较好的效果<sup id="fnref:22"><a href="#fn:22" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="E. Kang, J. Min, and J. C. Ye, ‘‘A deep convolutional neural network using directional wavelets for low-dose X-ray CT reconstruction,’’ Med. Phys., vol. 44, no. 10, pp. e360–e375, 2017.
">[22]</span></a></sup>。受这些方法的启发，我们提出了基于小波的深度神经网络去除条纹噪声（SNRWDNN），其挖掘了图像在小波域的特征并且将多个频带的信息作为有效补充来更好的去除条纹噪声。本文主要创新点和贡献如下：</p>
<ol>
<li>引入小波域条纹去噪神经网络，其能够自适应的估计噪声强度和分布。</li>
<li>提出方向正则化器来避免模型产生不规则条纹噪声，并更好地恢复场景细节信息。</li>
<li>利用小波分解将输入图像变为一系列四分之一大小的系数，以提升计算效率并提升去噪效果。<br>本文其余部分组织结构如下：在Section2中，我们分析了条纹噪声在小波域的表现形式。Section3详细阐述了SNRWDNN的实现细节。为了更好地展示本文所提方法的效果，模拟数据和真实数据实验均用于分析（Section4）。Section5为结论。<h1 id="PROPERTY-ANALYSIS-OF-STRIPE-NOISE"><a href="#PROPERTY-ANALYSIS-OF-STRIPE-NOISE" class="headerlink" title="PROPERTY ANALYSIS OF STRIPE NOISE"></a>PROPERTY ANALYSIS OF STRIPE NOISE</h1><img src="/2021/05/21/10.1109ACCESS.2019.2908720/fig01.png" alt="fig01"><br>为了准确地估计图像中含有的条纹噪声，关键是要挖掘出条纹噪声分量的属性并使用合理的方式描述它们。如文献<sup id="fnref:23"><a href="#fn:23" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Y. Chen, T.-Z. Huang, L.-J. Deng, X.-L. Zhao, and M. Wang, ‘‘Group sparsity based regularization model for remote sensing image stripe noise removal,’’ Neurocomputing, vol. 267, pp. 95–106, Dec. 2017.
">[23]</span></a></sup>中所述，条纹噪声具有明显的方向属性，这一属性有利于去噪过程中图像细节和噪声分量的分离。图1展示了含条纹噪声图像的水平梯度和垂向梯度。从结果中我们可以看出，条纹噪声明显存在于水平梯度中，并且严重影响着垂直方向的图像细节信息。与之相反的是，垂向梯度中的条纹噪声分量表现出较好的平滑性质，因此对图像细节影响不大。基于以上简单的分析，可以基于不同方向梯度信息来从含噪图像中去除条纹噪声并可能保留图像的结构信息。<br><img src="/2021/05/21/10.1109ACCESS.2019.2908720/fig02.png" alt="fig02"><br>$Harr$离散小波变换(HDWT)具有提取图像水平方向、垂直方向、对角方向高频信息、以及保留低频结构信息的能力。本文中，$HDWT$被用于提取条纹噪声的梯度信息并更彻底地从条纹噪声中区分场景细节信息。$HDWT$的结果如图2所示。可以明显看出条纹噪声在近似系数(cA)和水平系数(cH)中有明显的响应，与之相对应的，垂向系数(cV)和对角系数(cD)则主要描述了场景的细节信息。总结来讲，不同子频带的补充性信息有助于在去除条纹噪声的同时保留图像的细节信息。<h1 id="THE-PROPOSED-SRNWDNN-MODEL"><a href="#THE-PROPOSED-SRNWDNN-MODEL" class="headerlink" title="THE PROPOSED SRNWDNN MODEL"></a>THE PROPOSED SRNWDNN MODEL</h1>在这一章节中，我们将详细介绍提出的$SNRWDNN$模型结构，然后深入讨论所设计的方向损失函数对于保留图像纹理细节的重要性，最后给出训练策略。<h2 id="A-网络结构"><a href="#A-网络结构" class="headerlink" title="A.网络结构"></a>A.网络结构</h2><img src="/2021/05/21/10.1109ACCESS.2019.2908720/fig03.png" alt="fig03"><br>$SNRWDNN$网络结构如图3所示。与现有的基于深度学习的条纹噪声去除方法不同，我们将条带噪声去除视为小波域的变换系数预测问题。$SNRWDNN$方法包括三个步骤：$HDWT$、小波系数预测和$Haar$离散小波逆变换$IHDWT$。首先，利用$HDWT$得到反映条纹噪声固有特性的四个子带系数。然后将这些系数串联成一个输入张量，送入小波系数预测网络，估计条纹分量，然后将输入张量与估计的条纹分量跳转连接，进行噪声消除，产生去条纹系数。值得注意的是，级联操作融合了不同子带中的信息，并保持了它们之间的一致性。最后，利用$IHDWT$对估计系数进行反变换，重建空间域去噪后结果。通过这种策略，我们提出的网络可以利用条纹的方向特性来抑制噪声，同时减少细节损失。小波系数预测网络由M层具有残差连接的卷积层构成，其中所有卷积滤波器共享大小为$3 \times3$、$stride$为1的卷积核。另外，采用零填充的方法使每个特征映射与输入张量保持相同的大小。除了最后一层输出4通道条纹分量外，每个卷积层的核数被设置为64。此外，将前一卷积层的输出输入到校正线性单元（ReLU）激活函数中进行非线性映射。由于SNRWDNN的输入和输出非常相似，我们采用了残差学习方法，使训练更加稳定、快速和精确。小波分解中的下采样操作有效地扩大了感受野，有利于场景细节的恢复<sup id="fnref:25"><a href="#fn:25" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="H. Chen, X. He, L. Qing, S. Xiong, and T. Q. Nguyen, ‘‘DPW-SDNet: Dual pixel-wavelet domain deep CNNs for soft decoding of JPEG-compressed images,’’ presented at the IEEE Conf. CVPR, Salt Lake City, UT, USA, 2018.
">[25]</span></a></sup>，同时其减少了计算复杂性。此外，小波分解大大降低了计算复杂度。<h2 id="B-方向小波损失函数"><a href="#B-方向小波损失函数" class="headerlink" title="B.方向小波损失函数"></a>B.方向小波损失函数</h2>当前基于深度学习的铜像处理任务通常关注于最小化均方误差目标函数<sup id="fnref:26"><a href="#fn:26" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="C. Ledig et al., ‘‘Photo-realistic single image super-resolution using a generative adversarial network,’’ in Proc. IEEE Conf. CVPR, Honolulu, HI, USA, Jul. 2017, pp. 105–114.
">[26]</span></a></sup>。本文延续前人<sup id="fnref:21"><a href="#fn:21" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="H. Huang, R. He, Z. Sun, and T. Tan, ‘‘Wavelet-SRNet: A wavelet-based CNN for multi-scale face super resolution,’’ in Proc. IEEE Conf. CVPR, Honolulu, HI, USA, Oct. 2017, pp. 1689–1697.
">[21]</span></a></sup><sup id="fnref:25"><a href="#fn:25" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="H. Chen, X. He, L. Qing, S. Xiong, and T. Q. Nguyen, ‘‘DPW-SDNet: Dual pixel-wavelet domain deep CNNs for soft decoding of JPEG-compressed images,’’ presented at the IEEE Conf. CVPR, Salt Lake City, UT, USA, 2018.
">[25]</span></a></sup>工作，引入小波均方误差损失来处理小波域的条纹噪声去除任务。小波均方误差被定义为<script type="math/tex; mode=display">L_W=\mid\mid cA- \overline{cA} \mid\mid_2^2+\mid\mid cV- \overline{cV} \mid\mid+\mid\mid cH- \overline{cH} \mid\mid+\mid\mid cD- \overline{cD} \mid\mid \tag{2}</script>其中，$\mid\mid·\mid\mid_2^2$表示$L2$范数，$cA$,$cV$,$cH$,$cD$分别代表真实图像的近似系数、水平系数、垂向系数和对角系数，$\overline{cA}$,$\overline{cV}$,$\overline{cH}$,$\overline{cD}$，分别表示它们的预测值。<br>从局部角度看，单个条纹内的像素强度在较窄的范围内变化，这意味着条纹的沿条纹方向上具有良好的平滑性。为了更好地估计条纹噪声，我们通过最小化条纹相关子带中条纹分量方向的部分差异来描述其平滑程度<sup id="fnref:27"><a href="#fn:27" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="X. Liu, X. Lu, H. Shen, Q. Yuan, Y. Jiao, and L. Zhang, ‘‘Stripe noise separation and removal in remote sensing images by consideration of the global sparsity and local variational properties,’’ IEEE Trans. Geosci. Remote Sens., vol. 54, no. 5, pp. 3049–3060, May 2016.
">[27]</span></a></sup>。为此，构造方向化正则器<script type="math/tex; mode=display">L_D=\mid\mid \nabla S_{cA} \mid\mid_2^2+\mid\mid \nabla S_{cH}\mid\mid_2^2\tag{3}</script>其中$\nabla$代表沿条纹方向的偏微分算子。$S_{cA}$和$S_{cH}$表示$cA$和$cH$子带的条纹分量。<br>最后，所提出的方向小波损失函数为<script type="math/tex; mode=display">Loss = L_W+\lambda L_D \tag{4}</script>其中，$\lambda$为控制方向损失的常量。<span id="more"></span>
<details><summary>参考文献</summary><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">A. Jara et al., ‘‘Joint de-blurring and nonuniformity correction method for infrared microscopy imaging,’’ Infr. Phys. Technol., vol. 90, pp. 199–206, May 2018.<a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">Y. Cao and Y. Li, ‘‘Strip non-uniformity correction in uncooled long-wave infrared focal plane array based on noise source characterization,’’ Opt. Commun., vol. 339, pp. 236–242, Mar. 2015.<a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">Y. Huang, C. He, H. Fang, and X. Wang, ‘‘Iteratively reweighted unidirectional variational model for stripe non-uniformity correction,’’ Infr. Phys. Technol., vol. 75, pp. 107–116, Mar. 2016.<a href="#fnref:3" rev="footnote"> ↩</a></span></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">C. Chen, X. Liu, H.-H. Chen, M. Li, and L. Zhao, ‘‘A rear-end collision risk evaluation and control scheme using a Bayesian network model,’’ IEEE Trans. Intell. Transp. Syst., vol. 20, no. 1, pp. 264–284, Jan. 2019.<a href="#fnref:4" rev="footnote"> ↩</a></span></li><li id="fn:5"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">5.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">R. Lai, G. Yue, and G. Zhang, ‘‘Total variation based neural network regression for nonuniformity correction of infrared images,’’ Symmetry, vol. 10, no. 5, p. 157, 2018.<a href="#fnref:5" rev="footnote"> ↩</a></span></li><li id="fn:6"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">6.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">R. Lai, J. Guan, Y. Yang, and A. Xiong, ‘‘Spatiotemporal adaptive nonuniformity correction based on BTV regularization,’’ IEEE Access, vol. 7, pp. 753–762, 2019.<a href="#fnref:6" rev="footnote"> ↩</a></span></li><li id="fn:7"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">7.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">K. Liang, C.Yang, L. Peng, and B. Zhou, ‘‘Nonuniformity correction based on focal plane array temperature in uncooled long-wave infrared cameras without a shutter,’’ Appl. Opt., vol. 56, no. 4, pp. 884–889, 2017.<a href="#fnref:7" rev="footnote"> ↩</a></span></li><li id="fn:8"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">8.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">X. Jian, R. Lu, Q. Guo, and G.-P. Wang, ‘‘Single image non-uniformity correction using compressive sensing,’’ Infr. Phys. Technol., vol. 76, pp. 360–364, May 2016.<a href="#fnref:8" rev="footnote"> ↩</a></span></li><li id="fn:9"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">9.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">S. Rong, H. Zhou, D. Zhao, K. Cheng, K. Qian, and H. Qin, ‘‘Infrared fix pattern noise reduction method based on shearlet transform,’’ Infr. Phys. Technol., vol. 91, pp. 243–249, Jun. 2018.<a href="#fnref:9" rev="footnote"> ↩</a></span></li><li id="fn:10"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">10.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">K. Dabov, A. Foi, and K. Egiazarian, ‘‘Video denoising by sparse 3D transform-domain collaborative filtering,’’ in Proc. Eur. Signal Process. Conf., Poznan, Poland, Sep. 2007, pp. 145–149.<a href="#fnref:10" rev="footnote"> ↩</a></span></li><li id="fn:11"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">11.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">L. I. Rudin, S. Osher, and E. Fatemi, ‘‘Nonlinear total variation based noise removal algorithms,’’ Phys. D, Nonlinear Phenomena, vol. 60, nos. 1–4, pp. 259–268, 1992.<a href="#fnref:11" rev="footnote"> ↩</a></span></li><li id="fn:12"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">12.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">K. He, J. Sun, and X. Tang, ‘‘Guided image filtering,’’ IEEE Trans. Pattern Anal. Mach. Intell., vol. 35, no. 6, pp. 1397–1409, Jun. 2013.<a href="#fnref:12" rev="footnote"> ↩</a></span></li><li id="fn:13"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">13.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">H. Li and C. Y. Suen, ‘‘A novel non-local means image denoising method based on grey theory,’’ Pattern Recognit., vol. 49, pp. 237–248, Jan. 2016.
VOLUME 7, 2019<a href="#fnref:13" rev="footnote"> ↩</a></span></li><li id="fn:14"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">14.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">Y. Chang, L. Yan, T. Wu, and S. Zhong, ‘‘Remote sensing image stripe noise removal: From image decomposition perspective,’’ IEEE Trans. Geosci. Remote Sens., vol. 54, no. 12, pp. 7018–7031, Dec. 2016.<a href="#fnref:14" rev="footnote"> ↩</a></span></li><li id="fn:15"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">15.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">Y. Tendero, J. Gilles, S. Landeau, and J. M. Morel, ‘‘Efficient single image non-uniformity correction algorithm,’’ Proc. SPIE, vol. 7834, Oct. 2010, Art. no. 78340E.<a href="#fnref:15" rev="footnote"> ↩</a></span></li><li id="fn:16"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">16.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">X. Kuang, X. Sui, Q. Chen, and G. Gu, ‘‘Single infrared image stripe noise removal using deep convolutional networks,’’ IEEEPhoton. J., vol. 9, no. 4, Aug. 2017, Art. no. 3900913.<a href="#fnref:16" rev="footnote"> ↩</a></span></li><li id="fn:17"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">17.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">Z. He, Y. Cao, Y. Dong, J. Yang, Y. Cao, and C.-L. Tisse, ‘‘Single-imagebased nonuniformity correction of uncooled long-wave infrared detectors: A deep-learning approach,’’ Appl. Opt., vol. 57, no. 18, pp. D155–D164, 2018.<a href="#fnref:17" rev="footnote"> ↩</a></span></li><li id="fn:18"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">18.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">P. Xiao, Y. Guo, and P. Zhuang, ‘‘Removing stripe noise from infrared cloud images via deep convolutional networks,’’ IEEE Photon. J., vol. 10, no. 4, Aug. 2018, Art. no. 7801114.<a href="#fnref:18" rev="footnote"> ↩</a></span></li><li id="fn:19"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">19.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">S. G. Chang, B. Yu, and M. Vetterli, ‘‘Adaptive wavelet thresholding for image denoising and compression,’’ IEEE Trans. Image Process., vol. 9, no. 9, pp. 1532–1546, Sep. 2000.<a href="#fnref:19" rev="footnote"> ↩</a></span></li><li id="fn:20"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">20.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">A. L. da Cunha, J. Zhou, and M. N. Do, ‘‘The nonsubsampled contourlet transform: Theory, design, and applications,’’ IEEETrans. Image Process., vol. 15, no. 10, pp. 3089–3101, Oct. 2006.<a href="#fnref:20" rev="footnote"> ↩</a></span></li><li id="fn:21"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">21.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">H. Huang, R. He, Z. Sun, and T. Tan, ‘‘Wavelet-SRNet: A wavelet-based CNN for multi-scale face super resolution,’’ in Proc. IEEE Conf. CVPR, Honolulu, HI, USA, Oct. 2017, pp. 1689–1697.<a href="#fnref:21" rev="footnote"> ↩</a></span></li><li id="fn:22"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">22.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">E. Kang, J. Min, and J. C. Ye, ‘‘A deep convolutional neural network using directional wavelets for low-dose X-ray CT reconstruction,’’ Med. Phys., vol. 44, no. 10, pp. e360–e375, 2017.<a href="#fnref:22" rev="footnote"> ↩</a></span></li><li id="fn:23"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">23.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">Y. Chen, T.-Z. Huang, L.-J. Deng, X.-L. Zhao, and M. Wang, ‘‘Group sparsity based regularization model for remote sensing image stripe noise removal,’’ Neurocomputing, vol. 267, pp. 95–106, Dec. 2017.<a href="#fnref:23" rev="footnote"> ↩</a></span></li><li id="fn:24"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">24.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">B. L. Lai and L. W. Chang, ‘‘Adaptive data hiding for images based on harr discrete wavelet transform,’’ in Advances in Image and Video Technology (Lecture Notes in Computer Science), vol. 4319. Berlin, Germany: Springer, 2006, pp. 1085–1093.<a href="#fnref:24" rev="footnote"> ↩</a></span></li><li id="fn:25"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">25.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">H. Chen, X. He, L. Qing, S. Xiong, and T. Q. Nguyen, ‘‘DPW-SDNet: Dual pixel-wavelet domain deep CNNs for soft decoding of JPEG-compressed images,’’ presented at the IEEE Conf. CVPR, Salt Lake City, UT, USA, 2018.<a href="#fnref:25" rev="footnote"> ↩</a></span></li><li id="fn:26"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">26.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">C. Ledig et al., ‘‘Photo-realistic single image super-resolution using a generative adversarial network,’’ in Proc. IEEE Conf. CVPR, Honolulu, HI, USA, Jul. 2017, pp. 105–114.<a href="#fnref:26" rev="footnote"> ↩</a></span></li><li id="fn:27"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">27.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">X. Liu, X. Lu, H. Shen, Q. Yuan, Y. Jiao, and L. Zhang, ‘‘Stripe noise separation and removal in remote sensing images by consideration of the global sparsity and local variational properties,’’ IEEE Trans. Geosci. Remote Sens., vol. 54, no. 5, pp. 3049–3060, May 2016.<a href="#fnref:27" rev="footnote"> ↩</a></span></li><li id="fn:28"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">28.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">W. Luo, J. Li, W. Xu, and J. Yang, ‘‘Learning sparse features in convolutional neural networks for image classification,’’ in Proc. Int. Conf. Intell. Sci. Big Data Eng., Suzhou, China, 2015, pp. 29–38.<a href="#fnref:28" rev="footnote"> ↩</a></span></li><li id="fn:29"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">29.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">K. Simonyan and A. Zisserman. (2014). ‘‘Very deep convolutional networks for large-scale image recognition.’’ [^Online]:. Available: https:// arxiv.org/abs/1409.1556<a href="#fnref:29" rev="footnote"> ↩</a></span></li><li id="fn:30"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">30.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">K. Zhang, W. Zuo, Y. Chen, D. Meng, and L. Zhang, ‘‘Beyond a Gaussian denoiser: Residual learning of deep CNN for image denoising,’’ IEEE Trans. Image Process., vol. 26, no. 7, pp. 3142–3155, Jul. 2017.<a href="#fnref:30" rev="footnote"> ↩</a></span></li><li id="fn:31"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">31.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">D. Graziotin and P. Abrahamsson, ‘‘A Web-based modeling tool for the SEMAT essence theory of software engineering,’’ J. Open Res. Softw., to be published. doi: 10.5334/jors.ad.<a href="#fnref:31" rev="footnote"> ↩</a></span></li><li id="fn:32"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">32.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">D. P. Kingma and J. Ba. (2014). ‘‘Adam: A method for stochastic optimization.’’ [^Online]:. Available: https://arxiv.org/abs/1412.6980<a href="#fnref:32" rev="footnote"> ↩</a></span></li><li id="fn:33"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">33.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">J. Kim, J. K. Lee, and K. M. Lee, ‘‘Accurate image super-resolution using very deep convolutional networks,’’ in Proc. IEEE Conf. CVPR, Las Vegas, NV, USA, Jun. 2016, pp. 1646–1654.<a href="#fnref:33" rev="footnote"> ↩</a></span></li><li id="fn:34"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">34.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">Z. Wang, A. C. Bovik, H. R. Sheikh, and E. P. Simoncelli, ‘‘Image quality assessment: From error visibility to structural similarity,’’ IEEE Trans. Image Process., vol. 13, no. 4, pp. 600–612, Apr. 2004.<a href="#fnref:34" rev="footnote"> ↩</a></span></li><li id="fn:35"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">35.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">Y. Cao, M. Y. Yang, and C.-L. Tisse, ‘‘Effective strip noise removal for low-textured infrared images based on 1-D guided filtering,’’ IEEE Trans. Circuits Syst. Video Technol., vol. 26, no. 12, pp. 2176–2188, Dec. 2016.<a href="#fnref:35" rev="footnote"> ↩</a></span></li><li id="fn:36"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">36.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">N. Liu, L. Wan, Y. Zhang, T. Zhou, H. Huo, and T. Fang, ‘‘Exploiting convolutional neural networks with deeply local description for remote sensing image classification,’’ IEEE Access, vol. 6, pp. 11215–11228, 2018.<a href="#fnref:36" rev="footnote"> ↩</a></span></li><li id="fn:37"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">37.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">Z. Jin et al., ‘‘EEG classification using sparse Bayesian extreme learning machine for brain–computer interface,’’ Neural Comput. Appl., to be published. doi: 10.1007/s00521-018-3735-3.<a href="#fnref:37" rev="footnote"> ↩</a></span></li><li id="fn:38"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">38.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">G. Zhou et al., ‘‘Linked component analysis from matrices to high-order tensors: Applications to biomedical data,’’ Proc. IEEE, vol. 104, no. 2, pp. 310–331, Feb. 2016.<a href="#fnref:38" rev="footnote"> ↩</a></span></li><li id="fn:39"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">39.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">R. Lai, Y. Mo, Z. Liu, and J. Guan, ‘‘Local and nonlocal steering kernel weighted total variation model for image denoising,’’ Symmetry, vol. 11, no. 3, p. 329, 2019.<a href="#fnref:39" rev="footnote"> ↩</a></span></li><li id="fn:40"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">40.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">M. Sandler, A. Howard, M. Zhu, A. Zhmoginov, and L.-C. Chen, ‘‘MobileNetV2: Inverted residuals and linear bottlenecks,’’ in Proc. IEEE
Conf. Comput. Vis. Pattern Recognit., Salt Lake City, UT, USA, Jun. 2018, pp. 4510–4520.<a href="#fnref:40" rev="footnote"> ↩</a></span></li><li id="fn:41"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">41.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">W.-Q. Lim, ‘‘The discrete shearlet transform: A new directional transform and compactly supported shearlet frames,’’ IEEE Trans. Image Process., vol. 19, no. 5, pp. 1166–1180, May 2010.<a href="#fnref:41" rev="footnote"> ↩</a></span></li></ol></div></div></details></li>
</ol>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>文献翻译</category>
      </categories>
      <tags>
        <tag>深度学习与计算地球物理</tag>
      </tags>
  </entry>
  <entry>
    <title>Wave physics as an analog recurrent neural network</title>
    <url>/2021/04/23/10.1126sciadv.aay6946/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="Wave-physics-as-an-analog-recurrent-neural-network"><a href="#Wave-physics-as-an-analog-recurrent-neural-network" class="headerlink" title="Wave physics as an analog recurrent neural network"></a>Wave physics as an analog recurrent neural network</h1><p>原文地址：<a href="https://advances.sciencemag.org/content/5/12/eaay6946.abstract">模拟递归神经网络的波动物理</a><br>doi: <a href="http://sci-hub.ren/10.1126/sciadv.aay6946">10.1126/sciadv.aay6946</a><br>翻译时间：2021年4月23日</p>
<h2 id="ABSTRACTS"><a href="#ABSTRACTS" class="headerlink" title="ABSTRACTS"></a>ABSTRACTS</h2><p>模拟机器学习硬件平台有望比数字平台更快、更节能。声学和光学中的波物理，是为时变信号构建模拟处理器最自然的选择。本文明确了波动物理与RNN（Recurrent neural networks，循环神经网络）之间的映射。这种映射表明，利用标准的神经网络训练技术，可以使物理波动系统学习到时序数据中的复杂特征。例如，我们证明了，当原始音频信号在逆向设计的非均匀介质中散射和传播时，能够实现元音分类（vowel classification），且其性能与RNN的“数字化实现”相当。这些发现为一类新的模拟机器学习平台提供了可能，该平台能够快速有效地对数据在其原有域进行处理（即不通过将问题转化网络训练的方式）。</p>
<h2 id="INTRODUCTION"><a href="#INTRODUCTION" class="headerlink" title="INTRODUCTION"></a>INTRODUCTION</h2><p>近年来，机器学习在执行复杂的信息处理任务方面取得了巨大的成功，例如计算机视觉（CV)<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="O. Russakovsky, J. Deng, H. Su, J. Krause, S. Satheesh, S. Ma, Z. Huang, A. Karpathy, A. Khosla, M. Bernstein, A. C. Berg, L. Fei-Fei, Imagenet large scale visual recognition challenge. Int. J. Comput. Vis. 115, 211–252 (2015).
">[1]</span></a></sup>、机器翻译<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="I. Sutskever, O. Vinyals, Q. V. Le, Sequence to sequence learning with neural networks, in Advances in Neural Information Processing Systems, NIPS Proceedings, Montreal, CA, 2014.
">[2]</span></a></sup>等传统上难以处理的领域。然而，<br>这些应用的计算需求正呈指数级增长，促使人们不断开发新的、专门的硬件平台，以便快速高效地执行机器学习模型，其中包括从架构上模仿大脑生物电路的神经形态硬件平台<sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="J. M. Shainline, S. M. Buckley, R. P. Mirin, S. W. Nam, Superconducting optoelectronic circuits for neuromorphic computing. Phys. Rev. Appl. 7, 034013 (2017).
">[3]</span></a></sup><sup id="fnref:4"><a href="#fn:4" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="A. N. Tait, T. F. D. Lima, E. Zhou, A. X. Wu, M. A. Nahmias, B. J. Shastri, P. R. Prucnal, Neuromorphic photonic networks using silicon photonic weight banks. Sci. Rep. 7, 7430 (2017).
">[4]</span></a></sup><sup id="fnref:5"><a href="#fn:5" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="M. Romera, P. Talatchian, S. Tsunegi, F. Abreu Araujo, V. Cros, P. Bortolotti, J. Trastoy, K. Yakushiji, A. Fukushima, H. Kubota, S. Yuasa, M. Ernoult, D. Vodenicarevic, T. Hirtzlin, N. Locatelli, D. Querlioz, J. Grollier, Vowel recognition with four coupled spin-torque nano-oscillators. Nature 563, 230–234 (2018).
">[5]</span></a></sup>等。此外，使用连续物理系统自然演化来执行计算的模拟计算平台也正在成为实现机器学习的一个重要方向<sup id="fnref:6"><a href="#fn:6" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Y. Shen, N. C. Harris, S. Skirlo, M. Prabhu, T. Baehr-Jones, M. Hochberg, X. Sun, S. Zhao, H. Larochelle, D. Englund, M. Soljačić, Deep learning with coherent nanophotonic circuits. Nat. Photonics 11, 441–446 (2017).
">[6]</span></a></sup><sup id="fnref:7"><a href="#fn:7" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="J. Biamonte, P. Wittek, N. Pancotti, P. Rebentrost, N. Wiebe, S. Lloyd, Quantum machine learning. Nature 549, 195–202 (2017).
">[7]</span></a></sup><sup id="fnref:8"><a href="#fn:8" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="F. Laporte, A. Katumba, J. Dambre, P. Bienstman, Numerical demonstration of neuromorphic computing with photonic crystal cavities. Opt. Express 26, 7955–7964 (2018).
">[8]</span></a></sup><sup id="fnref:9"><a href="#fn:9" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="X. Lin, Y. Rivenson, N. T. Yardimci, M. Veli, Y. Luo, M. Jarrahi, A. Ozcan, All-optical machine learning using diffractive deep neural networks. Science 361, 1004–1008 (2018).
">[9]</span></a></sup><sup id="fnref:10"><a href="#fn:10" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="E. Khoram, A. Chen, D. Liu, L. Ying, Q. Wang, M. Yuan, Z. Yu, Nanophotonic media for artificial neural inference. Photon. Res. 7, 823–827 (2019).
">[10]</span></a></sup>。本项工作中，我们发现了诸如声波、光学等波动物理现象与RNN计算之间的映射关系。RNN是最重要的机器学习模型之一，其已被广泛用于执行自然语言处理<sup id="fnref:11"><a href="#fn:11" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="K. Yao, G. Zweig, M.-Y. Hwang, Y. Shi, D. Yu, Recurrent neural networks for language understanding (Interspeech, 2013), pp. 2524–2528; https://www.microsoft.com/en-us/ research/publication/recurrent-neural-networks-for-language-understanding/.
">[11]</span></a></sup>和时间序列预测<sup id="fnref:12"><a href="#fn:12" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="M. Hüsken, P. Stagge, Recurrent neural networks for time series classification. Neurocomputing 50, 223–235 (2003).
">[12]</span></a></sup><sup id="fnref:13"><a href="#fn:13" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="G. Dorffner, Neural networks for time series processing. Neural Net. World 6, 447–468 (1996).
">[13]</span></a></sup><sup id="fnref:14"><a href="#fn:14" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="J. T. Connor, R. D. Martin, L. E. Atlas, Recurrent neural networks and robust time series prediction. IEEE Trans. Neural Netw. 5, 240–254 (1994).
">[14]</span></a></sup>等任务。我们证明了基于波的物理系统可以训练成RNN，因此，可以被动地处理数据原有域的信号和信息，而无需进行模数转换，从而有效提升处理效率并降低功耗。在这个框架中，与有意将信号反馈给输入不同的是，递归关系自然地发生在物理本身的时间动力学中，用于信息处理的内存和容量由在空间中传播的波提供。</p>
<h2 id="RESULTS"><a href="#RESULTS" class="headerlink" title="RESULTS"></a>RESULTS</h2><h3 id="波动力学与RNN之间的等效性"><a href="#波动力学与RNN之间的等效性" class="headerlink" title="波动力学与RNN之间的等效性"></a>波动力学与RNN之间的等效性</h3><p>本节中，我们介绍RNN运算与波动力学之间的关系。RNN通过对输入序列逐步应用相同的基本运算来得到输出序列，先前时刻的信息则被编码到RNN的隐藏状态中并在每个时刻进行更新。隐藏状态允许RNN保存历史信息的记忆，并学习到数据的时间结构以及长程依赖关系<sup id="fnref:15"><a href="#fn:15" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="J. L. Elman, Finding structure in time. Cognit. Sci. 14, 179–211 (1990).
">[15]</span></a></sup><sup id="fnref:16"><a href="#fn:16" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="M. I. Jordan, Serial order: A parallel distributed processing approach. Adv. Physcol. 121, 471–495 (1997).
">[16]</span></a></sup>。在给定的时刻$\boldsymbol t$，RNN作用于输入矢量$\boldsymbol x_t$以及隐藏状态矢量$\boldsymbol h_{t-1}$，计算得到输出矢量$\boldsymbol y_t$以及更新后的隐藏状态$\boldsymbol h_t$。<br>RNN有多种表现形式，其中最常见的形式其更新公式如下所示：</p>
<script type="math/tex; mode=display">\boldsymbol h_t = \sigma^{(h)}(\boldsymbol W^{(h)}·\boldsymbol h_{t-1}+\boldsymbol W^{(x)}·\boldsymbol x_t) \tag{1}</script><script type="math/tex; mode=display">\boldsymbol y_t = \sigma^{(y)}(\boldsymbol W^{(y)}·\boldsymbol h_t) \tag{2}</script><p>如图1B所示。稠密矩阵$\boldsymbol W^{(h)}$、$\boldsymbol W^{(x)}$、$\boldsymbol W^{(y)}$是训练过程中不断优化得到的，$\sigma^{(h)}(·)$和$\sigma^{(y)}(·)$为非线性激活函数。当公式1、2所定义的运算作用于输入序列时，有向图如1C所示。<br>接下来我们讨论如式1、2所示的RNN与波动物理系统之间的关系。举个例子，标量波场分布$\boldsymbol u(x, y, z)$由二阶偏微分方程$3$（图1D）控制。</p>
<script type="math/tex; mode=display">\frac{\partial^{2}u}{\partial t^{2}}-c^{2}·\nabla^{2}u=f \tag{3}</script><p>其中，$\nabla^{2}=\frac{\partial^{2}}{\partial x^{2}}+\frac{\partial^{2}}{\partial y^{2}}+\frac{\partial^{2}}{\partial z^{2}}$为拉普拉斯算子，$c=c(x, y, z)$为波速的空间分布，$f=f(x, y, z, t)$为源项。公式3的递推离散形式（以$\Delta t$为时间步长）为：</p>
<script type="math/tex; mode=display">\frac{u_{t+1}-2u_{t}+u_{t-1}}{\Delta t^{2}}-c^{2}·\nabla^{2}u_t=f_t\tag{4}</script><p>其中，下标$t$表示在固定时刻的标量场值。波动系统的<strong>隐藏状态-Hidden stae</strong>被定义为当前时刻和前一时刻波场分布的级联(concatenation)，$\boldsymbol h_t \equiv[\boldsymbol u_{t-1}, \boldsymbol u_{t-1}]^T$，其中$\boldsymbol u_t$和$\boldsymbol u_{t-1}$均为定义在离散空间网格上的标量场$u_t$和$u_{t-1}$拉平(flatten)后的矢量。此时，波动方程的更新公式可改写为</p>
<script type="math/tex; mode=display">\boldsymbol h_t=\boldsymbol A(\boldsymbol h_{t-1})·\boldsymbol h_{t-1}+\boldsymbol P^{(i)}·\boldsymbol x_t \tag{5}</script><script type="math/tex; mode=display">\boldsymbol y_t = (\boldsymbol P^{o}·\boldsymbol h_t)^{2}\tag{6}</script><p>其中稀疏矩阵$A$，描述了无源波场$\boldsymbol u_t$和$\boldsymbol u_{t-1}$的更新量（如图1E所示）。公式$5$和$6$推导过程见S1。<br>对于足够大的场强，$A$对$\boldsymbol h_{t-1}$的依赖性可以通过形式为$c=c_lin+u^{2}_t·c_{nl}$的强度依赖波速实现，其中$c_{nl}$表现为介质局部区域中的非线性响应。事实上，这种类型的非线性响应会在各种博物理线性中遇到，例如水波、Kerr效应<sup id="fnref:19"><a href="#fn:19" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="R. W. Boyd, Nonlinear Optics (Academic Press, 2008).
">[19]</span></a></sup>的非线性光学材料、起泡流体以及柔软介质中的声波<sup id="fnref:20"><a href="#fn:20" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="T. Rossing, Springer Handbook of Acoustics (Springer Science & Business Media, 2007). 
">[20]</span></a></sup>等。章节S2中提供了非线性材料响应的讨论和分析。正如激活函数$\sigma^{(y)}(·)$之于标准RNN中，当输出为波强度度量时，隐藏状态$\boldsymbol h_t$和输出$\boldsymbol y_t$之间的非线性关系在波动物理中也是非常典型的，正如公式$6$所示。<br>与标准RNN类似，波动方程中隐藏状态以及输入和输出之间的关系是由线性算子定义的，这里给定$\boldsymbol P^{(i)}$和$\boldsymbol P^{(o)}$。这些矩阵给定了空间中的注入(injecting)和测量(measuring)点。与输入和输出均为密集矩阵的标准RNN不同的是，波动方程的输入和输出矩阵都是稀疏的，因为他们只在注入和测量点是非零的。此外，这些矩阵在训练过程中都是不变的。与矩阵构造相关的更多信息请参照章节S3。<br>波动方程中可训练的自由参数为波速$c(x, y, z)$，对应于实际中材料的物理配置和布局。因此，当以离散时间（图1E）进行建模时，波动方程定义了一个映射到RNN的运算（图1B）。与RNN相类似，整个波动方程的动态过程可以被视为一个有向图，但相反的是，拉普拉斯算子的存在（最近邻耦合）使得信息通过隐藏层的速度是有限的。<br><img src="/2021/04/23/10.1126sciadv.aay6946/fig01.png" alt="RNN"><br>图1.标准RNN和基于波动物理系统的概念比较(A)作用于离散输入序列上并产生离散输出序列的RNN单元图(B)RNN单元的内部组成部分，由可训练密集矩阵$\boldsymbol W^{(h)}$、$\boldsymbol W^{(x)}$、$\boldsymbol W^{(y)}$组成。隐态和输出的激活函数分别用$\sigma^{(h)}$和$\sigma^{(y)}$表示(C)RNN单元的有向图(D)连续物理系统在连续输入序列上运行并产生连续输出序列的循环表示图(E)波动方程用有限差分离散时递推关系的内部分量(F)连续物理系统离散时间步长的有向图，以及波扰动如何在空间内传播示意图。</p>
<h2 id="DISCUSSION"><a href="#DISCUSSION" class="headerlink" title="DISCUSSION"></a>DISCUSSION</h2><p>本文提出的基于波动力学的RNN具有许多优点，为其处理时间编码信息提供了可能。与标准RNN不同的是，波动方程从一个时刻到下一个时刻的更新通过拉普拉斯算子（由图1E中的稀疏矩阵表示）强制隐态元素之间的最近邻耦合。这种近邻耦合是由于波动方程是一个双曲偏微分方程，其中信息以有限的速度传播。因此，模拟RNN隐藏状态的大小，以及它的存储容量，直接由传播介质的大小决定。此外，与传统的RNN不同，波动方程加强了能量守恒约束，防止了隐态范数和输出信号的无限增长。相反，定义标准RNN更新关系的无约束稠密矩阵将会导致梯度消失和爆炸，这对传统RNN的训练提出了重大挑战<sup id="fnref:27"><a href="#fn:27" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="L. Jing, Y. Shen, T. Dubcek, J. Peurifoy, S. Skirlo, Y. LeCun, M. Tegmark, M. Soljačić, Tunable Efficient Unitary Neural Networks (EUNN) and their application to RNNs, Proceedings of the 34th International Conference on Machine Learning-Volume 70 (JMLR.org, 2017), pp. 1733–1741.
">[27]</span></a></sup>。</p>
<p>我们已经证明了波动方程动力学在概念上等同于RNN。这种概念上的联系为一类新的模拟硬件平台提供了机会，在这种平台中，演化的时间动力学在物理和数据集中都扮演着重要角色。虽然我们把重点放在最一般的例子波动动力学（标量波动方程），我们的结果可以很容易地扩展到其他类波物理。这种利用物理进行计算的方法<sup id="fnref:9"><a href="#fn:9" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="X. Lin, Y. Rivenson, N. T. Yardimci, M. Veli, Y. Luo, M. Jarrahi, A. Ozcan, All-optical machine learning using diffractive deep neural networks. Science 361, 1004–1008 (2018).
">[9]</span></a></sup><sup id="fnref:28"><a href="#fn:28" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="A. Silva, F. Monticone, G. Castaldi, V. Galdi, A. Alù, N. Engheta, Performing mathematical operations with metamaterials. Science 343, 160–163 (2014).
">[28]</span></a></sup><sup id="fnref:32"><a href="#fn:32" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="N. M. Estakhri, B. Edwards, N. Engheta, Inverse-designed metastructures that solve equations. Science 363, 1333–1338 (2019).
">[32]</span></a></sup>可能会为模拟机器学习设备提供一个新的平台，它有可能比数字设备更自然、更有效地进行计算。该方法的普遍性进一步表明，许多物理系统可能是对动态信号（例如光学、声学或地震学中的信号）执行类似RNN的计算。</p>
<h2 id="MATERIALS-AND-METHODS"><a href="#MATERIALS-AND-METHODS" class="headerlink" title="MATERIALS AND METHODS"></a>MATERIALS AND METHODS</h2><h3 id="Numerical-modeling"><a href="#Numerical-modeling" class="headerlink" title="Numerical modeling"></a>Numerical modeling</h3><p>利用Python编写的自定义软件包对波动方程物理进行了数值模拟和仿真。该软件是在流行的机器学习库PyTorch<sup id="fnref:33"><a href="#fn:33" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="A. Paszke, S. Gross, S. Chintala, G. Chanan, E. Yang, Z. DeVito, Z. Lin, A. Desmaison, L. Antiga, A. Lerer, Automatic differentiation in PyTorch, Workshop on Autodiff (NIPS, 2017).
">[33]</span></a></sup>的基础上开发的，通过逆向模式自动微分计算损失函数相对于材料分布的梯度。在物理和工程领域的逆设计中，这种梯度计算方法通常被称为伴随变量法，并且需要额外进行一次模拟。我们注意到，在地震数据集的全波形反演中，已经提出了使用机器学习框架进行数值模拟的相关方法<sup id="fnref:34"><a href="#fn:34" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="A. Richardson, Seismic full-waveform inversion using deep learning tools and techniques. arXiv:1801.07232 [physics.geo-ph] (22 January 2018).">[34]</span></a></sup>。进行数值模拟和波动方程训练的代码，以及生成本文中给出的图形的代码，可在<a href="https://www.github.com/fancompute/wavetorch/">github</a>上找到。</p>
<p><details><summary>参考文献</summary></details></p>
<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">O. Russakovsky, J. Deng, H. Su, J. Krause, S. Satheesh, S. Ma, Z. Huang, A. Karpathy, A. Khosla, M. Bernstein, A. C. Berg, L. Fei-Fei, Imagenet large scale visual recognition challenge. Int. J. Comput. Vis. 115, 211–252 (2015).<a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">I. Sutskever, O. Vinyals, Q. V. Le, Sequence to sequence learning with neural networks, in Advances in Neural Information Processing Systems, NIPS Proceedings, Montreal, CA, 2014.<a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">J. M. Shainline, S. M. Buckley, R. P. Mirin, S. W. Nam, Superconducting optoelectronic circuits for neuromorphic computing. Phys. Rev. Appl. 7, 034013 (2017).<a href="#fnref:3" rev="footnote"> ↩</a></span></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">A. N. Tait, T. F. D. Lima, E. Zhou, A. X. Wu, M. A. Nahmias, B. J. Shastri, P. R. Prucnal, Neuromorphic photonic networks using silicon photonic weight banks. Sci. Rep. 7, 7430 (2017).<a href="#fnref:4" rev="footnote"> ↩</a></span></li><li id="fn:5"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">5.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">M. Romera, P. Talatchian, S. Tsunegi, F. Abreu Araujo, V. Cros, P. Bortolotti, J. Trastoy, K. Yakushiji, A. Fukushima, H. Kubota, S. Yuasa, M. Ernoult, D. Vodenicarevic, T. Hirtzlin, N. Locatelli, D. Querlioz, J. Grollier, Vowel recognition with four coupled spin-torque nano-oscillators. Nature 563, 230–234 (2018).<a href="#fnref:5" rev="footnote"> ↩</a></span></li><li id="fn:6"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">6.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">Y. Shen, N. C. Harris, S. Skirlo, M. Prabhu, T. Baehr-Jones, M. Hochberg, X. Sun, S. Zhao, H. Larochelle, D. Englund, M. Soljačić, Deep learning with coherent nanophotonic circuits. Nat. Photonics 11, 441–446 (2017).<a href="#fnref:6" rev="footnote"> ↩</a></span></li><li id="fn:7"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">7.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">J. Biamonte, P. Wittek, N. Pancotti, P. Rebentrost, N. Wiebe, S. Lloyd, Quantum machine learning. Nature 549, 195–202 (2017).<a href="#fnref:7" rev="footnote"> ↩</a></span></li><li id="fn:8"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">8.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">F. Laporte, A. Katumba, J. Dambre, P. Bienstman, Numerical demonstration of neuromorphic computing with photonic crystal cavities. Opt. Express 26, 7955–7964 (2018).<a href="#fnref:8" rev="footnote"> ↩</a></span></li><li id="fn:9"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">9.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">X. Lin, Y. Rivenson, N. T. Yardimci, M. Veli, Y. Luo, M. Jarrahi, A. Ozcan, All-optical machine learning using diffractive deep neural networks. Science 361, 1004–1008 (2018).<a href="#fnref:9" rev="footnote"> ↩</a></span></li><li id="fn:10"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">10.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">E. Khoram, A. Chen, D. Liu, L. Ying, Q. Wang, M. Yuan, Z. Yu, Nanophotonic media for artificial neural inference. Photon. Res. 7, 823–827 (2019).<a href="#fnref:10" rev="footnote"> ↩</a></span></li><li id="fn:11"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">11.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">K. Yao, G. Zweig, M.-Y. Hwang, Y. Shi, D. Yu, Recurrent neural networks for language understanding (Interspeech, 2013), pp. 2524–2528; https://www.microsoft.com/en-us/ research/publication/recurrent-neural-networks-for-language-understanding/.<a href="#fnref:11" rev="footnote"> ↩</a></span></li><li id="fn:12"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">12.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">M. Hüsken, P. Stagge, Recurrent neural networks for time series classification. Neurocomputing 50, 223–235 (2003).<a href="#fnref:12" rev="footnote"> ↩</a></span></li><li id="fn:13"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">13.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">G. Dorffner, Neural networks for time series processing. Neural Net. World 6, 447–468 (1996).<a href="#fnref:13" rev="footnote"> ↩</a></span></li><li id="fn:14"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">14.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">J. T. Connor, R. D. Martin, L. E. Atlas, Recurrent neural networks and robust time series prediction. IEEE Trans. Neural Netw. 5, 240–254 (1994).<a href="#fnref:14" rev="footnote"> ↩</a></span></li><li id="fn:15"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">15.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">J. L. Elman, Finding structure in time. Cognit. Sci. 14, 179–211 (1990).<a href="#fnref:15" rev="footnote"> ↩</a></span></li><li id="fn:16"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">16.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">M. I. Jordan, Serial order: A parallel distributed processing approach. Adv. Physcol. 121, 471–495 (1997).<a href="#fnref:16" rev="footnote"> ↩</a></span></li><li id="fn:17"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">17.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">I. Goodfellow, Y. Bengio, A. Courville, Deep Learning (MIT Press, 2016).<a href="#fnref:17" rev="footnote"> ↩</a></span></li><li id="fn:18"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">18.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">F. Ursell, The long-wave paradox in the theory of gravity waves. Math. Proc. Camb. Philos. Soc. 49, 685–694 (1953).<a href="#fnref:18" rev="footnote"> ↩</a></span></li><li id="fn:19"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">19.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">R. W. Boyd, Nonlinear Optics (Academic Press, 2008).<a href="#fnref:19" rev="footnote"> ↩</a></span></li><li id="fn:20"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">20.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">T. Rossing, Springer Handbook of Acoustics (Springer Science &amp; Business Media, 2007).<a href="#fnref:20" rev="footnote"> ↩</a></span></li><li id="fn:27"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">27.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">L. Jing, Y. Shen, T. Dubcek, J. Peurifoy, S. Skirlo, Y. LeCun, M. Tegmark, M. Soljačić, Tunable Efficient Unitary Neural Networks (EUNN) and their application to RNNs, Proceedings of the 34th International Conference on Machine Learning-Volume 70 (JMLR.org, 2017), pp. 1733–1741.<a href="#fnref:27" rev="footnote"> ↩</a></span></li><li id="fn:28"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">28.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">A. Silva, F. Monticone, G. Castaldi, V. Galdi, A. Alù, N. Engheta, Performing mathematical operations with metamaterials. Science 343, 160–163 (2014).<a href="#fnref:28" rev="footnote"> ↩</a></span></li><li id="fn:32"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">32.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">N. M. Estakhri, B. Edwards, N. Engheta, Inverse-designed metastructures that solve equations. Science 363, 1333–1338 (2019).<a href="#fnref:32" rev="footnote"> ↩</a></span></li><li id="fn:33"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">33.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">A. Paszke, S. Gross, S. Chintala, G. Chanan, E. Yang, Z. DeVito, Z. Lin, A. Desmaison, L. Antiga, A. Lerer, Automatic differentiation in PyTorch, Workshop on Autodiff (NIPS, 2017).<a href="#fnref:33" rev="footnote"> ↩</a></span></li><li id="fn:34"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">34.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">A. Richardson, Seismic full-waveform inversion using deep learning tools and techniques. arXiv:1801.07232 [physics.geo-ph] (22 January 2018).<a href="#fnref:34" rev="footnote"> ↩</a></span></li></ol></div></div><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>文献翻译</category>
      </categories>
      <tags>
        <tag>深度学习与计算地球物理</tag>
      </tags>
  </entry>
  <entry>
    <title>Born散射级数</title>
    <url>/2021/06/12/IPTS_BOX11.1/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="Born散射级数"><a href="#Born散射级数" class="headerlink" title="Born散射级数"></a>Born散射级数</h1><p>Born散射级数是由Lippmann-Schwinger积分方程推导而来的，在应用这个方程时，除预测地震响应的实际介质外，我们还需要选择一个背景介质(参考介质)。</p>
<p>下面我们从频率域中控制压力场的波动方程开始推导相关方程。若$P({\rm \textbf x}, \omega, {\rm \textbf x}_s)$表示由位于${\rm \textbf x}_s$处点源激发， 在${\rm \textbf x}$处记录的压力场，它遵守以下方程：</p>
<script type="math/tex; mode=display">L({\rm \textbf x}, \omega) P({\rm \textbf x}, \omega, {\rm \textbf x}_s) = -S(\omega)\delta ({\rm \textbf x} - {\rm \textbf x}_s), \tag{11.33}</script><p>其中，</p>
<script type="math/tex; mode=display">L({\rm \textbf x}, \omega) = \omega^2K({\rm \textbf x}) + {\rm {div}}[\sigma({\rm \textbf x}) \textbf{grad}],\tag{11.34}</script><p> $K({\rm \textbf x})$表示压缩系数(体积模量的倒数)，$\sigma({\rm \textbf x})$为比容积(密度的倒数)，$S(\omega)$为位于${\rm \textbf x}_s$的源。</p>
<p>波在背景介质中传播所产生的压力场$P_0=P_0({\rm \textbf x}, \omega, {\rm \textbf x}_s)$满足如下方程：</p>
<script type="math/tex; mode=display">L_0({\rm \textbf x}, \omega) P_0({\rm \textbf x}, \omega, {\rm \textbf x}_s) = -S(\omega)\delta ({\rm \textbf x} - {\rm \textbf x}_s), \tag{11.33}</script><p>并有：</p>
<script type="math/tex; mode=display">L_0({\rm \textbf x}, \omega)=\omega^2 K_0 + {\rm {div}}[\sigma_0 \textbf{grad}]\tag{11.36}</script><p>上式中$L_0=L_0({\rm \textbf x}, \omega)$为描述背景介质波动方程的微分算子。$K_0$为压缩系数，$\sigma_0$为比容积。</p>
<p>同时，我们还需要背景介质中波动方程的格林函数$G_0=G_0({\rm \textbf x}, \omega, {\rm \textbf x}_s)$, 其定义如下：</p>
<script type="math/tex; mode=display">L_0({\rm \textbf x}, \omega)G_0({\rm \textbf x}, \omega;{\rm \textbf x}^{\prime})=-\delta({\rm \textbf x}-{\rm \textbf x}^{\prime})\tag{11.37}</script><p>所以，</p>
<script type="math/tex; mode=display">P_0({\rm \textbf x}, \omega, {\rm \textbf x}_s)=S(\omega)G_0({\rm \textbf x}, \omega;{\rm \textbf x}_s) \tag{11.38}</script><p>另一个我们需要的量是格林函数的逆：$G_{0}^{-1} = G_{0}^{-1}({\rm \textbf x}, \omega;{\rm \textbf x}_s)$，其由如下公式所定义：</p>
<script type="math/tex; mode=display">\int d{\rm \textbf x}^{\prime}G_0({\rm \textbf x}, \omega;{\rm \textbf x}^{\prime}) G_0^{-1}({\rm \textbf x}^{\prime}, \omega;{\rm \textbf x}^{\prime\prime}) \tag{11.39}</script><p>利用压力场$P_0$和格林函数$G_0$，Lippmann-Schwinger积分方程给出了压力场$P$的一个解，即在实际介质中的任何地方，都有如下积分方程:</p>
<script type="math/tex; mode=display">\begin{align}
\notag
P({\rm \textbf x}, &\omega, {\rm \textbf x}_s) = P_0({\rm \textbf x}, \omega, {\rm \textbf x}_s) \\
\notag
&+\int_D d{\rm \textbf x}^{\prime} G_0({\rm \textbf x}, \omega;{\rm \textbf x}^{\prime}) W({\rm \textbf x}^{\prime}, \omega) P({\rm \textbf x}, \omega;{\rm \textbf x}^{\prime})
\end{align}\tag{11.40}</script><p>其中，</p>
<script type="math/tex; mode=display">W({\rm \textbf x}, \omega) = L({\rm \textbf x}, \omega)-L_0({\rm \textbf x}, \omega)\tag{11.41}</script><p>$D$为$W({\rm \textbf x}, \omega)$的定义域($D$外$W({\rm \textbf x}, \omega)$为<code>null</code>)，如图11.6中所示，11.40可用如下更简洁形式表示：</p>
<script type="math/tex; mode=display">P=P_0+G_0WP\tag{11.42}</script><p>或者，</p>
<script type="math/tex; mode=display">P=[I-G_0W]^{-1}P_0\tag{11.43}</script><p> 其中，$G_0({\rm \textbf x}, \omega, {\rm \textbf x}^{\prime})$为$G_0$的核，$W({\rm \textbf x}, \omega)$为势$W$的核。<br>将11.42泰勒展开后即可得到$Born$逆散射级数：</p>
<script type="math/tex; mode=display">\begin{align}
\notag
P &= P_0 \\
\notag&+G_0WP_0 \\
\notag&-G_0WG_0WP_0 \\
\notag&+G_0WG_0WG_0WP_0-...
\notag\end{align}
\tag{11.44}</script><p>或者，</p>
<script type="math/tex; mode=display">\begin{align}
\notag
P &= P_0 \\
\notag&+SG_0WG_0 \\
\notag&-SG_0WG_0WS_0 \\
\notag&+SG_0WG_0WG_0WS_0-...
\end{align}
\tag{11.45}</script><p>$Born$散射级数也可写为：</p>
<script type="math/tex; mode=display">P=P_0+SG_0W^{\prime}G_0\tag{11.46}</script><script type="math/tex; mode=display">\begin{align}
\notag W^{\prime} &= W \\
\notag & - WG_0 W  \\
\notag & + WG_0 WG_0 W  \\
\notag & - WG_0 WG_0 WG_0 W  
\end{align}
\tag{11.47}</script><p>忽略$Born$级数(公式11.44和11.45)三阶及以上项即可得到$Born$近似：</p>
<script type="math/tex; mode=display">P \approx P_0+SG_0WG_0 \tag{11.48}</script><p>将11.46做如下替换也可得到11.48所示的$Born$近似：</p>
<script type="math/tex; mode=display">W^{\prime} = W.\tag{11.49}</script><p>通过不同的方式均能够在保证$P$和$W$线性关系的同时得到$Born$近似。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>地球物理数理知识</category>
      </categories>
      <tags>
        <tag>Born散射级数</tag>
      </tags>
  </entry>
  <entry>
    <title>反问题</title>
    <url>/2021/06/11/IPTS_ch11_445~456/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="11-反问题例子：线性化地震数据反演"><a href="#11-反问题例子：线性化地震数据反演" class="headerlink" title="11. 反问题例子：线性化地震数据反演"></a>11. 反问题例子：线性化地震数据反演</h1><p>我们必须对间接测量得到的地震数据使进行处理和解释之后，才能较为合理地推断地下模型。我们需要对地下介质的物理性质进行建模，例如确定岩层之间的界面位置、估计岩层物理性质等。由一个给定数据集到与该数据集相关联的最优地下模型的这一过程被称为求解反问题。在这一节中，我们介绍石油地震学家解决这一问题所采取的一些方法。</p>
<h1 id="分步式反演"><a href="#分步式反演" class="headerlink" title="分步式反演"></a>分步式反演</h1><h2 id="反问题的基础要素"><a href="#反问题的基础要素" class="headerlink" title="反问题的基础要素"></a>反问题的基础要素</h2><p>反问题存在于诸多领域，例如量子力学、医学成像等。但是，较为广义的反问题理论是由研究地球物理数据的人们发展起来的。地球物理学家试图了解地球内部，但唯一可用的数据是在地球表面、海面、海底或钻孔等位置收集的。<br>脱离于学科概念，反问题的解决通常要包含以下三个步骤：</p>
<ol>
<li><strong>建立模型参数</strong>。即通过可用数据构建最佳的模型参数。但是由于我们数据的限制，这一般是不可能的。例如，根据以下$AVA$响应$f_{ava}$确定两个各向同性弹性岩层之间的弹性参数的对比度(constrast)。<script type="math/tex; mode=display">f_{ava}=\Delta I_P+(\Delta I_S-3\Delta\mu)sin^2\theta+4\Delta\mu sin^4\theta \tag{11.1}</script>当$\theta \in [0,30^{\circ}]$时，由于$sin^4\theta$较小，因此以上公式中只有两个参数(即$[\Delta I_P, \Delta I_S-3\Delta\mu]$)，而非三个参数(即$[\Delta I_P, \Delta I_S-3\Delta\mu, \Delta \mu]$)。所以，由于数据的局限性，我们无法重构出精确的模型。物理量$\Delta I_P, \Delta I_S, \Delta \mu$分别代表纵波阻抗对比度、横波阻抗对比度和剪切模量对比度。<br><img src="/2021/06/11/IPTS_ch11_445~456/11.1.png" alt="11.1"></li>
<li><strong>正演</strong>(forward modeling)。对于给定的模型参数，该步骤意味着我们要在一定物理定律的约束下来预测该模型参数下的数据（如图11.1所示）。方程11.1给出了在特定弹性参数对比度下的$AVA$响应。<strong>波动方程</strong>也是正演的一种基本方式(如第2和6节所示)，基于波动方程的正演模拟允许我们使用密度、拉梅系数等弹性参数来预测地震记录。</li>
<li><strong>反演</strong>(inverse problem)。该步骤需要我们使用观测数据来推断模型参数，使得由该模型参数正演得到的<strong>预测数据</strong>(Predicted data)在特定的<strong>准则</strong>(Criterion)下能够很好地拟合<strong>观测数据</strong>(Observed data)。使预测数据和观测数据的误差平方和最小是最为常用的准则(如公式11.2所示)<script type="math/tex; mode=display">F=\sum_s \sum_r \int_{t_0}^{t_1} [P_{obs}(x_s, x_r, t)-P_{pred}(x_s, x_r, t)]^2 dt</script>其中，$P_{obs}(x_s, x_r, t)$和$P_{pred}(x_s, x_r, t)$分别代表观测数据和合成数据。$x_s$表示炮点位置($s=1,2,…$)；$x_r$表示接受点位置($r=1,2,…$)；$t$表示旅行时$t_0\leq t\leq t_1$。</li>
</ol>
<p>以上步骤中有非常强的反馈机制，在任何一步中的提升一般都可以用到其它两个步骤中。</p>
<p>在本节中我们只关注地震数据的反演。</p>
<h2 id="非唯一性、不稳定性、收敛性、不确定性、成本"><a href="#非唯一性、不稳定性、收敛性、不确定性、成本" class="headerlink" title="非唯一性、不稳定性、收敛性、不确定性、成本"></a>非唯一性、不稳定性、收敛性、不确定性、成本</h2><p>石油地震学中反问题的求解通常会遇到五个基础性问题：①<strong>非唯一性</strong>。即如何确定由给定数据所反演的模型与实际情况最为匹配。②<strong>不稳定性</strong>。即数据中的微小扰动可能会导致反演结果中的较大扰动。③<strong>收敛性</strong>。即迭代求解反问题时可能出现。④<strong>不确定性</strong>。即物理模型不准确、物理模型不完整性以及测量的不确定性等⑤<strong>成本</strong>。反问题求解过程中的正问题的成本。</p>
<p><img src="/2021/06/11/IPTS_ch11_445~456/11.2.png" alt="11.2"><br>为了使我们刚才提出的反问题解决方案的相关问题更加具体，让我们看几个例子。如图11.2所示，两个完全不同模型，入射角为$30^{\circ}$以下时的亚临界$AVA$响应（振幅随角度变化）几乎完全一样，此即<strong>非唯一性</strong>问题。对于超过$30^{\circ}$的入射角、$AVA$响应的差异足以区分这两种模型。换言之，石油地震学问题中大量的非均匀性可以通过改进我们的理论或抛弃一些假设来解决，或者通过改进我们采集数据的观测系统，例如，长偏移距，以便采集大于$30^{\circ}$入射角的数据。<br><img src="/2021/06/11/IPTS_ch11_445~456/11.3new.png" alt="11.3"><br>图11.3显示了亚临界PP反射的$AVA$响应来重构横波速度所产生的不稳定性问题。我们可以看到，当对横波速度施加$50%$变化量后，$PP$反射的$AVA$响应几乎没有变化。这种<strong>不稳定性</strong>的结果就是，我们可能无法通过$PP$反射数据来区分松散沉积物和固结岩层。但是，正如在非唯一性问题中所讲的那样，我们可以改进理论、抛弃一些假设或者改进采集数据的观测系统来解决不稳定性问题。例如，在长偏移距数据能够看到明显的$PS$反射能量。事实上，从图11.3中可以看出，可以通过使用$PP$反射的临界后$AVA$响应或者$PS$的$AVA$响应来对两种模型加以区分。<br><img src="/2021/06/11/IPTS_ch11_445~456/11.4.png" alt="11.4"><br>接下来让我们看一下物理模型的<strong>不准确性</strong>问题。假设我们正演中用于预测$PP$反射的物理模型是基于声波方程，而不是弹性方程（见第2章和第6章）。如图11.4所示，尽管声波方程能够很好地预测旅行时，但是振幅确实完全不正确的，在大偏移距处更为明显。同样，这些不准确的结果是，我们可能无法区分某些岩性。</p>
<p>正如我们在第7~10章中所描述的，地震数据含有大量的多余的能量，例如地滚波、涌浪噪声、多次波等等。当反问题迭代求解时，这些不需要的信号（通常比期望的信号大得多）会减慢收敛到最优解的速度，甚至会导致地下模型的不精确。事实上，选择最佳地下模型的大多数标准包括拟合观测数据和为给定地下模型预测的数据。但是，根据这些标准建立的模型往往同时解释了数据中的可能是噪声的大振幅信号，例如地滚波等。解决这个<strong>收敛性</strong>问题的一种方法是在开始反演之前从数据中尽可能多地去除不必要的能量。</p>
<p>下面考虑石油地震学中正问题的成本。正问题即在一组初始条件、最终条件和边界条件下，求解控制波在地球中传播的微分方程。有限差分模拟是求解波动方程的常用方法，其对偏微分方程中的偏导数作了数值近似（附录C）。对时间和空间进行适当地离散后，就能够较为精确的计算波动方程中的偏微分。在这种情况下，有限差分正演模拟（FDM）技术是迄今为止通过复杂地质模型（如勘探与生产行业目前面临的模型）模拟弹性波传播的最精确的工具。但是，其计算成本非常高。建设我们对一个离散成$1000\times1000\times500$个空间网格的复杂地质模型进行弹性波正演模拟，在时间上递推4000次。我们估计，在SGI Origin 2000（由Silicon Graphics，Inc.提供）上，使用20个CPU进行40000次的小型3D正演计算需要12年以上时间，远远超过了某些石油储层的生产寿命(编者注：本书写于2005年)。</p>
<h2 id="地震反问题的分步式方法"><a href="#地震反问题的分步式方法" class="headerlink" title="地震反问题的分步式方法"></a>地震反问题的分步式方法</h2><p>在实际应用中，我们并不是开发单一的反演算法，让其接收野外数据输入然后生成地下模型，而是将其划分为多个步骤，以更好地处理不稳定性、唯一性、不确定性、收敛性，正演成本等问题。这里的基本思想是，我们对数据、问题的物理性质以及其他先验地质和地球物理信息的了解越深入，越有助于引导反问题解远离不稳定性和非均匀性。这些知识甚至可以帮助我们减少正演成本，因为它允许我们采用具有多种人类交互可能性的多步反演方案，而不是单步方案，如图11.5所示。<br><img src="/2021/06/11/IPTS_ch11_445~456/11.5.png" alt="11.5"><br>当前<strong>海洋数据</strong>多步反演方案包含以下关键步骤：</p>
<ol>
<li>去鬼波（即对震源和接收器鬼波的影响进行校正）；</li>
<li>去多次波（即自由面多次波的衰减）；</li>
<li>宏观模型速度的估计（即估计最适合地震数据中包含的走时的速度模型），这也被称为背景模型；</li>
<li>线性化反演（即，地震数据反演，假设数据已针对多次反射进行了校正，并且背景模型已知）。</li>
</ol>
<p>在<strong>陆地地震</strong>中，关键步骤如下：</p>
<ol>
<li>地滚波衰减；</li>
<li>静校正；</li>
<li>宏观模型速度估计；</li>
<li>线性化反演。</li>
</ol>
<p><strong>井中地震</strong>关键步骤如下：</p>
<ol>
<li>上下分离；</li>
<li>多次波衰减；</li>
<li>线性化反演。</li>
</ol>
<p>注意，在井中地震中，速度模型通常可从测井测量中获得。因此，通常不需要进行速度估计。我们不能用三章内容来描述所有这些处理步骤。我们将重点讨论海洋数据多步反演的四个步骤。对这四个步骤的描述为有助于了解本章内容。</p>
<p>由于成本原因，其中的一些步骤，例如多次波去除，都是从几何光学或者纯信号处理领域发展来的(例如Chapter8中$fk$倾角滤波方法)，并不是基于波动方程的。这些工具倾向于只关注旅行时变化而忽略振幅变化。并且，这些方法还会产生假象，并且在数据中留有较大的残差。但是由于这些方法对于计算资源的需求较小，因此应用较为广泛。但随着近年来计算能力的提升，人们不再考虑使用这些几何光学工具来替换基于波动方程的方法。此外，为达到现在地震资料处理中追求的高分辨率和多次波衰减的目的，我们也必须基于运动学和动力学更加精确的波动方程方法。这些方法背后的理论是地震学中用于表示波场的两个积分方程：$Lippmann-Schwinger$积分方程和表示定理。$Lippmann-Schwinger$积分方程导出了所谓的$Born$散射级数，而表示定理导出了$Kirchhoff$散射级数。上述反演的四个步骤(去鬼波、多次波衰减、宏观模型估计和线性化反演)均可以通过$Born$散射级数和$Kirchhoff$散射级数推导得出，正如我们在第10章多次衰减中看到的那样。<strong>本章的重点是线性化反演和宏观模型的估计</strong>。</p>
<p>在前面的章节中，我们提到了<strong>NMO</strong>，<strong>DMO</strong>，偏移等作为地震成像的工具。我们刚才描述的地震反问题中，这些工具从何而来？在本章中，我们将看到<strong>偏移只是线性化反演的一个特例</strong>。我们还将动校正叠加与线性化反演、以及倾角校正叠加联系起来。</p>
<h1 id="反问题示例的关键假设"><a href="#反问题示例的关键假设" class="headerlink" title="反问题示例的关键假设"></a>反问题示例的关键假设</h1><p>在对数据进行去多次波和去鬼波处理(如Cahpters9和10所述)之后，下一步是从包含初至波的数据中构建地下模型。这一章节中我们通过线性化反演解来讲述如何解决反问题，线性化反演非常好地提供了一种从原始数据域构建地震剖面的方法。线性化反演问题的关键假设如下面的章节所述。</p>
<h1 id="Born近似"><a href="#Born近似" class="headerlink" title="Born近似"></a>Born近似</h1><p>如前所述，通过正演模拟求解物理规律允许我们以最经济有效的方式获得预测数据。对于给定的地下模型，我们本章节的任务是选择一组物理定律来预测<strong>只包含初至波</strong>的拖揽数据。<br>第6节中所述的一阶波动方程以及初始和边界条件，或者是$Lippmann-Schwinger$积分方程是两个解决正问题的工具。</p>
<h2 id="基于有限差分求解正问题"><a href="#基于有限差分求解正问题" class="headerlink" title="基于有限差分求解正问题"></a>基于有限差分求解正问题</h2><p>使用波动方程求解只有初至波的正问题与求解包含多次波的完整数据几乎是完全相同的。我们将不施加如Chapter3所述的自由界面边界条件，而是假设水层是无限的。从实用角度看，当用有限差分计算波动方程的解时（见附录C），我们需要用吸收边界条件来代替自由界面边界条件。因此，就计算所消耗的时间而言，使数据仅包含初至波是没有任何收益的。实际上，在某些情况下，仅计算包含初至波的波场要比包含多次波的全波场数据更加费时，因为吸收边界条件的数值模拟要比自由界面边界条件计算成本更高。</p>
<h2 id="基于Born近似求解正问题"><a href="#基于Born近似求解正问题" class="headerlink" title="基于Born近似求解正问题"></a>基于Born近似求解正问题</h2><p>正演模拟的另一种解决方案是$Lippmann-Schwinger$积分方程，或与该积分方程相关的$Born$散射级数(见Box 11.1)。这要求我们将实际的介质分解为背景模型(或参考模型、宏观模型)和扰动模型(散射模型)两部分。在这一分解中，震源和接收点均位于背景模型中，如图11.6所示。没有接触到扰动模型，直接从震源到达接收点的波被称为直达波场(非扰动波场)，与扰动模型相互作用的波则构成了扰动波场(散射波场)。<br><img src="/2021/06/11/IPTS_ch11_445~456/11.6new.png" alt="11.6"><br>对于给定的地下介质模型，如<strong>Box 11.1</strong>所示的$Lippmann-Schwinger$积分方程允许我们预测产生只包含初至的数据，这里用$P$来表示：</p>
<script type="math/tex; mode=display">P=P_0+SG_0WG\tag{11.3}</script><p>其中，</p>
<script type="math/tex; mode=display">P_0=SG_0\tag{11.4}</script><p>这里，$P_0$表示直达波场，$S$表示震源，$G_0$代表背景介质中波动方程的格林函数，$G$代表真实介质中波动方程的格林函数，$W$表示散射势。散射波场$\delta P$可表示为:</p>
<script type="math/tex; mode=display">\delta P=P-P0\tag{11.5}</script><p>公式11.3对于任何背景介质都是有效的，而$G_0$是否准去的描述了震源检波点界面以及散射点并不重要。11.3所示的积分可以通过迭代的方式或者通过如<strong>Box 11.1</strong>所示的$Born$级数方式求解。<br>公式11.3还可以改写为：</p>
<script type="math/tex; mode=display">P=P_0+SG_0W^{'}G_0 \tag{11.6}</script><script type="math/tex; mode=display">W^{'}=WGG^{-1}_0\tag{11.7}</script><p>如果我们假设$G_0$足够近似$G$，即$G_0$能够精确预测从散射点到震源和检波器的波场，有如下公式</p>
<script type="math/tex; mode=display">GG^{-1}_0\approx I\tag{11.8}</script><p>式中$I$表示恒等算符——当$W^{‘}$近似等于$W^{‘}$，公式11.6退化为$Born$近似，即</p>
<script type="math/tex; mode=display">P \approx P_0+SG_0WG_0\tag{11.9}</script><p>或者</p>
<script type="math/tex; mode=display">\delta P \approx SG_0WG_0\tag{11.10}</script><p>此外，在高于二阶项均可忽略不计的前提下，我们可以通过截断$Born$级数<strong>Box 11.1</strong>中，只取其前两项，来得到公式11.9和11.10。</p>
<p>因此，我们能够利用公式11.9预测给定散射势的初至波场(即求解正演模拟问题)。然而，与第六章中的$Lippmann-Schwinger$积分方程或一阶波动微分方程组相反，我们在将实际模型分解为背景和扰动模型时，不能简单地选择任意背景模型。只有当背景模型与源-接收器界面和散射点之间的实际介质相同时，方程11.9才有效。另请注意，与11.3中的$Lippmann-Schwinger$积分方程以及有限差分求解波动方程相反，利用$Born$近似得到的方程11.9求解正问题不涉及迭代过程或具有无穷多个项的级数。因此，方程11.9中的$Born$近似不会产生数值不稳定性问题，也不会遇到迭代过程中的收敛问题，其解也不会有无穷多项级数。这些特点使$Born$近似成为解决正演模拟问题的一个非常经济有效的方案，特别是对于背景介质中与波动方程相关的格林函数是明确的或已知解析解时，例如在均匀和一维背景介质中。</p>
<p><strong>此外，其中包含我们最终想要恢复的弹性参数的数据和散射势，在$Born$近似下是线性的。这一特性大大简化了反问题的求解。$Born$近似的缺点是描述波在源-接收器界面和散射点之间传播的背景模型必须是精确的。否则，$Born$近似产生的响应误差较大。</strong></p>
<p>让我们用另一种观点解释$Born$近似，正如第10章所述，初至波要求震源和检波器均位于地下，由于我们在本章中考虑的拖缆数据是在地球表面附近生成和收集的，因此我们必须以某种方式将数据从地球表面附近的实际震源和接收器位置外推到地下的所需位置。这种外推是通过计算描述波在背景介质中传播的格林函数$G_0$来实现的。为了计算这个格林函数，我们需要知道源所在位置和散射点之间介质，以及散射点和接收器位置之间介质的性质。换句话说，我们至少需要知道地下模型的某些部分，以便重建“整个”模型。这一要求被称为基于玻恩近似的<strong>地震成像悖论</strong>。由于目前大多数地震成像方案都是基于$Born$近似的（即使这种假设在一些出版物中往往不明确），这一要求通常被称为地震成像悖论。</p>
<p>总之，用本章所提到的$Born$近似，我们必须将“从包含初至的地震数据中重建地下模型”这一问题分解为两部分：①<strong>找到背景速度模型</strong>，以使得我们能够将数据从震源-检波器界面外推到散射点上；②<strong>重建散射模型</strong>，其中包含引起散射和反射的弹性性质。在接下来的四节中，我们将重点讨论“在背景模型已知前提下重建引起散射的物理属性”这一问题。关于如何估计背景模型的讨论将在标题为“<strong>偏移</strong>”和“<strong>估计背景速度的模型</strong>”的章节中进行。</p>
<h2 id="平滑背景介质"><a href="#平滑背景介质" class="headerlink" title="平滑背景介质"></a>平滑背景介质</h2><p>如图11.7所示，方程11.9中的$Born$近似使我们能够预测初至以及多次波。由于在大多数成像中都假定数据只包含初至，因此我们需要调整11.9的$Born$近似，使预测数据满足成像假设。如果描述背景介质中波动方程的格林函数$G_0$不包含反射波，此时11.9的$Born$近似将只预测初至波。换句话说，如果我们假设背景模型是平滑的(即没有反射或只有非常弱的反射)，那么11.9中的$Born$近似将只预测初至波。实现这种平滑的经典方法是将实际模型分解为两部分：低空间频率分量和高空间频率分量。$a1D$(横向不变)模型的分解示例如图11.8所示，低空间频率（长波数）分量表示背景模型，高空间频率（即短波数）分量引起散射和反射。<br><img src="/2021/06/11/IPTS_ch11_445~456/11.7_8.png" alt="11.7~8"><br>当背景模型中没有反射点时，如图11.8所示，描述波在背景介质中传播的直达波场基本上可以以旅行时和几何扩散来描述，而这两者主要取决于速度变化。这也是为什么<strong>在石油地震学中背景模型一般被称为背景速度模型</strong>。</p>
<h1 id="Born近似的局限性"><a href="#Born近似的局限性" class="headerlink" title="Born近似的局限性"></a>Born近似的局限性</h1><p>如<strong>Box 11.1</strong>所描述的那样，11.3所示$Lippmann-Schwinger $积分方程的解可以表示成$Born$级数的形式，其中此级数的前两项为$Born$近似，有时我们将这种近似称为单散射点近似。通过截断$Born$级数，只取其前两项，我们假设背景介质与实际介质十分相近，并且高于二阶的$Born$级数项均可以忽略不计。<br>下面我们以实际的声速介质为例，将$Born$近似的假设公式化。我们从$Box 11.1$中定义的散射势(散射势的表达式源自量子力学，$W$实际上是粒子散射的势，这一表达现在被那些将散射理论应用于地震学的学者们所广泛采用)出发：</p>
<script type="math/tex; mode=display">W({\rm \textbf x}, \omega)=\omega^2 \delta K({\rm \textbf x})+{\rm div}[\delta \sigma({\rm \textbf {x}}) {\rm \textbf {grad}}] \tag{11.11}</script><script type="math/tex; mode=display">\delta K({\rm \textbf x})=K({\rm \textbf x})-K_0({\rm \textbf x}), \delta \sigma({\rm \textbf x})=\sigma({\rm \textbf x})-\sigma_0({\rm \textbf x}) \tag{11.12}</script><p>其中$K_0({\rm \textbf x})$和$\sigma_0({\rm \textbf x})$分别为背景介质的压缩系数(体积模量的倒数)和比容积(密度的倒数)。$K({\rm \textbf x})$和$\sigma({\rm \textbf x})$分别为实际介质的压缩系数(体积模量的倒数)和比容积(密度的倒数)。在$Born$近似的假设中，背景介质中十分接近于实际介质，即如下公式成立</p>
<script type="math/tex; mode=display">\frac{\delta K({\rm \textbf x})}{K_0({\rm \textbf x})} \leq 1, {\rm and} \frac{\delta \sigma({\rm \textbf x})}{\sigma_0({\rm \textbf x})} \leq1 \tag{11.13}</script><p>下面我们通过比较$Born$近似法的预测数据与精确解对应的数据，来更具体地观察公式11.13所提出的假设。<br>我们必须通过$Born$近似或者利用有限差分求解波动方程的数值解，是因为精确的解析解非常少。为数不多的精确解析解一般仅限于平面波的传播。因此，这里我们将通过一维平面波的传播比较$Born$近似和精确解析解。一维模型如图11.9所示，其由一个嵌入在速度为$V_{P0}=2.0 km/s$的背景介质中的流体介质组成，其中嵌入物速度为$V_{P1}$、厚度为$h$。因此，在这一模型中的散射势可以表示为：</p>
<script type="math/tex; mode=display">W({\rm \textbf x}, \omega)=\omega^2\delta K({\rm \textbf x}) \tag{11.14}</script><p>如果我们将公式11.14带入公式11.10，将得到$Born$近似公式：</p>
<script type="math/tex; mode=display">\delta P({\rm \textbf x}_s, \omega, {\rm \textbf x}_r)=\omega^2S(\omega) \int_D {d{\rm \textbf x} G_0({\rm \textbf x}_s, \omega, {\rm \textbf x}) \delta K({\rm \textbf x})G_0({\rm \textbf x},\omega,{\rm \textbf x}_r)} \tag{11.15}</script><p>其中，$D$为$\delta K(\rm \textbf x)$的定义域，即$\delta K(\rm \textbf x)$在$D$外为null。对于一维介质中垂直于纵轴的入射平面波，方程11.15与坐标$x$和$y$无关；即</p>
<script type="math/tex; mode=display">\delta P(\omega, z_r)=\omega ^2 S(\omega) \int_{z_1}^{z_2} dz G_0(z_s=0,\omega ,z)\delta K(z)G_0(z,\omega ,z_r) \tag{11.16}</script><p>并有</p>
<script type="math/tex; mode=display">G_0(z_s, \omega, z)=-i \frac{V_{P0}}{\omega} {\rm exp}(-i \frac{\omega}{V_{P0}} |z_s-z|)\tag{11.17}</script><p>其中，$z_r$代表检波器深度，$z_s$代表震源深度。假设震源位于表面$z_s=0$。公式11.6变为：</p>
<script type="math/tex; mode=display">\delta P(\omega, z_r)=-S(\omega)\Delta K \int_{z_1}^{z_2}dz {\rm exp}[-o \frac{\omega}{V_{P0}}(z+|z-z_r|)]\tag{11.18}</script><p>其中，</p>
<script type="math/tex; mode=display">\Delta K = \frac{\delta K}{K_0}\tag{11.19}</script><p>对于反射问题(即$z_r \leq z_1$)，对11.18积分可得</p>
<script type="math/tex; mode=display">\delta P(\omega, z_r)=-S(\omega) \Delta K {\rm exp}[-2i\frac{\omega}{V_{P0}}(z_1-z_r)] \times \lbrace -1+{\rm exp}(-2i\frac{\omega}{V_{P0}}h)\rbrace\tag{11.20}</script><p>公式11.20中的指数项控制了波的传播。我们可以看出其只受背景介质$V_{P0}$的影响，而与$V_{P1}$无关。换句话说，$Born$解以背景介质的速度在嵌入体中传播。我们稍后将讨论这些问题对Born解的准确性的影响。<br>11.9所示图的准确压力场可在经典的声学书中看到。所以，我们这里只给出最后的结果：</p>
<script type="math/tex; mode=display">\begin{align}
\notag
 \delta P(\omega, z_r)&=-S(\omega)\frac{V_{P0}-V_{P1}}{V_{P0}+V_{P1}}{\rm exp} [-2i \frac{\omega}{V_{P1}}(z_1-z_r)] \\\\
\notag
&\times \lbrace -1 + \frac{V_{P0}V_{P1}}{(V_{P0}+V_{P1})^2} \sum_{k=0}^{k=\infty} [\frac{V_{P0}-V_{P1}}{V_{P0}+V_{P1}} \times {\rm exp}(-i\frac{\omega}{V_{P1}}h)]^{2k} \rbrace \\\\
\end{align}\tag{11.21}</script><p> 与公式11.20所示的$Born$解不同的是，在准确解中，控制波传播的指数项不但取决于背景介质速度$V_{P0}$，同时还受嵌入体速度$V_{P1}$影响。<br><img src="/2021/06/11/IPTS_ch11_445~456/11.9_10.png" alt="11.9_10"></p>
<p>在我们对方程11.20中的$Born$解和方程11.21中的精确解进行数值比较之前，我们先介绍我们即将讨论的三个重要参数：①在背景介质中传播的信号的主波长，$\lambda_0=V_{P0}/f_c$，其中$f_c$是源信号的主频；② 在嵌入体中传播的信号的主波长，$\lambda_1=V_{P1}/f_c$③嵌入体与背景介质的相对扰动，$\Delta K=\delta K/K_0$。对于下面的数值实验，源信号的主频为35Hz(见图11.10)。<br><img src="/2021/06/11/IPTS_ch11_445~456/11.11_12_13.png" alt="11.11~13"><br>图11.11、11.12和11.13比较了不同嵌入体厚度和不同速度下的$Born$解和精确解。这些计算中使用的震源信号频谱如图11.10所示。我们可以看到，对于信号在嵌入体中传播的波长远大于平板厚度的情况（即$h\leq \lambda_1$）， 当相对扰动小于0.36时，$Born$近似解与精确解几乎一致。然而，随着板的厚度增加，我们可以看到，在$Born$近似解中，嵌入体底部的反射开始偏离精确解，即使$\Delta K$很小。前面我们提到了$Born$近似解与精确解存在差异的原因，即玻恩近似解是以背景介质的速度而不是以平板速度在平板中传播的。如果背景介质的速度与嵌入体速度之差较大，或者波在嵌入体中传播的持续时间足够长，则$Born$近似无法准确预测嵌入体底部反射的到达时间。</p>
<p>我们注意到，$Born$近似中的反射波到时与嵌入体的速度和厚度无关。然而，这种反射的振幅却受到嵌入体与背景介质之间的相对扰动，即$\Delta K$的影响。当$\Delta K=0.55$时，$Born$近似解误差较大。<br>另外，对于板厚为$25m$，板速度为$3.0 km/s$的情况，$Born$近似解的形状与精确解的形状似乎有很大不同。形状不同是因为<strong>玻恩</strong>近似假定波在板中以背景速度传播，它预测的两个同相轴之间有一个小的重叠，而在精确解中，基于波以实际速度传播，由于嵌入体中速度快因此两个同相轴完全重叠。<br>我们还可以看到，当$\Delta K=0.55$，$h \geq100m$时，由于背景介质是均匀的，所以在精确解中能够看到明显的层间多次波，而$Born$近似中却并不明显。如图11.7所示，如果介质是平滑的，$Born$近似无法预测层间多次波；均匀介质是平滑介质的理想情况。<br>总结来讲，$Born$近似解需要①在嵌入体中传播的波的波长要远远大于嵌入体厚度；②相对扰动要足够小。我们通过一维介质中的平面波解得出了以上结论。在更一般意义上，其由嵌入体的厚度$h$和散射势平均强度的乘积来决定。对于一维情况，$Born$近似有效的标准是：</p>
<script type="math/tex; mode=display">\frac{\delta K}{K_0} \frac{h}{\lambda_1} << 1\tag{11.22}</script><p>以上公式对于二维和三维情况下的球面波同样适用，尽管对于二维和三维介质中的球面波这一结论非常难验证。距离和全散射势的平均强度的乘积才是最重要的。<strong>成功应用$Born$近似的关键是，背景介质的选择或估计必须足够准确以捕捉实际模型中包含的所有长波长信息，而扰动模型必须基本上由短波组成。图11.8所示为理想情况下，$Born$近似将介质分解为背景介质和扰动介质。</strong></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>地球物理数理知识</category>
      </categories>
      <tags>
        <tag>反问题</tag>
      </tags>
  </entry>
  <entry>
    <title>Radon变换</title>
    <url>/2021/05/31/ITPS_Radon644~645/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="石油地震学中的Radon变换及快速离散Radon变换"><a href="#石油地震学中的Radon变换及快速离散Radon变换" class="headerlink" title="石油地震学中的Radon变换及快速离散Radon变换"></a>石油地震学中的Radon变换及快速离散Radon变换</h1><h2 id="Radon变换"><a href="#Radon变换" class="headerlink" title="Radon变换"></a>Radon变换</h2><p>翻译自SEG Introduction to petroleum Seismology(pp. 644~645, pp.646~648)<br>在石油地震学中，$Radon$变换首先由Chapman(1978)<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Chapman, C. H., 1978, A new method for computing seismograms: Geophysical Journal of the Royal Astronomical Society, 54, 481–518.
">[1]</span></a></sup>等提出应用。然而，我们在石油地震学中使用的$Radon$变换与其他教科书中可能会遇到的，如Deans(1993，1996)<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Deans, S. R., 1993, The Radon transform and some of its applications: John Wiley & Sons, Inc.
">[2]</span></a></sup><sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Deans, S. R., 1996, Radon and Abel transforms, in A. D. Poularikas, ed., The transforms and applications handbook: CRC Press, 631–717.
">[3]</span></a></sup>，略有不同。在二维空间中，函数的$Radon$变换是由沿线的积分组成的。斜截式直线可表示为：</p>
<script type="math/tex; mode=display">t=px+ \tau \tag{1}</script><p>其中斜率$p=dt/dx$，表示慢度参数，$\tau$表示截距时间，地震剖面$u(x,t)$在$z=0$处的$Radon$变换为：</p>
<script type="math/tex; mode=display">\check{u}=\iint{dx dt \delta(t-px-\tau)u(x,t)}=\int{dx u(x,\tau+px)} \tag{2}</script><p>$Fourier$变换和$Radon$变换之间的关系为：</p>
<script type="math/tex; mode=display">U(\omega p,\omega)=\int{d\tau exp(i \omega \tau)\check{u}(p, \tau)} \tag{3}</script><p>上式可简写为：</p>
<script type="math/tex; mode=display">\mathcal{F}_2u=\mathcal{F}_1 \check{u} \tag{4}</script><p>其中，$\mathcal{F}_2$和$\mathcal{F}_1$分别表示二维和一维$Fourier$变换。因此，关于截距变量$\tau$的$Radon$变换的$Fourier$变换，等价于$u(x,t)$沿$k_x=p\omega$的二维$Fourier$变换。公式$4$又被称为$Projection-Slice-Theorem$(投影切片定理，中心切片定理)。</p>
<p>$Radon$逆变换有多种表现形式，例如：</p>
<script type="math/tex; mode=display">u(x, t)=-\frac{1}{2\pi^2} \iint dp d{\tau} \frac{\partial \check{u}(p,\tau-px)/\partial \tau}{\tau -t} \tag{5}</script><p>$Radon$变换函数$\check{u}(p,x)$也被称为慢度表示（$slowness representation$）、平面波分解（$plane-wave-decomposition$）或倾斜叠加（$slant-stack$）。倾斜叠加的描述更为清晰透彻：将波场中的值 沿“倾斜”的线进行叠加。$Radon$变换将时空域中一条斜率为$p_0$、截距为$\tau_0$的线转化为新域中的一个点$(p_0,\tau_0)$。即，Radon变换将一条线映射为一个点。$Radon$逆变换将新域中的点变为原来的线。</p>
<p>在$2D Fourier$变换中，其将一条时空域中的线转换为频率波数域中的一条线，其逆变换将$f-k$域中的线转换回$t-x$域。线$t=px+\tau$的$Fourier$变换为：</p>
<script type="math/tex; mode=display">\begin{align}
\notag
\int_{-\infty}^{\infty} \int_{-\infty}^{\infty} dx dt {\rm{exp}} [i(\omega t-k_xx)] \delta(t-px-\tau) \\\\
\notag
=\int_{-\infty}^{\infty}dx {\rm{exp}} \lbrace i [\omega(px+\tau)-k_xx] \rbrace =2\pi {\rm {exp}} (i\omega \tau) \delta (p\omega -k_x) 
\end{align}\tag{6}</script><p>因此，$Fourier$变换的振幅由沿着以下公式的狄拉克函数给出：</p>
<script type="math/tex; mode=display">\omega =k_x/p \tag{7}</script><p>其相位为$\omega \tau$，且过原点（截距为0），$Fourier$变换有时空域中线的倒数斜率。另外，相位谱包含了截距$\tau$的信息。通过$Fourier$逆变换可得到原来的线：</p>
<script type="math/tex; mode=display">\frac{1}{2\pi^2} \int_{-\infty}^{\infty} \int_{-\infty}^{\infty} dk_xd{\omega} {\rm{exp}} [-i(\omega t-k_xx)] \times {\rm{exp}}(i\omega\tau) \delta(p\omega-k_x)=\delta(t-px-\tau)\tag{8}</script><p>地震学中常用的是包含非线性曲线（将公式1替换）的广义$Radon$变换($GRT$)。常用的 非线性曲线有抛物线($t=\tau+px^2$)、双曲线$t=\sqrt{(\tau^2+px^2)}$，$p$为双曲线的慢度或抛物线中慢度与位移的比值。</p>
<h2 id="关于快速离散Radon变换"><a href="#关于快速离散Radon变换" class="headerlink" title="关于快速离散Radon变换"></a>关于快速离散Radon变换</h2><p>我们简要讨论了$Radon$变换的连续形式，但在地震勘探领域的应用中，例如$\tau-p$域去除多次波<sup id="fnref:4"><a href="#fn:4" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="基于预测反褶积的多次波去除建立在多次波为周期性的基础上，但是，在时间—位移道集，例如共炮点道集、共中心点道集或者共检波点道集中，当偏移距非零时，时间剖面上的多次波通常不是周期性的。Taner(1980)首先认识到层状介质中的多次波沿径向轨迹是周期性的（固定$p$）。径向道之间的时间间隔不同。因此，可以从每个$p$道的自相关图中设计一个预测反褶积算子，并将其应用于$(\tau, p)$域衰减多次波，其中初至和多次波为椭圆。
">[4]</span></a></sup>等，我们需要一种快速、数字化的$Radon$变换来处理离散地震数据。Mersereau和Oppenheim(1974)<sup id="fnref:5"><a href="#fn:5" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Mersereau, R. M., and A. V. Oppenheim, 1974, Digital reconstruction of multidimensional signals from their projections: Proceedings of the IEEE, 62, 1319–1338.">[5]</span></a></sup>将非笛卡尔网格引入二维傅里叶变换中，其被称为同心网格视图（$concentric-squares grid$）。Averbuch等（个人交流，2003）提出了基于同心网格的离散$Radon$变换—伪极坐标网格，其计算效率更高且可通过$FFT$求逆。<br>在这里，我们利用同心网格或作者们所称的伪极坐标网格来将数据转换到二维傅里叶空间中。对于大多数地震数据处理领域的应用而言，将数据转换到同心网格的三角形子域足矣。所以，我们将这种数据转换方式称为三角傅里叶转换。<br>在我们考虑三角傅里叶变换之前，首先讨论投影切片（Radon变换基础的定理，公式$4$）的使用方法。投影切片定理认为$Radon$变换可通过以下方式获得：</p>
<ol>
<li>对时空域数据$(x,t)$做二维傅里叶变换</li>
<li>得到二维傅里叶变换的径向切片</li>
<li>对径向切片做一维傅里叶逆变换</li>
</ol>
<p>投影切片定理可用于离散数据，即分别将步骤1和3替换为笛卡尔网格中的二维和一维傅里叶变换。然而，由于傅立叶域的径向切片通常不与二维FFT输出的笛卡尔网格相交，我们需要在第二步中插值。<br>对于其中的插值，我们做更细致的解释。采样的时空域数据$u(nx\Delta x, nt\Delta t)$，其中$nx=1, 2, …, NX$以及$nt=0, 2, …, NT-1$, $\Delta x$和$\Delta t$分别为空间和时间采样间隔。二维傅里叶变换将时空域数据转换到相应的频率波数域。$Nyquist$频率和$Nyquist$波数分别为$\omega^{N}=\pi/\Delta t$和$k^{N}_x=\pi/\Delta x$。由于$u$为实数，因此我们只需考虑零频和正频率。最大不超过$Nyquist$的零频和正频率值为$n\omega =0, 2, …, NW$,($NW=NT/2$)。频率采样间隔为：</p>
<script type="math/tex; mode=display">\Delta \omega = 2\omega^{(N)}/NT \tag{9}</script><p>所有的正频率和负频率都需要考虑在内，$nkx=-NX/2+1,-NX/2+2,…,-,0，1,…,NX/2-1,NX/2$。波数$NKX$的数量等于空间采样点数$NX$。波数采样间隔为：</p>
<script type="math/tex; mode=display">\Delta k_x=2k^N_x/NX\tag{10}</script><p>采样二维傅里叶变换为$U(nkx\Delta k_x, n\omega \Delta \omega)$。为表述方便，我们将其简写为$U(nkx, n\omega)$，即不将数据的采样间隔显式表示。<br>时空域到频波域的二维傅里叶变换由两个运算构成，首先，对数据$u(nx,nt)$做时间$FFT$。得到：</p>
<script type="math/tex; mode=display">\tilde{U}(nx,n\omega) = \sum^{NT-1}_{nt=0}u(nx,nt) {\rm{exp}} (i \frac{2\pi n\omega nt}{NT}) \tag{11}</script><script type="math/tex; mode=display">n\omega=0,...,NT/2</script><p>其中$\tilde{U}(nx,n\omega)$为$u(nx,nt)$对于时间的傅里叶变换。然后，对$U(nx,n\omega)$做空间$FFT$，将空间转换为波数：</p>
<script type="math/tex; mode=display">U(nkx, n\omega)=\sum^{NX/2}_{nx=-NX/2+1} \tilde{U}(nx,n\omega) \times {\rm{exp}}(-i\frac{2\pi nkxnx}{NX})\tag{12}</script><script type="math/tex; mode=display">nkx=-NX/2+1,...,NX/2</script><p><img src="/2021/05/31/ITPS_Radon644~645/fig01.png" alt="fig01"><br>通常，我们将波数和正频率分别沿水平方向和垂直方向绘图。图1展示了$NT=32$、$NX=16$的$\omega-k_x$网格。这里，$NW=16,NKX=16$。<br>但是，图1所示网格并不适用于离散$Radon$变换。$Fourier$切片定理中，对截距变量$\tau$的$Radon$变换的$Fourier$变换，等价于$u(x,t)$沿$k_x=p\omega$的二维$Fourier$变换。在数值计算中，由于$u(nx,nt)$的二维$FFT$是定义在规则网格$\omega-k_x$上的，即其为频率-波数的函数，也就是说通常需要将$\omega-k_x$网格插值为线$k_x=p\omega$（对于不同$p$），来得到$U(nkx,n\omega)$。<br><img src="/2021/05/31/ITPS_Radon644~645/fig02.png" alt="fig02"><br>另外，利用伪极坐标或三角法，傅里叶变换解决了上述需要插值的问题。三角傅里叶变换（$T-FFT$）结合了传统对时间采样点的$FFT$和修正的对于空间采样点的$FFT$。在空间$FFT$（公式$12$）中，令</p>
<script type="math/tex; mode=display">nx \to 2nx n\omega /NT, n\omega =0,...,NT/2\tag{13}</script><p>输出非笛卡尔系的坐标数据（如图2所示），我们将这一伪极坐标网格的子集称为三角网格。Mersereau和Oppenheim(1974)<sup id="fnref:5"><a href="#fn:5" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Mersereau, R. M., and A. V. Oppenheim, 1974, Digital reconstruction of multidimensional signals from their projections: Proceedings of the IEEE, 62, 1319–1338.">[5]</span></a></sup>首先提出了此类网格，这种网格可以实现快速傅立叶计算。采用伪极坐标网格的具体思路，Averbuch提出了快速倾斜叠加（2003年）。<br>$T-FFT$沿着特定的线$k_x=p\omega$输出$Fourier$变换后的数据。采样线为$npx=-NPX/2+1,-NPX/2+2,…,-1,0,1,…,NPX/2-1,NPX/2$。线的数量$NPX$等于波数的数量$NKX$，同时也等于空间采样数$NX$。对于$f_x \geq 0$，</p>
<script type="math/tex; mode=display">p_0=0</script><script type="math/tex; mode=display">p_1=\Delta kx/\omega^{(N)}=\frac{1}{(NX/2)}  \frac{\Delta t}{\Delta x}</script><script type="math/tex; mode=display">p_npx=npx \Delta k_x/ \omega^{(N)}=\frac{1}{(NX/2)} \frac{\Delta t}{\Delta x}</script><script type="math/tex; mode=display">p_{NPX/2}=k^{(N)}_x/{\omega}^{(N)}</script><p>这些线在斜率上等距分布，距离间隔为慢度采样间隔：</p>
<script type="math/tex; mode=display">\Delta p=\frac{1}{(NX/2)} \frac{\Delta t}{\Delta x}</script><p><img src="/2021/05/31/ITPS_Radon644~645/fig03.png" alt="fig02"><br>但是它们有不同的长度（半径）。此外，如图3所示，频率波数域蓝色三角区域之外的信号信息在$T-FFT$变换后将不存在。所以，$T-FFT$对地震数据进行了隐式的速度滤波。例如，当$\Delta t=0.008 ms$、$\Delta x=12.5m$时，线$NPX/2$对应视速度$p^{-1}_{NPX/2}=1562.5 m/s$，任何低于视速度的信号都将被滤掉。<br>对每一个$p$道做一维逆傅里叶变换即可得到$Radon$变换后的数据。离散$Radon$变换是精确的、可逆的且能够快速计算的。这里我们详细阐述了如何对二维地震数据做$Radon$变换。同时能够将这一步骤直接推广到三维$Radon$变换的计算中，或者$\tau-p_x-p_y$变换，或者三维地震数据$u(nx,ny,nt)$($ny=1,…,NY$，$NY$为$crossline$方向的道数)中。在空间$FFT$中由坐标$y$转换为波数$k_y$，只需要作如下替换$ny \to 2ny n\omega /NT$。</p>
<p><details><summary>参考文献</summary></details></p>
<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">Chapman, C. H., 1978, A new method for computing seismograms: Geophysical Journal of the Royal Astronomical Society, 54, 481–518.<a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">Deans, S. R., 1993, The Radon transform and some of its applications: John Wiley &amp; Sons, Inc.<a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">Deans, S. R., 1996, Radon and Abel transforms, in A. D. Poularikas, ed., The transforms and applications handbook: CRC Press, 631–717.<a href="#fnref:3" rev="footnote"> ↩</a></span></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">基于预测反褶积的多次波去除建立在多次波为周期性的基础上，但是，在时间—位移道集，例如共炮点道集、共中心点道集或者共检波点道集中，当偏移距非零时，时间剖面上的多次波通常不是周期性的。Taner(1980)首先认识到层状介质中的多次波沿径向轨迹是周期性的（固定$p$）。径向道之间的时间间隔不同。因此，可以从每个$p$道的自相关图中设计一个预测反褶积算子，并将其应用于$(\tau, p)$域衰减多次波，其中初至和多次波为椭圆。<a href="#fnref:4" rev="footnote"> ↩</a></span></li><li id="fn:5"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">5.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">Mersereau, R. M., and A. V. Oppenheim, 1974, Digital reconstruction of multidimensional signals from their projections: Proceedings of the IEEE, 62, 1319–1338.<a href="#fnref:5" rev="footnote"> ↩</a></span></li></ol></div></div><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>地球物理数理知识</category>
      </categories>
      <tags>
        <tag>Radon</tag>
      </tags>
  </entry>
  <entry>
    <title>速度分析</title>
    <url>/2021/06/09/ITPS_pp500~503/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="估计背景速度的模型"><a href="#估计背景速度的模型" class="headerlink" title="估计背景速度的模型"></a>估计背景速度的模型</h1><p>翻译自SEG Introduction to petroleum Seismology(pp. 500~503)</p>
<h2 id="背景速度估计与成像之间的联系"><a href="#背景速度估计与成像之间的联系" class="headerlink" title="背景速度估计与成像之间的联系"></a>背景速度估计与成像之间的联系</h2><p>前面章节中描述的成像算法，其成功与否取决与背景速度模型的准确性。换句话说，我们只有知道一部分地下模型，才能重构出“整个”模型，这又被称为地震成像悖论。正如本章第一节所描述的，这一悖论是由于我们当前使用的成像技术中显式或隐式地使用了Born近似所致。</p>
<p>幸运的是，如果地质构造不太复杂的话，能够用于成像的较为准确的速度模型，其也可以用来估计背景模型。如图11.46所示，其中只有一条反射同相轴，与同相轴相关的检波点的成像对于速度非常敏感。如前面章节所述，我们需要对由于偏移距所产生的旅行时差异(moveout)进行校正和叠加。如图11.47所示，对于一个包含三个同相轴的记录，正确的背景速度能够得到最大振幅动校正(maximun-amplitude-moveout correction)并将同相轴“拉平”。这一想法相当于“聚焦”地震道，以得到最大响应。当地震道正确排列时（即动校正完全时），地震道记录的总和将最大。这种想法类似于透镜或抛物面透镜对平面波的聚焦作用。<br><img src="/2021/06/09/ITPS_pp500~503/11.46.png" alt="11.46"><br>因此，重建背景速度的基本思想是使用各种速度模型对数据进行成像，并选择能够对地下构造聚焦的模型。估计背景速度模型的两个关键点，一是成像算法，二是确定最佳速度模型的准则。在例11.46和1.47中，为了简化问题，我们使用动校正和叠加进行成像，能够使叠加结果振幅最大的模型为正确模型。（对Box11.9不做介绍）<br><img src="/2021/06/09/ITPS_pp500~503/11.47.png" alt="11.47"><br>时间域成像和深度域成像是两种最常用的成像手段。时间域成像的背景速度是均方根速度，深度域成像的背景速度是实际速度(也称层速度)。实现$focus$和$defocus$的思想在时间域和深度域成像中有非常大的不同。时间域成像中违反了斯奈尔定律，所以聚焦和散焦可以应用于数据中的每个单独的同相轴，并且其独立于其它同相轴。我们可以通过在一系列均匀、非均匀速度模型上偏移来同时扫描所有同相轴，进而估计均方根速度。图11.47中，同时扫描了三个同相轴。</p>
<p>在深度域成像中，由于没有使用常速度模型作为背景速度，因此我们没有违反斯奈尔定律。所以，要想将某一深度上的同相轴还原到深度域其构造上，就必须知道该层以上的所有的准确速度。所以我们必须从地表开始逐层扫描，以获得实际的速度，或者我们可以扫描一系列不均匀速度模型来获得背景速度。后文中将详细介绍用于深度域成像的恢复层速度的方法。下面，我们从时间域成像开始介绍速度估计。</p>
<h2 id="速度谱"><a href="#速度谱" class="headerlink" title="速度谱"></a>速度谱</h2><p>11.47(b)中的曲线图即为<strong>速度谱</strong>。图中所示的量为对CMP道集动校正并叠加后的振幅。速度谱中另一个量是<code>Box 11.9</code>中定义的<code>semblance</code>。实际上，速度谱通常是基于<code>semblance</code>，如图11.48所示。我们可以看到，图11.48中<code>semblance</code>在反射波较强时更为突出。图11.48和11.49中的合成地震数据均通过有限差分计算得到。尽管图中只显示了纵波速度模型，但正演是基于弹性波的，这里我们主要考虑P-P反射。在图11.49中，这些强反射用红色表示。我们可以根据均方根速度通常随着时间或深度增加这一事实来对其进行选择。此外，由此选择的速度与理论计算的均方根速度(白色曲线)拟合较好。<br><img src="/2021/06/09/ITPS_pp500~503/11.48.png" alt="11.48"><br>需要注意的是，我们可以在<code>semblance</code>图红色区域选择不同的值，但是其中一些值代表多次波，它们并不会参与均方根速度的计算。均方根速度通常会随时间和深度增加使我们能够避免选择与多次波相关的红色峰值。<br><img src="/2021/06/09/ITPS_pp500~503/11.49.png" alt="11.49"><br>在<code>semblance</code>图上选择正确的速度是非常困难的。例如，11.49所示的炮集记录和速度谱对应于一个较为简单的模型，该模型包含一个高速玄武岩层，与图11.48不同的是，理论计算的均方根速度与<code>semblance</code>图3s位置选取的红色峰值处并不匹配。这种误差是非双曲的旅行时变化造成的，而我们的速度谱是基于动校正叠加计算的，也即暗含了时距曲线是双曲线这一假设(动校正量为双曲)。换句话说，这种误差是我们成像工具的局限性以及聚焦和散焦的局限性所致。在下一小节中，我们将讨论这种聚焦和散焦思想在复杂成像工具中的扩展。</p>
<p>图11.49中的<code>semblance</code>图也显示，与图11.48中的<code>semblance</code>图相比，强振幅同相轴到达时间更晚。显然，这些波明显不是初至，而是多次波和转换波。这一结果说明了区分玄武岩上方产生的多次波和真正的初至是非常困难的。</p>
<h1 id="偏移速度分析"><a href="#偏移速度分析" class="headerlink" title="偏移速度分析"></a>偏移速度分析</h1><p>如图11.48和11.49所示的均方根速度估计是基于动校正和叠加的。这种方法只有在检波器水平分布且时距曲线为双曲线时才有意义，当界面倾角较大时，速度模型的误差也会较大。<br>另一种方法是使用如公式11.202所示的叠前时间偏移算法来取代动校正和叠加。我们以$\Delta V$对$V_{min}$~$V_{max}$之间的速度进行常速偏移，在图11.50所示例子中，$V_{min}=2050 m/s$~$V_{max}=3350 m/s$，$\Delta V=50m/s$。偏移结果如图11.50所示(以 $200m/s$为间隔)。我们仍然可以十分清楚地看到同相轴能够聚焦，即使使用的速度模型偏离正确速度。例如，同相轴$A$和$B$在$2050m/s$的速度模型下偏移效果最好，而同相轴$C$在$3050m/s$的速度模型下偏移效果最好。这个例子证明了任何成像算法都能够用于速度估计。基于叠前时间偏移的速度估计方法被称为<strong>偏移速度分析</strong>。</p>
<p>通过拼接11.50中基于不同常速模型的偏移结果即可得到最终成像结果，这样一来,每一部分的成像剖面都有较为正确的速度。</p>
<h1 id="速度建模"><a href="#速度建模" class="headerlink" title="速度建模"></a>速度建模</h1><p>在进行深度域成像之前，必须要获得较为准确的深度模型，或者，同时获得深度成像结果和深度域成像模型。首先，速度模型被认为是一系列的速度函数，建立这些函数的过程被称为<strong>速度建模</strong>。</p>
<p>速度建模是一个不断迭代的过程，并且通常是一层一层来进行的，通过不断输入新的信息细化每次迭代的结果。正如所有的迭代处理过程，速度建模的第一个步骤是要获得<strong>初始速度模型</strong>。</p>
<h3 id="建立初始速度模型"><a href="#建立初始速度模型" class="headerlink" title="建立初始速度模型"></a>建立初始速度模型</h3><p>建立初始速度模型的两种常用方法为：均方根速度(时间域成像)或层速度。均方根速度是从CMP道集的<code>semblance</code>图中选取的，然后可利用<strong>Dix</strong>公式(Box 3.3)将其转换为层速度。初始速度模型即可以构建出初始模型。</p>
<p>正如我们在“反问题示例的关键假设”一节中所阐述的，我们需要对层速度模型进行平滑，以避免不平滑速度场中包含的突变界面层可能会产生的虚假构造。</p>
<h3 id="迭代过程"><a href="#迭代过程" class="headerlink" title="迭代过程"></a>迭代过程</h3><p>第一步是使用初始速度模型进行叠前深度偏移，然后进行<strong>剩余动校正分析</strong>。（剩余动校正分析，<strong>RMO</strong>，是在共反射点道集上计算得到的剩余时差量）。<strong>RMO</strong>分析之后，我们再次修正速度模型以使得<strong>RMO</strong>在<strong>CRP</strong>(Common-reflection-point)道集上最小。</p>
<p>有两种基本方法来获得最终的速度模型：<strong>层析方法</strong>和<strong>全局方法</strong>。<br><strong>层析方法</strong>从顶层开始，一次只处理一层，每层都会包含地球物理和地质约束。当顶层处理结束并且速度收敛到一个“真值”时，我们将该层“锁定”以使得其不再被修改，然后对下一层进行修正。重复以上步骤，直到所有层都被处理完毕。这种方法通常被用于复杂构造区，如图11.51所示。<br><strong>全局方法</strong>即同时对整个模型进行处理。每一层都有其地球物理和地质约束，但与层析方法不同的是，在每次迭代中都对整个模型进行修正，直到模型收敛到设定的极小值，如图11.52所示。<br><img src="/2021/06/09/ITPS_pp500~503/11.51_11.52.png" alt="11.51"></p>
<p>备注：其它图片请到原文中查看。<a href="ori.pdf">点击下载</a></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>地球物理数理知识</category>
      </categories>
      <tags>
        <tag>速度分析</tag>
      </tags>
  </entry>
  <entry>
    <title>如何在Python环境中使用Madagascrar函数</title>
    <url>/2021/06/04/Madagascrar_01/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="Madagascrar-python"><a href="#Madagascrar-python" class="headerlink" title="Madagascrar-python"></a>Madagascrar-python</h1><p>这里简单讲解如何在<code>python</code>中使用<code>Madagascrar</code>中的函数，读者需要自行安装好<code>swig</code>、<code>Madagascrar</code>、<code>python</code>、<code>numpy</code>等环境。</p>
<p>实际应用中有下列网址可供参考：<br>Madagascrar官方:<a href="https://reproducibility.org/wiki/Main_Page">https://reproducibility.org/wiki/Main_Page</a><br>Madagascrar模块介绍:<a href="https://reproducibility.org/RSF/">https://reproducibility.org/RSF/</a><br>SWIG官方:<a href="http://www.swig.org/tutorial.html">http://www.swig.org/tutorial.html</a></p>
<p>安装完<code>Madagascrar</code>之后，即可在<code>python</code>中调用<code>m8r module</code>来使用其中的各种函数，本文以源码下<code>/src/bei/ft1/autocor/SConstruct</code>为例简单讲述如何在<code>python</code>中调用<code>Madagascrar</code>中的函数。<code>autocor</code>源码主要展示了利用<code>spike</code>和<code>causint</code>函数来创建不同信号。我们经常需要在<code>python</code>脚本中实现各类数学变换以满足开发需求，通过<code>python</code>调用<code>Madagascrar</code>中相关函数的方式能够极大的简化我们的开发过程，提升开发效率。</p>
<p>首先，在<code>/src/bei/ft1/autocor</code>路径下打开<code>terminal</code>，执行<code>scons</code>命令，即可按照脚本<code>SConstruct</code>中命令的顺序获得所需要的文件，下面我们逐条语句解释<code>SConstruct</code>中出现的各种<code>Madagascrar</code>命令，并以纯<code>numpy</code>语句和<code>python</code>中<code>Madagascrar</code>语句(<code>m8r.command</code>)两种形式来实现相同功能。以下语句均在Linux环境下<code>Jupyter notebook</code>中完成。</p>
<h1 id="引入相关模块"><a href="#引入相关模块" class="headerlink" title="引入相关模块"></a>引入相关模块</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> m8r, os, math</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">n1 = <span class="number">128</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">integrate</span>(<span class="params">d</span>):</span><br><span class="line">    t = <span class="number">0</span></span><br><span class="line">    d_copy = np.zeros_like(d)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n1):</span><br><span class="line">        t += d[i]</span><br><span class="line">        d_copy[i] += t</span><br><span class="line">    <span class="keyword">return</span> d_copy</span><br></pre></td></tr></table></figure>
<h1 id="Spike"><a href="#Spike" class="headerlink" title="Spike"></a>Spike</h1><h2 id="SConstruct源码"><a href="#SConstruct源码" class="headerlink" title="SConstruct源码"></a><code>SConstruct</code>源码</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Flow(<span class="string">&#x27;spike&#x27;</span>,None,<span class="string">&#x27;spike n1=%d o1=0 d1=1 label1=&quot; &quot; &#x27;</span> % n1)</span><br></pre></td></tr></table></figure>
<p>该语句通过<code>spike</code>函数（可在<code>terminal</code>中输入<code>sfspike</code>查看该函数的功能及所需参数，当需要查看Flow中出现函数的<code>doc</code>时，需要在该命令前加前缀<code>sf</code>）创建了一个共<code>n1=128</code>个采样点、每个采样点的值均为<code>1</code>的一维信号，并将其生成的文件保存在<code>./spike.rsf</code>中。</p>
<p>在<code>python</code>中读取<code>rsf</code>文件，需要用到<code>m8r</code>中的<code>Input</code>函数：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">spike_file = m8r.Input(os.path.join(root_path, <span class="string">&#x27;spike.rsf&#x27;</span>))</span><br></pre></td></tr></table></figure><br>当需要读取该文件中的数据时，需要用的<code>read</code>方法：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">spike = spike_file.read()</span><br></pre></td></tr></table></figure><br>此时，<code>./spike.rsf</code>文件中的数据就已经被保存到了名为<code>spike</code>的<code>numpy</code>变量中。</p>
<h2 id="m8r方法"><a href="#m8r方法" class="headerlink" title="m8r方法"></a><code>m8r</code>方法</h2><p>使用如下语句即可在<code>python</code>中调用<code>Madagascrar</code>函数：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n1 = <span class="number">128</span></span><br><span class="line">spike_op = m8r.spike(n1=n1, o1=<span class="number">0</span>, d1=<span class="number">1</span>, label1=<span class="string">&quot; &quot;</span>)</span><br><span class="line">spike2 = np.zeros(n1)</span><br><span class="line">spike2 = spike_op.apply(spike2)</span><br></pre></td></tr></table></figure><br>首先，<code>m8r.spike(n1=n1, o1=0, d1=1, label1=&quot; &quot;)</code>创建了一个<code>operation</code>赋值给<code>spike_op</code>，表示需要进行的运算；同时我们创建一个元素均为0的一维数据<code>spike2</code>，其数据类型为<code>float64</code>，使用<code>spike_op</code>的<code>apply</code>方法即可即可将该运算的结果赋值给<code>spike2</code>，此时<code>spike2</code>的数据类型已经变为了<code>float32</code>。</p>
<h2 id="numpy方法"><a href="#numpy方法" class="headerlink" title="numpy方法"></a><code>numpy</code>方法</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n1 = <span class="number">128</span></span><br><span class="line">spike3 = np.ones(n1, dtype=np.float32)</span><br></pre></td></tr></table></figure>
<p>使用<code>plt.plot</code>对以上三种方法所得到的数据进行绘图，均可得到如下所示图件：<br><img src="/2021/06/04/Madagascrar_01/spike01.png" alt="spike01"></p>
<h1 id="Cos"><a href="#Cos" class="headerlink" title="Cos"></a>Cos</h1><p>该示例使用<code>math</code>函数生成了一个角频率为<code>(2*math.pi*6/n1)</code>的弦信号。</p>
<h2 id="SConstruct源码-1"><a href="#SConstruct源码-1" class="headerlink" title="SConstruct源码"></a><code>SConstruct</code>源码</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Flow(<span class="string">&#x27;cos&#x27;</span>,<span class="string">&#x27;spike&#x27;</span>,<span class="string">&#x27;math output=&quot;cos(%g*x1)&quot; &#x27;</span> % (2*math.pi*6/n1))</span><br></pre></td></tr></table></figure>
<p>读取源码所生成的数据：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cos_file = m8r.Input(os.path.join(root_path, <span class="string">&#x27;cos.rsf&#x27;</span>))</span><br><span class="line">cos = cos_file.read()</span><br></pre></td></tr></table></figure></p>
<h2 id="m8r方法-1"><a href="#m8r方法-1" class="headerlink" title="m8r方法"></a><code>m8r</code>方法</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cos_op = m8r.math(output=<span class="string">&quot;cos(%g*x1)&quot;</span>%((<span class="number">2</span>*np.pi*<span class="number">6</span>/n1)))</span><br><span class="line">cos2 = np.zeros(n1, dtype=np.float32)</span><br></pre></td></tr></table></figure>
<h2 id="numpy方法-1"><a href="#numpy方法-1" class="headerlink" title="numpy方法"></a><code>numpy</code>方法</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">w = <span class="number">2</span>*np.pi*<span class="number">6</span>/n1</span><br><span class="line">x = np.arange(<span class="number">0</span>, n1, <span class="number">1</span>, dtype=np.float32)</span><br><span class="line">cos3 = np.cos(w*(x)).astype(np.float32)</span><br></pre></td></tr></table></figure>
<p>使用<code>plt.plot</code>对以上三种方法所得到的数据进行绘图，均可得到如下所示图件：<br><img src="/2021/06/04/Madagascrar_01/cos.png" alt="cos"></p>
<h1 id="Sinc"><a href="#Sinc" class="headerlink" title="Sinc"></a>Sinc</h1><p>该示例通过<code>spike</code>函数生成了一个采样函数。</p>
<h2 id="SConstruct源码-2"><a href="#SConstruct源码-2" class="headerlink" title="SConstruct源码"></a><code>SConstruct</code>源码</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Flow(<span class="string">&#x27;sinc&#x27;</span>,<span class="string">&#x27;spike&#x27;</span>,</span><br><span class="line">     <span class="string">&#x27;math output=&quot;%g*(x1+%g)&quot; | math output=&quot;sin(input)/input&quot; &#x27;</span> %</span><br><span class="line">     (12*math.pi/n1,1-0.001-n1//2)</span><br></pre></td></tr></table></figure>
<p>读取数据：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sinc_file = m8r.Input(os.path.join(root_path, <span class="string">&#x27;sinc.rsf&#x27;</span>))</span><br><span class="line">sinc = sinc_file.read()</span><br></pre></td></tr></table></figure></p>
<h2 id="m8r方法-2"><a href="#m8r方法-2" class="headerlink" title="m8r方法"></a><code>m8r</code>方法</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sinc_op1 = m8r.math(output=<span class="string">&quot;%g*(x1+%g)&quot;</span>%((<span class="number">12</span>*np.pi/n1,<span class="number">1</span>-<span class="number">0.001</span>-n1//<span class="number">2</span>)))</span><br><span class="line">sinc_op2 = m8r.math(output=<span class="string">&quot;sin(input)/input&quot;</span>)</span><br><span class="line">sinc2 = np.zeros(n1)</span><br><span class="line">sinc2 = sinc_op2.apply(sinc_op1.apply(sinc2))</span><br></pre></td></tr></table></figure>
<h2 id="numpy方法-2"><a href="#numpy方法-2" class="headerlink" title="numpy方法"></a><code>numpy</code>方法</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = (<span class="number">12</span>*math.pi/n1)*(np.arange(<span class="number">0</span>, n1, <span class="number">1</span>)+<span class="number">1</span>-<span class="number">0.001</span>-n1//<span class="number">2</span>)</span><br><span class="line">sinc3 = np.sin(x)/x</span><br></pre></td></tr></table></figure>
<p>使用<code>plt.plot</code>对以上三种方法所得到的数据进行绘图，均可得到如下所示图件：<br><img src="/2021/06/04/Madagascrar_01/sinc.png" alt="sinc"></p>
<h1 id="Widebox"><a href="#Widebox" class="headerlink" title="Widebox"></a>Widebox</h1><p>该示例使用<code>spike</code>生成了一个有两个尖脉冲的信号，并使用<code>causint</code>对其积分得到门信号。</p>
<h2 id="SConstruct源码-3"><a href="#SConstruct源码-3" class="headerlink" title="SConstruct源码"></a><code>SConstruct</code>源码</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Flow(<span class="string">&#x27;widebox&#x27;</span>,None,</span><br><span class="line">     <span class="string">&#x27;spike n1=%d o1=0 d1=1 nsp=2 k1=%d,%d mag=1,-1 | causint&#x27;</span> %</span><br><span class="line">     (n1,n1//8+1,n1//8+3*n1//16))</span><br></pre></td></tr></table></figure>
<h2 id="m8r方法-3"><a href="#m8r方法-3" class="headerlink" title="m8r方法"></a><code>m8r</code>方法</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">widebox_op1 = m8r.spike(n1=n1, o1=<span class="number">0</span>, d1=<span class="number">1</span>, nsp=<span class="number">2</span>, k1=[n1//<span class="number">8</span>+<span class="number">1</span>,n1//<span class="number">8</span>+<span class="number">3</span>*n1//<span class="number">16</span>], mag=[<span class="number">1</span>,-<span class="number">1</span>])</span><br><span class="line"><span class="comment"># signal</span></span><br><span class="line">widebox2 = np.zeros(n1)</span><br><span class="line">widebox2 = widebox_op1.apply(widebox2)</span><br><span class="line"><span class="comment"># apply intergrate</span></span><br><span class="line">widebox_op2 = m8r.causint()</span><br><span class="line">widebox2 = widebox_op2.apply(widebox2)</span><br></pre></td></tr></table></figure>
<h2 id="numpy方法-3"><a href="#numpy方法-3" class="headerlink" title="numpy方法"></a><code>numpy</code>方法</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">widebox3 = np.zeros(n1)</span><br><span class="line">widebox3[n1//<span class="number">8</span>] = <span class="number">1</span></span><br><span class="line">widebox3[n1//<span class="number">8</span>+<span class="number">3</span>*n1//<span class="number">16</span>-<span class="number">1</span>] = -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">temp = np.zeros_like(widebox3)</span><br><span class="line"><span class="comment"># apply intergrate</span></span><br><span class="line">temp = integrate(widebox3)</span><br></pre></td></tr></table></figure>
<p>使用<code>plt.plot</code>对以上三种方法所得到的数据进行绘图，均可得到如下所示图件：</p>
<p>积分前：<br><img src="/2021/06/04/Madagascrar_01/widebox_a.png" alt="widebox_a"><br>积分后：<br><img src="/2021/06/04/Madagascrar_01/widebox_b.png" alt="widebox_b"></p>
<h1 id="Narrowbox"><a href="#Narrowbox" class="headerlink" title="Narrowbox"></a>Narrowbox</h1><p>与上类似。</p>
<h2 id="SConstruct源码-4"><a href="#SConstruct源码-4" class="headerlink" title="SConstruct源码"></a><code>SConstruct</code>源码</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Flow(<span class="string">&#x27;narrowbox&#x27;</span>,None,</span><br><span class="line">     <span class="string">&#x27;spike n1=%d o1=0 d1=1 nsp=2 k1=%d,%d mag=1,-1 | causint&#x27;</span> %</span><br><span class="line">     (n1,n1//8+1,n1//8+n1//16))</span><br></pre></td></tr></table></figure>
<h2 id="m8r方法-4"><a href="#m8r方法-4" class="headerlink" title="m8r方法"></a><code>m8r</code>方法</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">narrowbox_op1 = m8r.spike(n1=n1, o1=<span class="number">0</span>, d1=<span class="number">1</span>, nsp=<span class="number">2</span>, k1=[n1//<span class="number">8</span>+<span class="number">1</span>,n1//<span class="number">8</span>+n1//<span class="number">16</span>], mag=[<span class="number">1</span>,-<span class="number">1</span>])</span><br><span class="line">narrowbox2 = np.zeros(n1)</span><br><span class="line">narrowbox2 = narrowbox_op1.apply(narrowbox2)</span><br><span class="line"><span class="comment"># apply intergrate</span></span><br><span class="line">narrowbox_op2 = m8r.causint()</span><br><span class="line">narrowbox2 = widebox_op2.apply(narrowbox2)</span><br></pre></td></tr></table></figure>
<h2 id="numpy方法-4"><a href="#numpy方法-4" class="headerlink" title="numpy方法"></a><code>numpy</code>方法</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">narrowbox3 = np.zeros(n1)</span><br><span class="line">narrowbox3[n1//<span class="number">8</span>] = <span class="number">1</span></span><br><span class="line">narrowbox3[n1//<span class="number">8</span>+n1//<span class="number">16</span>-<span class="number">1</span>] = -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">temp = np.zeros_like(narrowbox3)</span><br><span class="line"><span class="comment"># apply intergrate</span></span><br><span class="line">temp = integrate(narrowbox3)</span><br></pre></td></tr></table></figure>
<p>使用<code>plt.plot</code>对以上三种方法所得到的数据进行绘图，均可得到如下所示图件：<br>积分前：<br><img src="/2021/06/04/Madagascrar_01/narrowbox_a.png" alt="narrowbox_a"><br>积分后：<br><img src="/2021/06/04/Madagascrar_01/narrowbox_b.png" alt="narrowbox_b"></p>
<h1 id="Twin"><a href="#Twin" class="headerlink" title="Twin"></a>Twin</h1><p>该示例生成了一个具有两个尖脉冲的信号。</p>
<h2 id="SConstruct源码-5"><a href="#SConstruct源码-5" class="headerlink" title="SConstruct源码"></a><code>SConstruct</code>源码</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Flow(<span class="string">&#x27;twin&#x27;</span>,None,</span><br><span class="line">     <span class="string">&#x27;spike n1=%d o1=0 d1=1 nsp=2 k1=1,%d&#x27;</span> % (n1,1+3*n1//16))</span><br></pre></td></tr></table></figure>
<h2 id="m8r方法-5"><a href="#m8r方法-5" class="headerlink" title="m8r方法"></a><code>m8r</code>方法</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">twin_op = m8r.spike(n1=n1, o1=<span class="number">0</span>, d1=<span class="number">1</span>, nsp=<span class="number">2</span>, k1=[<span class="number">1</span>,<span class="number">1</span>+<span class="number">3</span>*n1//<span class="number">16</span>])</span><br><span class="line">twin = np.zeros(n1)</span><br><span class="line">twin = twin_op.apply(twin)</span><br></pre></td></tr></table></figure>
<h2 id="numpy方法-5"><a href="#numpy方法-5" class="headerlink" title="numpy方法"></a><code>numpy</code>方法</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">twin2 = np.zeros(n1)</span><br><span class="line">twin2[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">twin2[<span class="number">3</span>*n1//<span class="number">16</span>] = <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>使用<code>plt.plot</code>对以上三种方法所得到的数据进行绘图，均可得到如下所示图件：<br><img src="/2021/06/04/Madagascrar_01/twin.png" alt="twin"></p>
<h1 id="Double"><a href="#Double" class="headerlink" title="Double"></a>Double</h1><p>该示例使用<code>spike</code>生成了一个具有四个尖脉冲的信号，并使用<code>causint</code>对其进行积分。</p>
<h2 id="SConstruct源码-6"><a href="#SConstruct源码-6" class="headerlink" title="SConstruct源码"></a><code>SConstruct</code>源码</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Flow(<span class="string">&#x27;doublebox&#x27;</span>,None,</span><br><span class="line">     <span class="string">&#x27;spike n1=%d o1=0 d1=1 nsp=4 k1=1,%d,%d,%d mag=1,-1,1,-1 | causint&#x27;</span> %</span><br><span class="line">     (n1,n1//16,1+3*n1//16,n1//16+3*n1//16))</span><br></pre></td></tr></table></figure>
<h2 id="m8r方法-6"><a href="#m8r方法-6" class="headerlink" title="m8r方法"></a><code>m8r</code>方法</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">double_op1 = m8r.spike(n1=n1, o1=<span class="number">0</span>, d1=<span class="number">1</span>, nsp=<span class="number">4</span>, k1=[<span class="number">1</span>, n1//<span class="number">16</span>,<span class="number">1</span>+<span class="number">3</span>*n1//<span class="number">16</span>,n1//<span class="number">16</span>+<span class="number">3</span>*n1//<span class="number">16</span>],</span><br><span class="line">                       mag=[<span class="number">1</span>,-<span class="number">1</span>,<span class="number">1</span>,-<span class="number">1</span>])</span><br><span class="line">double_op2 = m8r.causint()</span><br><span class="line">double2 = np.zeros(n1)</span><br><span class="line">double2 = double_op1.apply(double2)</span><br></pre></td></tr></table></figure>
<h2 id="numpy方法-6"><a href="#numpy方法-6" class="headerlink" title="numpy方法"></a><code>numpy</code>方法</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">doublebox2 = np.zeros(n1)</span><br><span class="line"><span class="keyword">for</span> idx, value <span class="keyword">in</span> <span class="built_in">zip</span>([<span class="number">0</span>,n1//<span class="number">16</span>-<span class="number">1</span>,<span class="number">3</span>*n1//<span class="number">16</span>,n1//<span class="number">16</span>+<span class="number">3</span>*n1//<span class="number">16</span>-<span class="number">1</span>], [<span class="number">1</span>,-<span class="number">1</span>,<span class="number">1</span>,-<span class="number">1</span>]):</span><br><span class="line">    doublebox2[idx] = value</span><br><span class="line">doublebox2 =  integrate(doublebox2)</span><br></pre></td></tr></table></figure>
<p>使用<code>plt.plot</code>对以上三种方法所得到的数据进行绘图，均可得到如下所示图件：<br>积分前：<br><img src="/2021/06/04/Madagascrar_01/double_a.png" alt="double_a"><br>积分后：<br><img src="/2021/06/04/Madagascrar_01/double_b.png" alt="double_b"></p>
<h1 id="Combs"><a href="#Combs" class="headerlink" title="Combs"></a>Combs</h1><h2 id="SConstruct源码-7"><a href="#SConstruct源码-7" class="headerlink" title="SConstruct源码"></a><code>SConstruct</code>源码</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">combs = [</span><br><span class="line">    range(1,1+n1//2,4),</span><br><span class="line">    range(1,1+n1//4,4),</span><br><span class="line">    range(1,1+n1//2,8),</span><br><span class="line">    range(1,1+n1//4,8),</span><br><span class="line">    range(1,1+n1,32)</span><br><span class="line">    ]</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">case</span> <span class="keyword">in</span> range(len(combs)):</span><br><span class="line">    comb = combs[<span class="keyword">case</span>]</span><br><span class="line">    name = <span class="string">&#x27;comb%d&#x27;</span> % <span class="keyword">case</span></span><br><span class="line">    Flow(name,None,</span><br><span class="line">         <span class="string">&#x27;spike n1=%d o1=0 d1=1 nsp=%d k1=%s&#x27;</span> %</span><br><span class="line">         (n1,len(comb),<span class="string">&#x27;,&#x27;</span>.<span class="built_in">join</span>(map(str,comb))))</span><br><span class="line">    signals.append(name)</span><br><span class="line">    labels = labels + <span class="string">&#x27;:cmb%d&#x27;</span> % (<span class="keyword">case</span>+1)</span><br></pre></td></tr></table></figure>
<h2 id="m8r方法-7"><a href="#m8r方法-7" class="headerlink" title="m8r方法"></a><code>m8r</code>方法</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">comb_idx = <span class="number">4</span> <span class="comment">#\in [0,4)</span></span><br><span class="line"><span class="keyword">assert</span> comb_idx&lt;=<span class="number">4</span>, <span class="string">&#x27;comb_idx must &lt;= 4!&#x27;</span></span><br><span class="line">k_list = [<span class="built_in">int</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">map</span>(<span class="built_in">str</span>,combs[comb_idx])]</span><br><span class="line">comb0_op = m8r.spike(n1=n1, o1=<span class="number">0</span>, d1=<span class="number">1</span>, nsp=<span class="built_in">len</span>(combs[comb_idx]), k1=k_list)</span><br><span class="line">comb0_2 = np.zeros(n1)</span><br></pre></td></tr></table></figure>
<h2 id="numpy方法-7"><a href="#numpy方法-7" class="headerlink" title="numpy方法"></a><code>numpy</code>方法</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">comb_idx = <span class="number">4</span> <span class="comment">#\in [0,4)</span></span><br><span class="line"><span class="keyword">assert</span> comb_idx&lt;=<span class="number">4</span>, <span class="string">&#x27;comb_idx must &lt;= 4!&#x27;</span></span><br><span class="line">k_list = [<span class="built_in">int</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">map</span>(<span class="built_in">str</span>,combs[comb_idx])]</span><br><span class="line">comb0_3 = np.zeros(n1)</span><br><span class="line">k_list2 = [i-<span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> k_list]</span><br><span class="line">comb0_3[k_list2]=<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>使用<code>plt.plot</code>对以上三种方法所得到的数据进行绘图，均可得到如下所示图件：<br><img src="/2021/06/04/Madagascrar_01/comb04.png" alt="comb04"></p>
<h1 id="Exponent"><a href="#Exponent" class="headerlink" title="Exponent"></a>Exponent</h1><p>该示例使用<code>math</code>生成了指数型信号。</p>
<h2 id="SConstruct源码-8"><a href="#SConstruct源码-8" class="headerlink" title="SConstruct源码"></a><code>SConstruct</code>源码</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Flow(<span class="string">&#x27;exponent&#x27;</span>,<span class="string">&#x27;spike&#x27;</span>,</span><br><span class="line">     <span class="string">&#x27;math output=&quot;exp(-%g*(2*x1-%d))&quot; &#x27;</span> % (8./n1,n1-2))</span><br></pre></td></tr></table></figure>
<h2 id="m8r方法-8"><a href="#m8r方法-8" class="headerlink" title="m8r方法"></a><code>m8r</code>方法</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">exponent2_op = m8r.math(output=<span class="string">&quot;exp(-%g*(2*x1-%d))&quot;</span>%(<span class="number">8.</span>/n1,n1-<span class="number">2</span>))</span><br><span class="line">exponent2 = np.zeros(n1)</span><br><span class="line">exponent2 = exponent2_op.apply(exponent2)</span><br></pre></td></tr></table></figure>
<h2 id="numpy方法-8"><a href="#numpy方法-8" class="headerlink" title="numpy方法"></a><code>numpy</code>方法</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = np.arange(<span class="number">0</span>, n1, <span class="number">1</span>)</span><br><span class="line">exponent3 = np.exp(-(<span class="number">8.</span>/n1)*(<span class="number">2</span>*x-(n1-<span class="number">2</span>)))</span><br></pre></td></tr></table></figure>
<p>使用<code>plt.plot</code>对以上三种方法所得到的数据进行绘图，均可得到如下所示图件：<br><img src="/2021/06/04/Madagascrar_01/exponent.png" alt="exponent"></p>
<h1 id="Gaussian"><a href="#Gaussian" class="headerlink" title="Gaussian"></a>Gaussian</h1><p>该示例使用<code>spike</code>和<code>math</code>生成<code>Gaussian</code>信号。</p>
<h2 id="SConstruct源码-9"><a href="#SConstruct源码-9" class="headerlink" title="SConstruct源码"></a><code>SConstruct</code>源码</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Flow(<span class="string">&#x27;gaussian&#x27;</span>,<span class="string">&#x27;spike&#x27;</span>,</span><br><span class="line">     <span class="string">&#x27;math output=&quot;%g*(2*x1-%d)&quot; | math output=&quot;exp(-input*input)&quot; &#x27;</span> %</span><br><span class="line">     (8./n1,n1-2))</span><br></pre></td></tr></table></figure>
<h2 id="m8r方法-9"><a href="#m8r方法-9" class="headerlink" title="m8r方法"></a><code>m8r</code>方法</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">gaussian_op1 = m8r.math(output=<span class="string">&quot;%g*(2*x1-%d)&quot;</span>%(<span class="number">8.</span>/n1,n1-<span class="number">2</span>))</span><br><span class="line">gaussian_op2 = m8r.math(output=<span class="string">&quot;exp(-input*input)&quot;</span>)</span><br><span class="line">gaussian2 = np.ones(n1)</span><br><span class="line">gaussian2 = gaussian_op2.apply(gaussian_op1.apply(gaussian2))</span><br></pre></td></tr></table></figure>
<h2 id="numpy方法-9"><a href="#numpy方法-9" class="headerlink" title="numpy方法"></a><code>numpy</code>方法</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = np.arange(<span class="number">0</span>, n1, <span class="number">1</span>)</span><br><span class="line">gaussian3 = np.zeros(n1)</span><br><span class="line">gaussian3 = <span class="number">8.</span>/n1*(<span class="number">2</span>*x-(n1-<span class="number">2</span>))</span><br><span class="line">gaussian3 = np.exp(-gaussian3*gaussian3)</span><br></pre></td></tr></table></figure>
<p>使用<code>plt.plot</code>对以上三种方法所得到的数据进行绘图，均可得到如下所示图件：<br><img src="/2021/06/04/Madagascrar_01/gaussian.png" alt="Gaussian"></p>
<h1 id="White"><a href="#White" class="headerlink" title="White"></a>White</h1><p>该示例使用<code>noise</code>生成白噪。</p>
<h2 id="SConstruct源码-10"><a href="#SConstruct源码-10" class="headerlink" title="SConstruct源码"></a><code>SConstruct</code>源码</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Flow(<span class="string">&#x27;white&#x27;</span>,<span class="string">&#x27;spike&#x27;</span>,<span class="string">&#x27;noise type=n seed=1990 | math output=&quot;2*(input-1)&quot; &#x27;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="m8r方法-10"><a href="#m8r方法-10" class="headerlink" title="m8r方法"></a><code>m8r</code>方法</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">white_op1 = m8r.noise(<span class="built_in">type</span>=<span class="literal">False</span>, seed = <span class="number">1990</span>)</span><br><span class="line">white_op2 = m8r.math(output=<span class="string">&quot;2*(input-1)&quot;</span>)</span><br><span class="line">white2 = np.ones(n1)</span><br><span class="line">white2 = white_op2.apply(white_op1.apply(white2))</span><br></pre></td></tr></table></figure>
<h2 id="numpy方法-10"><a href="#numpy方法-10" class="headerlink" title="numpy方法"></a><code>numpy</code>方法</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">white3 = np.random.random(n1)+<span class="number">0.5</span></span><br><span class="line">white3 = <span class="number">2</span>*(white3-<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>注：<code>m8r</code>与<code>numpy</code>种子设置方法不同，获取的随机数结果不同。</p>
<h1 id="colored"><a href="#colored" class="headerlink" title="colored"></a>colored</h1><p>该示例使用<code>smooth</code>对生成的白噪(<code>m8r</code>)信号进行平滑。</p>
<h2 id="SConstruct源码-11"><a href="#SConstruct源码-11" class="headerlink" title="SConstruct源码"></a><code>SConstruct</code>源码</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Flow(<span class="string">&#x27;colored&#x27;</span>, <span class="string">&#x27;white&#x27;</span>, <span class="string">&#x27;smooth rect1=3&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="m8r方法-11"><a href="#m8r方法-11" class="headerlink" title="m8r方法"></a><code>m8r</code>方法</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">colored_op = m8r.smooth(rect1=<span class="number">3</span>)</span><br><span class="line">colored = np.zeros(n1)</span><br><span class="line">colored_op = colored_op.apply(white2)</span><br></pre></td></tr></table></figure>
<h2 id="numpy方法-11"><a href="#numpy方法-11" class="headerlink" title="numpy方法"></a><code>numpy</code>方法</h2><p>未阅读其中的平滑函数。<br>使用<code>plt.plot</code>对所得到的数据进行绘图，均可得到如下所示图件：<br>平滑前：<br><img src="/2021/06/04/Madagascrar_01/smbefore.png" alt="smBefore"><br>平滑后：<br><img src="/2021/06/04/Madagascrar_01/smafter.png" alt="smAfter"></p>
<h3 id="其它函数的使用，举一反三即可（在terminal中查找函数的参数，然后使用m8r-command的方式来调用）。"><a href="#其它函数的使用，举一反三即可（在terminal中查找函数的参数，然后使用m8r-command的方式来调用）。" class="headerlink" title="其它函数的使用，举一反三即可（在terminal中查找函数的参数，然后使用m8r.command的方式来调用）。"></a>其它函数的使用，举一反三即可（在terminal中查找函数的参数，然后使用m8r.command的方式来调用）。</h3><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Madagascrar</category>
      </categories>
      <tags>
        <tag>编程开发</tag>
      </tags>
  </entry>
  <entry>
    <title>Madagascrar之线性Radon变换</title>
    <url>/2021/06/06/Madagascrar_radon01/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="Madagascrar之线性Radon变换"><a href="#Madagascrar之线性Radon变换" class="headerlink" title="Madagascrar之线性Radon变换"></a>Madagascrar之线性Radon变换</h1><p>本文简要介绍如何在<code>python</code>中使用<code>Madagascrar</code>中的<code>Radon</code>变换模块。<br>命令行中输入<code>sfradon</code>可以查看<code>Radon</code>变换的相关参数，如下所示<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">NAME</span><br><span class="line">        sfradon</span><br><span class="line">DESCRIPTION</span><br><span class="line">        High-resolution Radon transform. </span><br><span class="line">SYNOPSIS</span><br><span class="line">        sfradon &lt; in.rsf &gt; out.rsf offset=offset.rsf adj=y inv=adj spk=inv verb=n np= dp= p0= nx= eps=1. ns=1 tol=1.e-6 perc=50.0 fact=0.5 ox= dx= parab=n x0=</span><br><span class="line">1. niter=100</span><br><span class="line">PARAMETERS</span><br><span class="line">        bool    adj=y [y/n]     <span class="keyword">if</span> y, perform adjoint operation </span><br><span class="line">        <span class="built_in">float</span>   dp=     p sampling (<span class="keyword">if</span> adj=y) </span><br><span class="line">        <span class="built_in">float</span>   dx=     </span><br><span class="line">        <span class="built_in">float</span>   eps=1.  </span><br><span class="line">        <span class="built_in">float</span>   fact=0.5        percentage <span class="keyword">for</span> sharpening </span><br><span class="line">        bool    inv=adj [y/n]   <span class="keyword">if</span> y, perform inverse operation </span><br><span class="line">        int     niter=100       </span><br><span class="line">        int     np=     number of p values (<span class="keyword">if</span> adj=y) </span><br><span class="line">        int     ns=1    number of sharpening cycles </span><br><span class="line">        int     nx=     number of offsets (<span class="keyword">if</span> adj=n) </span><br><span class="line">        string  offset=         auxiliary input file name</span><br><span class="line">        <span class="built_in">float</span>   ox=     </span><br><span class="line">        <span class="built_in">float</span>   p0=     p origin (<span class="keyword">if</span> adj=y) </span><br><span class="line">        bool    parab=n [y/n]   <span class="keyword">if</span> y, parabolic Radon transform </span><br><span class="line">        <span class="built_in">float</span>   perc=50.0       percentage <span class="keyword">for</span> sharpening </span><br><span class="line">        bool    spk=inv [y/n]   <span class="keyword">if</span> y, use spiking (hi-res) inversion </span><br><span class="line">        <span class="built_in">float</span>   tol=1.e-6       inversion tolerance </span><br><span class="line">        bool    verb=n [y/n]    verbosity flag </span><br><span class="line">        <span class="built_in">float</span>   x0=1.   reference offset</span><br><span class="line">USED IN</span><br><span class="line">        cwp/geo2006TimeShiftImagingCondition/flat</span><br><span class="line">        geo384s/hw5/pradon</span><br><span class="line">        geo384s/hw5/radon</span><br><span class="line">        milano/taupvel/cmp</span><br><span class="line">        rsf/school2012/demo</span><br><span class="line">        rsf/su/rsflab16</span><br><span class="line">        rsf/su/rsftaup</span><br><span class="line">        xjtu/test/myradon2</span><br><span class="line">SOURCE</span><br><span class="line">        system/seismic/Mradon.</span><br></pre></td></tr></table></figure><br>下面我们通过一个简单的实例来了解一下，如何使用线性<code>Radon</code>的正反变换。</p>
<p>首先，我们使用<code>numpy</code>生成一个包含两条水平直线、大小为(256, 256)的二维数组，两条直线分别位于网格深度64和192处。数据生成代码和图片如下所示：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nx = 256</span><br><span class="line">nz = 256</span><br><span class="line">image = np.zeros((nx, nz), dtype = np.float32)</span><br><span class="line">image[64,:]=1</span><br><span class="line">image[192,:]=1</span><br></pre></td></tr></table></figure><br><img src="/2021/06/06/Madagascrar_radon01/ori.png" alt="img01"><br>接下来，使用<code>m8r</code>模块中的<code>radon</code>分别创建拉冬正变化和反变换的算子<code>radon_op</code>和<code>iradon_op</code>，其中我们必须要通过<code>put</code>方法来输入数据的网格间距<code>d1</code>、<code>d2</code>和起始位置<code>o2</code>信息，以及拉冬变换所需要的相关参数信息，比如变换后的采样数<code>np</code>（决定了变换后数据的网格大小）、<code>p</code>起始位置<code>p0</code>以及采样间隔<code>dp</code>，是否使用高精度变换<code>spk</code>等。</p>
<p>这里，我们将原始数据横向和纵向采样间隔均设置为1，并令$NP=55$，$dp=2*pmax/(NP-1)$。需要注意的是，在反变换中，我们需要将<code>d2</code>设置为正变换中的<code>dp</code>，即将数据第二个维度采样间隔设置为正变换中<code>p</code>的采样间隔，并将第二个维度的起始位置<code>o2</code>设置为正变换中<code>p0</code>(即此例中的<code>-pmax</code>)；然后设置<code>radon</code>变换中的<code>nx</code>为原数据第一个维度大小即可得到与原数据大小相同的二维数据。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d1 = <span class="number">1</span></span><br><span class="line">d2 = <span class="number">1</span></span><br><span class="line">o2 = <span class="number">0</span></span><br><span class="line">pmax=<span class="number">1</span></span><br><span class="line">NP=<span class="number">55</span></span><br><span class="line">dp=<span class="number">2</span>*pmax/(NP-<span class="number">1</span>)</span><br><span class="line">radon_op = m8r.put(d1 = d1, d2 = d2, o2 = o2).radon(np=NP, p0=-pmax, dp=dp, spk=<span class="literal">False</span>)</span><br><span class="line">iradon_op = m8r.put(d1 = d1, d2 = dp, o2 = -pmax).radon(adj=<span class="literal">False</span>,</span><br><span class="line">                                                        nx=image.shape[<span class="number">0</span>],</span><br><span class="line">                                                        dx=d2, ox=<span class="number">0</span>, </span><br><span class="line">                                                        spk=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><br>分别将正、反变换算子应用于原始数据和变换后的数据，即可相应地得到拉冬域数据和原始数据。但需要注意的是，由于<code>python</code>和<code>C</code>中行列优先级的不同，我们需要将<code>numpy</code>数组转置后再输入到算子中才可得到正确的正变换结果，相应的，反变换的结果转置后才为真正的原始数据排列方式。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 正变换</span></span><br><span class="line">radon_m8r = radon_op.apply(image.T)</span><br><span class="line"><span class="comment"># 反变换</span></span><br><span class="line">idata_m8r = iradon_op.apply(radon_m8r)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘图</span></span><br><span class="line">dx, dy = <span class="number">0.5</span> * <span class="number">180.0</span> / <span class="built_in">max</span>(image.shape), <span class="number">0.5</span> / radon_m8r.shape[<span class="number">0</span>]</span><br><span class="line">fig, ax = plt.subplots(<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">ax.imshow(radon_m8r.T, </span><br><span class="line">          extent = (-dx, <span class="number">180.0</span> + dx, -dy, radon_m8r.shape[<span class="number">0</span>] + dy),</span><br><span class="line">          cmap = plt.cm.Greys, aspect =<span class="string">&#x27;auto&#x27;</span>)</span><br><span class="line">ax.set_xlabel(<span class="string">&quot;Projection angle (deg)&quot;</span>)</span><br><span class="line">ax.set_ylabel(<span class="string">&quot;Projection position (pixels)&quot;</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line">plt.imshow(image, cmap=plt.cm.Greys)</span><br><span class="line">plt.show()</span><br><span class="line">plt.imshow(idata_m8r.T, cmap=plt.cm.Greys)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><br>正变换结果：<br><img src="/2021/06/06/Madagascrar_radon01/forward.png" alt="正变换"><br>反变换结果：<br><img src="/2021/06/06/Madagascrar_radon01/backward.png" alt="正变换"></p>
<h3 id="实际上，m8r-radon函数也可完成抛物线拉冬变换，只需设置参数parab-True即可。"><a href="#实际上，m8r-radon函数也可完成抛物线拉冬变换，只需设置参数parab-True即可。" class="headerlink" title="实际上，m8r.radon函数也可完成抛物线拉冬变换，只需设置参数parab=True即可。"></a>实际上，<code>m8r.radon</code>函数也可完成抛物线拉冬变换，只需设置参数<code>parab=True</code>即可。</h3><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Madagascrar</category>
      </categories>
      <tags>
        <tag>编程开发</tag>
      </tags>
  </entry>
  <entry>
    <title>Madagascrar之rsf/su/rsflab16</title>
    <url>/2021/06/14/Madagascrar_rsf.su.rsflab16/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>本文介绍的是Madagascrar源码book中的rsf/su/rsflab16示例程序，该源码程序主要介绍的是如何使用Madagascrar对地震数据进行动校正(sfnmo)、taup变换(sfradon)、速度分析(sfvscan)、去动校正(sfinmo)等。<br>如何在python中读取RSF文件/输出<code>numpy</code>数据到RSF文件，请参考<a href="http://blog.geophyai.com/2021/06/09/Madagascrar_rsfIO/" title="RSF文件IO">《Madagascrar之RSF文件输入与输出》</a>一文。</p>
<h1 id="动校正-NMO"><a href="#动校正-NMO" class="headerlink" title="动校正(NMO)"></a>动校正(NMO)</h1><p><code>rsf/su/rsflab16/SConstruct</code>中有两处使用了<code>nmo</code>命令，第一处为动校正、第二处为去动校正。</p>
<p>动校正命令如下：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Flow(<span class="string">&#x27;nmo&#x27;</span>,<span class="string">&#x27;cdp265 offset265 vel&#x27;</span>,</span><br><span class="line">     <span class="string">&#x27;nmo half=n offset=$&#123;SOURCES[1]&#125; velocity=$&#123;SOURCES[2]&#125;&#x27;</span>)</span><br></pre></td></tr></table></figure><br>通过以上<code>Flow</code>命令可以看出，<code>Madagascrar</code>中的动校正模块<code>sfnmo</code>需要有三个输入文件，也就是说，如果我们想要在<code>Python</code>中使用<code>m8r.nmo</code>，除了<code>numpy</code>格式的输入数据外，还需额外输入偏移距数据<code>offset</code>以及速度数据<code>velocity</code>。<a href="http://blog.geophyai.com/2021/06/09/Madagascrar_rsfIO/" title="RSF文件IO">《Madagascrar之RSF文件输入与输出》</a>中我们提到，由于无法直接将<code>numpy</code>数据作为参数输入到<code>m8r.command</code>中，我们只能先将数据以规定的<code>RSF</code>文件格式输入到磁盘中，然后再将文件路径作为参数传入函数中。即<code>m8r.nmo(offset=np.array(offset), velocity=np.array(offset))</code>是不可行的，<code>m8r.nmo(half=False, offset=&#39;./offset.rsf&#39;, velocity=&#39;./vel.rsf&#39;.apply(np.array(cdp))</code>才能得到正确结果。</p>
<p>为方便起见，我们仍旧使用之前封装的<code>warpper</code>函数来读取<code>rsf</code>文件，代码如下所示：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">nmo_op = m8r.put(d1=<span class="number">0.004</span>,</span><br><span class="line">				 o1=<span class="number">0</span>).nmo(half=<span class="literal">False</span>, </span><br><span class="line">                       	   offset=warp.offset265.__file_path__, </span><br><span class="line">                           velocity=warp.vel.__file_path__)</span><br><span class="line">nmo = nmo_op.apply(warp.cdp265.data)</span><br><span class="line">warp.__set_attr_by_name__(<span class="string">&#x27;nmo&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.<span class="built_in">all</span>(nmo==warp.nmo.data))</span><br></pre></td></tr></table></figure><br>上面的代码中，我们首先定义了一个动校正算子<code>nmo_op</code>，然后我们将需要的参数(时间采样间隔<code>d1</code>，起始时间<code>o1</code>)输入到<code>put</code>中，将<code>nmo</code>需要的参数输入到其函数中(<code>offset</code>和<code>velocity</code>的参数分别为使用<code>warp.__set_attr_by_name__(&#39;offset265&#39;)</code>和<code>warp.__set_attr_by_name__(&#39;vel&#39;)</code>读取的<code>RSF</code>文件路径，这些文件均可以通过执行<code>scons</code>命令来生成)。通过查看最后输出是否为<code>True</code>来判断所生成动校正数据与源码最终结果的异同。另外，这里动校正的速度为<code>1500m/s</code>。<br><img src="/2021/06/14/Madagascrar_rsf.su.rsflab16/cdp265+nmo.png" alt="去动校正"><br>去动校正命令如下：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Flow(<span class="string">&#x27;sign&#x27;</span>,<span class="string">&#x27;sign2 vel&#x27;</span>,<span class="string">&#x27;inmo half=n velocity=$&#123;SOURCES[1]&#125;&#x27;</span>)</span><br></pre></td></tr></table></figure><br>使用方法与动校正相似，定义算子的时候需要将速度文件的路径作为参数传入，这里不做赘述。<br><img src="/2021/06/14/Madagascrar_rsf.su.rsflab16/sign+inmo.png" alt="去动校正"></p>
<h1 id="抛物线taup变换"><a href="#抛物线taup变换" class="headerlink" title="抛物线taup变换"></a>抛物线taup变换</h1><p><code>Radon</code>变换示例可参考<a href="http://blog.geophyai.com/2021/06/06/Madagascrar_radon01/">《Madagascrar之线性Radon变换》</a>。在<code>sfradon</code>中，由常规拉东变换到抛物线拉东变换，我们只需要将参数<code>parab</code>设置为<code>y</code>（默认为<code>n</code>，在<code>python</code>中则需要设置为<code>True</code>）即可。<br><code>SConstruct</code>源码为：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Flow(<span class="string">&#x27;taup&#x27;</span>,<span class="string">&#x27;nmo offset265 &#x27;</span>,</span><br><span class="line">     <span class="string">&#x27;radon parab=y x0=1000 np=251 dp=0.002 p0=-0.25 offset=$&#123;SOURCES[1]&#125;&#x27;</span>)</span><br></pre></td></tr></table></figure><br>对应的<code>Python</code>版实现为：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">taup_op = m8r.put(d1=<span class="number">0.004</span>).radon(parab=<span class="literal">True</span>,</span><br><span class="line">								  x0=<span class="number">1000</span>,</span><br><span class="line">								  np=<span class="number">251</span>,</span><br><span class="line"> 							      dp=<span class="number">0.002</span>,</span><br><span class="line">								  p0=-<span class="number">0.25</span>,</span><br><span class="line">								  offset=warp.offset265.__file_path___)</span><br><span class="line">taup = taup_op.apply(warp.nmo.data)</span><br></pre></td></tr></table></figure><br>同样的，<code>warp.nmo.data</code>为通过<code>warp.__set_attr_by_name__(&#39;nmo&#39;)</code>读取的<code>nmo.rsf</code>文件中的数据。<br><img src="/2021/06/14/Madagascrar_rsf.su.rsflab16/taup.png" alt="taup变换"><br>这里展示的图片为对原始炮集(即上面的动校正前数据)进行$taup$变换后的结果。</p>
<h1 id="速度分析"><a href="#速度分析" class="headerlink" title="速度分析"></a>速度分析</h1><p>速度分析也需要额外输出偏移距的<code>RSF</code>文件作为参数，所以我们要将偏移距数据按照格式写入文件。<br>脚本命令为：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Velocity analysis</span></span><br><span class="line">Flow(<span class="string">&#x27;scan&#x27;</span>,<span class="string">&#x27;cdp265 offset265&#x27;</span>,</span><br><span class="line">     <span class="string">&#x27;vscan semblance=y half=n offset=$&#123;SOURCES[1]&#125; dv=15 v0=1450 nv=200&#x27;</span>)</span><br><span class="line">Flow(<span class="string">&#x27;scan2&#x27;</span>,<span class="string">&#x27;sign&#x27;</span>,</span><br><span class="line">     <span class="string">&#x27;vscan semblance=y half=n dv=15 v0=1450 nv=200&#x27;</span>)</span><br></pre></td></tr></table></figure><br>对应的<code>Python</code>版实现为：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">vscan_op = m8r.put(o1=<span class="built_in">float</span>(o1), </span><br><span class="line">                   d1=<span class="built_in">float</span>(d1)).vscan(semblance=<span class="literal">True</span>,</span><br><span class="line">		                               half=<span class="literal">False</span>,</span><br><span class="line">		                               offset=<span class="string">&#x27;./offset265_.rsf&#x27;</span>, </span><br><span class="line">		                               dv=<span class="number">15</span>, </span><br><span class="line">		                               v0=<span class="number">1450</span>, </span><br><span class="line">		                               nv=<span class="number">200</span>)</span><br><span class="line">vscan = vscan_op.apply(warp.cdp265.data)</span><br><span class="line">vscan2 = vscan_op.apply(warp.sign.data)</span><br></pre></td></tr></table></figure><br><img src="/2021/06/14/Madagascrar_rsf.su.rsflab16/scan.png" alt="taup变换"></p>
<p>上图中，横轴表示速度(m/s)，纵轴表示为时间(s)。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Madagascrar</category>
      </categories>
      <tags>
        <tag>编程开发</tag>
      </tags>
  </entry>
  <entry>
    <title>Madagascrar之RSF文件输入与输出</title>
    <url>/2021/06/09/Madagascrar_rsfIO/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="Madagascrar中RSF文件读取与写入"><a href="#Madagascrar中RSF文件读取与写入" class="headerlink" title="Madagascrar中RSF文件读取与写入"></a>Madagascrar中RSF文件读取与写入</h1><p>本文主要介绍如何在<code>Python</code>脚本中读取由执行<code>scons</code>命令所生成的<code>Madagascrar</code>的<code>.rsf</code>文件，以及如何将<code>numpy</code>数据以及相关参数写入<code>.rsf</code>文件。</p>
<h1 id="在Python中读取RSF文件"><a href="#在Python中读取RSF文件" class="headerlink" title="在Python中读取RSF文件"></a>在Python中读取RSF文件</h1><p>这里我们将RSF文件读取封装在一个简单的函数中，该函数使用了<code>m8r</code>中的<code>Input</code>模块来完成对数据和参数的读取，我们只需要将文件名输入到该函数中，即可获得与文件名同名的方法，并可分别通过<code>name.data</code>和<code>name.pars</code>来访问<code>name.rsf</code>中的数据和参数。<br>函数原型：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">m8r_read</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, file_path</span>):</span><br><span class="line">        self.__file_path__ = file_path</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__read__</span>(<span class="params">self, </span>):</span><br><span class="line">        self.Input = m8r.Input(self.__file_path__)</span><br><span class="line">        self.pars = self.Input.file.pars</span><br><span class="line">        self.data = self.Input.read()</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__plot__</span>(<span class="params">self, cmap = plt.cm.gray</span>):</span><br><span class="line">        <span class="keyword">assert</span> self.data.ndim&gt;<span class="number">1</span></span><br><span class="line">        plt.figure()</span><br><span class="line">        vmin, vmax = np.percentile(self.data, [<span class="number">2</span>, <span class="number">98</span>])</span><br><span class="line">        plt.imshow(self.data.T,</span><br><span class="line">                   vmin=vmin, vmax=vmax, </span><br><span class="line">                   cmap = cmap,</span><br><span class="line">                   aspect = <span class="string">&#x27;auto&#x27;</span>)</span><br><span class="line">        plt.show()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">warpper</span>():</span><br><span class="line">    m8r.no_swig()</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, root_path</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        root_path: The root path of data.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.__root_path__ = root_path</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__set_attr_by_name__</span>(<span class="params">self, name, postfix = <span class="string">&#x27;rsf&#x27;</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        name: The name of rsf file that need to be loaded.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        path = os.path.join(self.__root_path__, name+<span class="string">&#x27;.&#x27;</span>+postfix)</span><br><span class="line">        self.__setattr__(name, m8r_read(path))</span><br><span class="line">        self.__getattribute__(name).__read__()</span><br></pre></td></tr></table></figure><br>我们以<code>rsf/su/rsflab16/seismic.rsf</code>为例，展示如何使用<code>warpper</code>读取<code>RSF</code>文件。</p>
<p>首先，我们通过<code>warp = warpper(file_path)</code>来实例化该类，其中<code>file_path</code>为<code>seismic.rsf</code>文件的路径，然后调用该类的<code>__set_attr_by_name__</code>方法，即<code>warp.__set_attr_by_name__(&#39;seismic&#39;)</code>，此时已经创建了与<code>seismic.rsf</code>文件同名的<code>warp.seismic</code>方法，该文件中的数据即存储在<code>numpy</code>数组<code>warp.seismic.data</code>中，参数则存储在<code>warp.seismic.pars</code>中。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">warp = warpper(file_path)</span><br><span class="line">warp.__set_attr_by_name__(<span class="string">&#x27;seismic&#x27;</span>)</span><br><span class="line"><span class="comment"># 数据</span></span><br><span class="line"><span class="built_in">print</span>(warp.seismic.data.shape)</span><br><span class="line"><span class="comment"># 参数</span></span><br><span class="line"><span class="built_in">print</span>(warp.seismic.pars)</span><br></pre></td></tr></table></figure>
<p>实质上，数据和参数读取分别调用了<code>m8r.Input.read()</code>和<code>m8r.Input.pars</code>，这里只是将其封装在了新的类中，用户仍旧可以通过<code>warp.seismic.Input.xxx</code>来使用原<code>m8r.Input</code>中的其它方法，例如调用<code>warp.seismic.grey()</code>来显示并存储等。</p>
<h1 id="Numpy数据写入RSF文件"><a href="#Numpy数据写入RSF文件" class="headerlink" title="Numpy数据写入RSF文件"></a>Numpy数据写入RSF文件</h1><p><code>Madagascrar</code>中的部分功能需要使用<code>.rsf</code>文件作为输入参数，由于暂时未找到直接将<code>numpy.ndarray</code>数据作为参数输入<code>m8r.func()</code>中的方法，因此我们先将<code>numpy.ndarray</code>数据格式化写入<code>.rsf</code>文件，然后再调用函数从<code>.rsf</code>文件中读取数据。</p>
<h3 id="数据准备"><a href="#数据准备" class="headerlink" title="数据准备"></a>数据准备</h3><p>假设一炮集记录共55道，每道有1500个采样点，将二维炮集记录写入<code>.rsf</code>文件时，<strong>需要保证第一个维度为道，第二维度为每道的采样点</strong>，此数据形成的<code>numpy</code>数组<code>shape</code>应为<code>(55, 1500)</code>。</p>
<h3 id="文件写入"><a href="#文件写入" class="headerlink" title="文件写入"></a>文件写入</h3><p>首先，通过<code>m8r.Output(file_path)</code>创建一个与<code>C</code>中文件指针相当的函数，其中<code>file_path</code>为<code>.rsf</code>文件的路径（包含文件名），然后分别通过此类的<code>put</code>和<code>write</code>方法向文件指针中写入参数与数据，最后调用<code>close</code>方法关闭文件指针。代码示例如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data.shape = (<span class="number">55</span>, <span class="number">1500</span>)</span><br><span class="line"><span class="built_in">type</span>(data) = numpy.ndarray</span><br><span class="line">data.dtype = np.float32</span><br><span class="line"></span><br><span class="line">file = m8r.Output(<span class="string">&#x27;data.rsf&#x27;</span>)</span><br><span class="line">file.put(<span class="string">&#x27;n1&#x27;</span>, data.shape[<span class="number">1</span>])</span><br><span class="line">file.put(<span class="string">&#x27;n2&#x27;</span>, data.shape[<span class="number">0</span>])</span><br><span class="line"><span class="comment"># 时间采样间隔</span></span><br><span class="line">file.put(<span class="string">&#x27;d1&#x27;</span>, <span class="number">0.004</span>)</span><br><span class="line"><span class="comment"># 空间采样间隔</span></span><br><span class="line">file.put(<span class="string">&#x27;d2&#x27;</span>, <span class="number">1.</span>)</span><br><span class="line">file.write(data)</span><br><span class="line">file.close()</span><br></pre></td></tr></table></figure>
<p>将<code>numpy</code>格式炮集数据写入<code>.rsf</code>文件时，值得注意的有以下几点：</p>
<ol>
<li><code>numpy</code>数据的<strong>第一</strong>和<strong>第二</strong>个维度分别为<strong>道</strong>和<strong>时间</strong></li>
<li><code>n1</code>和<code>n2</code>分别表示<strong>时间采样点数</strong>和<strong>道数</strong>；</li>
<li><code>d1</code>和<code>d2</code>分别代表<strong>时间采样间隔</strong>和<strong>道间距</strong>。</li>
</ol>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>由于<code>m8r</code>中的函数不支持<code>numpy</code>数据作为参数输入（可能是由于源码中没有嵌入<code>numpy</code>格式），因此我们需要先将数据写入到<code>.rsf</code>文件中，然后再将文件路径作为参数传入到函数中，完成相关功能的实现。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Madagascrar</category>
      </categories>
      <tags>
        <tag>编程开发</tag>
      </tags>
  </entry>
  <entry>
    <title>NoisePy安装及简易教程</title>
    <url>/2020/12/27/NoisePy001/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="NoisePy简易教程"><a href="#NoisePy简易教程" class="headerlink" title="NoisePy简易教程"></a>NoisePy简易教程</h1><h4 id="翻译自GitHub"><a href="#翻译自GitHub" class="headerlink" title="翻译自GitHub"></a>翻译自<a href="https://github.com/mdenolle/NoisePy">GitHub</a></h4><p>NoisePy是一个Python软件包，旨在快速轻松地计算背景噪声互相关函数。 它提供了用于噪声监视和表面波色散分析的其他功能。</p>
<p>免责声明：此代码不应“按原样”使用，也不能像黑盒一样运行。 希望用户更改本地路径和参数。 如果有问题，请将其提交到github，其中包含要调试的脚本和错误消息等信息。</p>
<p>完整doc请参考 <a href="https://noise-python.readthedocs.io/en/latest/">https://noise-python.readthedocs.io/en/latest/</a><br><img src="/2020/12/27/NoisePy001/logo.png" alt="logo"></p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>如果您在文章中使用了代码，请引用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Jiang, C. and Denolle, M. &quot;NoisePy: a new high-performance python tool for seismic ambient noise seismology.&quot; Seismological Research Letter 91 (3): 1853–1866.</span><br></pre></td></tr></table></figure>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>NoisePy由python脚本组成，因此其安装方式十分灵活，这实际上是为了构建脚本和相关功能的依赖库。 我们建议使用conda和pip安装库，因为它们更方便。 下面是我们经过测试的命令行，这些命令行将创建一个运行NoisePy的python环境。 请注意，该测试是在MacOS上执行的，因此对于其他OS可能会略有不同。（假设主机已经安装了MPI，mpi4py包会用到）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda create -n noisepy -c conda-forge python=3.7 numpy=1.16.2 numba pandas pycwt jupyter mpi4py=3.0.1 obspy=1.1 pyasdf</span><br><span class="line">conda activate noisepy</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/mdenolle/NoisePy.git</span><br></pre></td></tr></table></figure>
<h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><ul>
<li>根据obspy的<code>get_station</code>和<code>get_waveforms</code>的核心功能下载连续噪声数据</li>
<li>以ASDF格式保存地震数据，该数据可以方便地将元数据、波形数据和辅助数据组合到一个文件中（读/写ASDF文件的教程）</li>
<li>提供了高度的灵活性来处理存储在本地计算机上的混乱的SAC / miniSEED数据并将其转换为ASDF格式的数据，可以轻松地将其插入NoisePy</li>
<li>通过MPI并行运行功能，执行快速，简单的互相关(cross-correlation)</li>
<li>包括一系列监视功能，可使用一些最近开发的新方法来对结果互相关函数上的dv / v进行测量（有关更多详细信息，请参见我们的论文）</li>
</ul>
<h2 id="简易教程"><a href="#简易教程" class="headerlink" title="简易教程"></a>简易教程</h2><h3 id="0A-使用S0A-download-ASDF-MPI-py下载地震噪声数据"><a href="#0A-使用S0A-download-ASDF-MPI-py下载地震噪声数据" class="headerlink" title="0A. 使用S0A_download_ASDF_MPI.py下载地震噪声数据"></a>0A. 使用<code>S0A_download_ASDF_MPI.py</code>下载地震噪声数据</h3><p>该脚本（位于<code>src</code>目录中）及其现有参数允许通过SCEC数据中心下载位于某个区域并在1/Jul/2016-2/Jul/2016 期间运行的所有可用宽频CI台站（BH？） 。</p>
<p>在脚本中，为所有可根据用户需要更改的输入参数提供了简短摘要。 </p>
<p>在脚本的当前形式中，我们设置<code>inc_hours = 24</code>，下载一整天的连续噪声数据以及元信息，并将其存储在单个ASDF文件中。 为了增加最终互相关函数的信噪比（SNR）（更多详细信息，请参见Seats等，2012），我们将整天的序列分成了较小的段，每个<code>cc_len</code>长， 相邻段之间有部分重叠。 如果在下载过程中需要保存中间输出/操作时间，则可能需要将<code>flag</code>设置为<code>True</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python S0A_download_ASDF_MPI.py</span><br></pre></td></tr></table></figure>
<p>如果要使用多个内核（例如4个），请使用以下命令（使用mpi4py包）运行脚本。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mpirun -n 4 python S0A_download_ASDF_MPI.py</span><br></pre></td></tr></table></figure>
<p>从S0A输出的文件包括包含每日（24h）连续噪声数据的ASDF文件，在S0A脚本中记录所有使用的参数的参数文件以及所有电台信息的CSV文件（有关读取带有下载数据的ASDF文件的更多详细信息 可以在docs / src / ASDF.md中找到）。 可以使用src目录中名为plotting_modules的绘图模块显示存储在ASDF文件中的连续波形数据，如下所示。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> plotting_modules <span class="comment">#(cd to your source file directory first before loading this module)</span></span><br><span class="line">sfile = <span class="string">&#x27;/RAW_DATA/2016_07_01_00_00_00T2016_07_02_00_00_00.h5&#x27;</span></span><br><span class="line">plotting_modules.plot_waveform(sfile,<span class="string">&#x27;CI&#x27;</span>,<span class="string">&#x27;BLC&#x27;</span>,<span class="number">0.01</span>,<span class="number">0.4</span>)   </span><br></pre></td></tr></table></figure>
<p><img src="/2020/12/27/NoisePy001/waveform3.png" alt="waveform3"><br>请注意，该脚本还提供了从现有台站列表下载数据的选项，其格式与输出的CSV文件相同。 在这种情况下，应该在<code>L53</code>将<code>down_list</code>设置为<code>True</code>。 </p>
<p>实际上，下载速度取决于许多因素，例如目标数据的原始采样率，网络，托管该数据的数据中心以及要存储在计算机上的一般结构等。我们测试了许多评估其性能的参数，读者可参考我们的论文以获取更多详细信息（Jiang等人，2019）。</p>
<h3 id="0B-使用S0B-sacMSEED-to-ASDF-py处理本地SAC-缩小文件"><a href="#0B-使用S0B-sacMSEED-to-ASDF-py处理本地SAC-缩小文件" class="headerlink" title="0B. 使用S0B_sacMSEED_to_ASDF.py处理本地SAC /缩小文件"></a>0B. 使用<code>S0B_sacMSEED_to_ASDF.py</code>处理本地SAC /缩小文件</h3><p>如果要使用<code>NoisePy</code>处理存储在自己磁盘上的SAC /缩小格式的本地数据，则需要使用此脚本。 大多数变量与S0A的变量相同，因此应该很容易理解和更改。 </p>
<p>在此脚本中，它将通过合并，去趋势，去斜，下采样然后进行修整来对数据进行预处理，然后再将其保存为ASDF格式以用于以后的<code>NoisePy</code>处理。 特别是，我们希望脚本能够处理非常混乱的数据，这意味着地震数据会被分解成小块，并且混乱的时间信息（例如重叠的时间）会被分解。 <strong>记住，当数据混乱时，将<code>L62</code>处的<code>messydata</code>设置为<code>True</code>！ （有关删除仪器响应的教程）</strong></p>
<h3 id="1-使用S1-fft-cc-MPI-py-执行互相关"><a href="#1-使用S1-fft-cc-MPI-py-执行互相关" class="headerlink" title="1. 使用S1_fft_cc_MPI.py 执行互相关"></a>1. 使用<code>S1_fft_cc_MPI.py</code> 执行互相关</h3><p>这是NoisePy的核心脚本，该脚本首先对所有噪声数据执行傅立叶变换，然后将它们加载到内存中，然后再进行进一步的互相关。 </p>
<p>这意味着互相关是在频率域进行的。 在脚本中，我们提供了几种计算互相关的选项，包括<code>raw</code>，<code>coherency</code>和<code>deconv</code>（有关详细定义，请参见我们的论文*）。 我们在这里以<code>coherency</code>为例。 </p>
<p>运行脚本后，它将创建一个名为<code>CCF</code>的新文件夹，在其中放置了包含不同工作站对之间所有互相关函数的新ASDF文件。 它还创建一个<code>fft_cc_data.txt</code>参数文件，该文件记录了此脚本中使用的所有有用参数。 </p>
<p>一旦获得互相关文件，就可按以下方式在<code>plotting_modules</code>中调用<code>plot_substack_cc</code>函数来显示所有<strong>站对</strong>之间的每日时间变化。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> plotting_modules</span><br><span class="line">sfile = <span class="string">&#x27;/2016_07_01_00_00_00T2016_07_02_00_00_00.h5&#x27;</span></span><br><span class="line">plot_modules.plot_substack_cc(sfile,<span class="number">0.1</span>,<span class="number">0.2</span>,<span class="number">200</span>,<span class="literal">True</span>,<span class="string">&#x27;/Users/chengxin/Documents/SCAL/CCF/figures&#x27;</span>)     </span><br></pre></td></tr></table></figure>
<p><img src="/2020/12/27/NoisePy001/substack_cc_ZZ.png" alt="waveform3"></p>
<h3 id="2-使用S2-stacking-py叠加"><a href="#2-使用S2-stacking-py叠加" class="headerlink" title="2. 使用S2_stacking.py叠加"></a>2. 使用<code>S2_stacking.py</code>叠加</h3><p>该脚本用于叠加S1中所有台站对的互相关函数，并将它们保存到ASDF文件中以供将来分析（例如，时间变化和/或频散提取）。 特别地，叠加过程有两种选择，包括线性和相位加权堆叠（pws）。 通常，pws产生的波形具有高SNR，下面的快照显示了两种叠加方法的波形比较。 我们使用下面的命令来绘制动校正图。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> plotting_modules,glob</span><br><span class="line">sfiles = glob.glob(<span class="string">&#x27;/SCAL/STACK/*/*.h5&#x27;</span>)</span><br><span class="line">plot_modules.plot_all_moveout(sfiles,<span class="string">&#x27;Allstack_linear&#x27;</span><span class="number">0.1</span>,<span class="number">0.2</span>,<span class="string">&#x27;ZZ&#x27;</span>,<span class="number">1</span>,<span class="number">300</span>,<span class="literal">True</span>,<span class="string">&#x27;/SCAL/STACK&#x27;</span>) <span class="comment">#(move-out for linear stacking)</span></span><br><span class="line">plot_modules.plot_all_moveout(sfiles,<span class="string">&#x27;Allstack_pws&#x27;</span><span class="number">0.1</span>,<span class="number">0.2</span>,<span class="string">&#x27;ZZ&#x27;</span>,<span class="number">1</span>,<span class="number">300</span>,<span class="literal">True</span>,<span class="string">&#x27;/SCAL/STACK&#x27;</span>)    <span class="comment">#(move-out for pws)</span></span><br></pre></td></tr></table></figure>
<p><img src="/2020/12/27/NoisePy001/linear_stack1.png" alt="waveform3"><br><img src="/2020/12/27/NoisePy001/pws_stack1.png" alt="waveform3"><br>无论如何，这里仅给出一个简单的示例，说明NoisePy可能如何工作！<br>我们强烈建议您下载NoisePy软件包并自行探索！<br>如果在运行代码期间有任何意见和/或建议，请不要犹豫通过电子邮件与我们联系，或在<a href="https://github.com/mdenolle/NoisePy">此github页面</a>中创建issue！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Chengxin Jiang (chengxin_jiang@fas.harvard.edu)</span><br><span class="line">Marine Denolle (mdenolle@fas.harvard.edu).</span><br></pre></td></tr></table></figure>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Seats, K. J., Jesse F. L., and German A. P. &quot;Improved ambient noise correlation functions using Welch′ s method.&quot; Geophysical Journal International 188, no. 2 (2012): 513-523.</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*Jiang, C. and Denolle, M. &quot;NoisePy: a new high-performance python tool for seismic ambient noise seismology.&quot; Seismological Research Letter 91, no. 3 (2020): 1853–1866..</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">** Yuan, C., Bryan, J. T., Jiang, C., Okubo, K., Clements, T. and Denolle, M. (2019). Comparing approaches to measuring time- and frequency-dependent seismic phase variations for coda wave interferometry. In AGU Fall Meeting 2019.</span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>obspy</category>
      </categories>
      <tags>
        <tag>天然地震</tag>
      </tags>
  </entry>
  <entry>
    <title>使用bs4解析网站内容-以抓取Geophysics网站的文献词条为例</title>
    <url>/2021/09/17/html_study1/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="按照卷号和期号抓取Geophysics论文"><a href="#按照卷号和期号抓取Geophysics论文" class="headerlink" title="按照卷号和期号抓取Geophysics论文"></a>按照卷号和期号抓取Geophysics论文</h1><p>论文词条的输出格式如下：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">作者，出版年份，论文标题，Geophysics，卷号（期号），页码，doi.</span><br></pre></td></tr></table></figure><br>论文抓取的函数如下（使用到了<code>bs4</code>和<code>requests</code>模块）<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_seg_paper_lists</span>(<span class="params">volume_no, issue_no, write_path</span>):</span><br><span class="line">	<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">		volume_no: Geophysics卷号</span></span><br><span class="line"><span class="string">		issue_no： Geophysics期号</span></span><br><span class="line"><span class="string">		write_path：需要将文件写入的路径</span></span><br><span class="line"><span class="string">	&#x27;&#x27;&#x27;</span></span><br><span class="line">	<span class="comment"># 需要抓取论文信息的页面</span></span><br><span class="line">	<span class="comment"># 例(2018年3-4月第83卷第2期)：https://library.seg.org/toc/gpysa7/83/2</span></span><br><span class="line">    url = <span class="string">&#x27;https://library.seg.org/toc/gpysa7/&#x27;</span>+ <span class="string">&#x27;%02d&#x27;</span>%(volume_no) + <span class="string">&#x27;/%d&#x27;</span>%(issue_no)</span><br><span class="line">    html = requests.get(url)</span><br><span class="line">    html.encoding = <span class="string">&#x27;utf-8&#x27;</span></span><br><span class="line">    soup = BeautifulSoup(html.text, <span class="string">&quot;html.parser&quot;</span>)</span><br><span class="line">    <span class="comment"># 解析html文本</span></span><br><span class="line">    <span class="comment">## 每一篇论文都是一个titled_issues， 并且有的标签还包含了章节名titled_issues__title to-section</span></span><br><span class="line">    issues = soup.find_all(<span class="string">&#x27;div&#x27;</span>, <span class="string">&#x27;titled_issues&#x27;</span>)</span><br><span class="line">    <span class="comment"># 创建空字典，将章节名作为key，将章节下的包含文章词条的列表作为value</span></span><br><span class="line">    contents = <span class="built_in">dict</span>()</span><br><span class="line">    <span class="comment"># 循环遍历该volume-issue下的论文</span></span><br><span class="line">    <span class="keyword">for</span> issue <span class="keyword">in</span> issues:</span><br><span class="line">        <span class="comment"># 尝试获取章节名，如果章节名不是字典的键，则为该章节名添加空列表</span></span><br><span class="line">        to_section = issue.find(<span class="string">&#x27;h4&#x27;</span>, <span class="string">&#x27;titled_issues__title to-section&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> to_section:</span><br><span class="line">            Section = to_section.string</span><br><span class="line">            <span class="keyword">if</span> Section <span class="keyword">not</span> <span class="keyword">in</span> contents.keys():</span><br><span class="line">                contents[Section]=[]</span><br><span class="line">		<span class="comment"># 获取页码</span></span><br><span class="line">        pages = get_pages(issue)</span><br><span class="line">        <span class="comment"># 获取作者列表</span></span><br><span class="line">        authors = get_authors(issue)</span><br><span class="line">        <span class="comment"># 获取论文标题</span></span><br><span class="line">        title = issue.find(<span class="string">&#x27;div&#x27;</span>, <span class="string">&#x27;issue-item__title&#x27;</span>).string</span><br><span class="line">        <span class="comment"># 获取论文doi</span></span><br><span class="line">        doi   = issue.find(<span class="string">&#x27;div&#x27;</span>, <span class="string">&#x27;issue-item__doi&#x27;</span>).string</span><br><span class="line">        <span class="comment"># 若论文作者列表为空则设置为字符串‘None’</span></span><br><span class="line">        authors = <span class="string">&#x27;None&#x27;</span> <span class="keyword">if</span> authors <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">else</span> authors</span><br><span class="line">        <span class="comment"># 如果作者、标题和doi均不为空，则将论文信息整理为指定格式</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">all</span>([authors, title, doi]):</span><br><span class="line">            ref = ref_type(authors,</span><br><span class="line">                           title.title(),</span><br><span class="line">                           volume2year(volume_no),</span><br><span class="line">                           volume_no,</span><br><span class="line">                           issue_no,</span><br><span class="line">                           pages,</span><br><span class="line">                           doi.title())</span><br><span class="line">            <span class="comment"># 将论文词条ref添加到其对应的章节Section中</span></span><br><span class="line">            contents[Section].append(ref)</span><br><span class="line">    <span class="comment"># 将章节和论文内容按照每卷每期写入文件</span></span><br><span class="line">    <span class="comment"># 章节1：</span></span><br><span class="line">    <span class="comment">#     论文1</span></span><br><span class="line">    <span class="comment">#     论文2</span></span><br><span class="line">    <span class="comment"># 章节2：</span></span><br><span class="line">    <span class="comment">#     论文1</span></span><br><span class="line">    <span class="comment">#     ····</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(write_path, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> key, value <span class="keyword">in</span> <span class="built_in">zip</span>(contents.keys(), contents.values()):</span><br><span class="line">            f.write(key+<span class="string">&#x27;:\n&#x27;</span>)</span><br><span class="line">            <span class="keyword">for</span> title <span class="keyword">in</span> value:</span><br><span class="line">                <span class="keyword">if</span> title:</span><br><span class="line">                    f.write(<span class="string">&#x27;\t&#x27;</span>+title+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">            f.write(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Lists have been written into %s&#x27;</span>%(write_path))</span><br></pre></td></tr></table></figure><br>子函数如下：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 词条格式</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ref_type</span>(<span class="params">author_list, title, year, volume, issue, pages, doi</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    	author_list: 作者列表</span></span><br><span class="line"><span class="string">    	title      ：标题</span></span><br><span class="line"><span class="string">    	year       : 论文出版年份</span></span><br><span class="line"><span class="string">    	volume     ：论文出版卷号</span></span><br><span class="line"><span class="string">    	issue      ：论文出版期号</span></span><br><span class="line"><span class="string">    	pages      : 页码</span></span><br><span class="line"><span class="string">    	doi        ：doi</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    ref = <span class="string">&#x27;, &#x27;</span>.join([author_list,</span><br><span class="line">                    <span class="string">&#x27;%d&#x27;</span>%(year),</span><br><span class="line">                    title,</span><br><span class="line">                    <span class="string">&#x27;Geophysics&#x27;</span>,</span><br><span class="line">                    <span class="string">&#x27;%d(%d)&#x27;</span>%(volume, issue),</span><br><span class="line">                    pages])</span><br><span class="line">    ref = ref + <span class="string">&#x27;. doi: %s.&#x27;</span>%(doi.lower())</span><br><span class="line">    <span class="keyword">return</span> ref</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 根据作者的数量输出合适的格式</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">combine_authors</span>(<span class="params">author_list</span>):</span><br><span class="line">	<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">		author_list: 列表，包含作者的名字</span></span><br><span class="line"><span class="string">	&#x27;&#x27;&#x27;</span></span><br><span class="line">	<span class="comment"># 只有一个作者</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(author_list)==<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> author_list[<span class="number">0</span>]</span><br><span class="line">    <span class="comment"># 两个作者，中间用and连接</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(author_list)==<span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27; and &#x27;</span>.join(author_list)</span><br><span class="line">    <span class="comment"># 大于两个作者，出最后一个作者用and连接外，其他作者用，</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(author_list)&gt;<span class="number">2</span>:</span><br><span class="line">        new_list = <span class="string">&#x27;, &#x27;</span>.join(author_list[<span class="number">0</span>:-<span class="number">1</span>])</span><br><span class="line">        new_list += <span class="string">&#x27; and &#x27;</span>+author_list[-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> new_list</span><br><span class="line"><span class="comment"># 从html中抓取作者信息</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_authors</span>(<span class="params">issue</span>):</span><br><span class="line">	<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">		issue: &lt;titled_issues&gt;每个论文的节点标签。</span></span><br><span class="line"><span class="string">	&#x27;&#x27;&#x27;</span></span><br><span class="line">    authors = issue.find(<span class="string">&#x27;div&#x27;</span>, <span class="string">&#x27;issue-item__authors&#x27;</span>)</span><br><span class="line">    author_list = [d.string.title() <span class="keyword">for</span> d <span class="keyword">in</span> authors.find_all(<span class="string">&#x27;a&#x27;</span>)]</span><br><span class="line">    author_list = combine_authors(author_list)</span><br><span class="line">    <span class="keyword">return</span> author_list</span><br><span class="line"><span class="comment"># 从html中抓取页码信息</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_pages</span>(<span class="params">issue</span>):</span><br><span class="line">	<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">		issue: &lt;titled_issues&gt;每个论文的节点标签。</span></span><br><span class="line"><span class="string">	&#x27;&#x27;&#x27;</span></span><br><span class="line">    pages = issue.find(<span class="string">&#x27;ul&#x27;</span>, <span class="string">&#x27;rlist--inline separator toc-item__detail&#x27;</span>).find(<span class="string">&#x27;li&#x27;</span>).get_text(strip=<span class="literal">True</span>)</span><br><span class="line">    pages = pages.replace(<span class="string">&#x27;Pages:&#x27;</span>, <span class="string">&#x27;&#x27;</span>).replace(<span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> pages</span><br><span class="line"><span class="comment"># 将卷转换为年</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">volume2year</span>(<span class="params">volume</span>):</span><br><span class="line">	<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">		volume: 卷号。2017年为第82卷。</span></span><br><span class="line"><span class="string">	&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> volume + <span class="number">2017</span> - <span class="number">82</span></span><br></pre></td></tr></table></figure></p>
<p>以上即为如何利用bs4从html中解析文献信息。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 脚本执行如下命令即可将第82卷第1期的文章列表下载到文件V82I1.txt中</span></span><br><span class="line">get_seg_paper_lists(<span class="number">82</span>, <span class="number">1</span>, <span class="string">&#x27;./V82I1.txt&#x27;</span>)</span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>抓取文献词条</tag>
      </tags>
  </entry>
  <entry>
    <title>使用bs4解析网站内容-以抓取GJI网站的文献词条为例</title>
    <url>/2021/09/23/html_study2/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="按照卷号和期号抓取GJI-Geophysical-Journal-International-论文"><a href="#按照卷号和期号抓取GJI-Geophysical-Journal-International-论文" class="headerlink" title="按照卷号和期号抓取GJI(Geophysical Journal International)论文"></a>按照卷号和期号抓取GJI(Geophysical Journal International)论文</h1><p>论文词条输出格式如下：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">序号. 作者列表, Geophysical Journal International, doi.</span><br></pre></td></tr></table></figure><br>论文抓取函数如下：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_seg_paper_lists</span>(<span class="params">volume_no, issue_no, write_path</span>):</span><br><span class="line">    </span><br><span class="line">    url = <span class="string">&#x27;https://academic.oup.com/gji/issue/&#x27;</span>+ <span class="string">&#x27;%02d&#x27;</span>%(volume_no) + <span class="string">&#x27;/%d&#x27;</span>%(issue_no)</span><br><span class="line">    headers = &#123;<span class="string">&#x27;User-Agent&#x27;</span>:<span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) &#x27;</span></span><br><span class="line">                        <span class="string">&#x27;Chrome/51.0.2704.63 Safari/537.36&#x27;</span>&#125;</span><br><span class="line">    html = requests.get(url, headers = headers)</span><br><span class="line">    html.encoding = <span class="string">&#x27;utf-8&#x27;</span></span><br><span class="line">    soup = BeautifulSoup(html.text, <span class="string">&quot;html.parser&quot;</span>)</span><br><span class="line">    issues = soup.find_all(<span class="string">&#x27;div&#x27;</span>, <span class="string">&#x27;al-article-item-wrap al-normal&#x27;</span>)</span><br><span class="line">    contents = []</span><br><span class="line">    <span class="keyword">for</span> issue <span class="keyword">in</span> issues:</span><br><span class="line">        <span class="comment">#authors = issue.find(&#x27;div&#x27;,&#x27;al-authors-list&#x27;)</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            authors = get_authors(issue)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        title = issue.find(<span class="string">&#x27;h5&#x27;</span>, <span class="string">&#x27;customLink item-title&#x27;</span>).find(<span class="string">&#x27;a&#x27;</span>).string</span><br><span class="line">        title = title.title() <span class="keyword">if</span> title <span class="keyword">else</span> <span class="string">&#x27;None&#x27;</span></span><br><span class="line">        zipped = issue.find(<span class="string">&#x27;div&#x27;</span>, <span class="string">&#x27;pub-history-row clearfix&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">        ref_mid   = zipped.find(<span class="string">&#x27;div&#x27;</span>, <span class="string">&#x27;ww-citation-primary&#x27;</span>).contents[<span class="number">1</span>].title()</span><br><span class="line">        doi       = zipped.find(<span class="string">&#x27;div&#x27;</span>, <span class="string">&#x27;ww-citation-primary&#x27;</span>).find(<span class="string">&#x27;a&#x27;</span>).contents[<span class="number">0</span>].title()</span><br><span class="line"></span><br><span class="line">        authors = <span class="string">&#x27;None&#x27;</span> <span class="keyword">if</span> authors <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">else</span> authors</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">all</span>([authors, title, doi]):</span><br><span class="line">            ref = ref_type2(authors,</span><br><span class="line">                            title,</span><br><span class="line">                            doi.title())</span><br><span class="line">            contents.append(ref)</span><br><span class="line">            </span><br><span class="line">    <span class="comment"># Write into files:</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(write_path, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(<span class="string">&#x27;Volume%d_Issue%d&#x27;</span>%(volume_no, issue_no)+<span class="string">&#x27;\n\n&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> idx, ref <span class="keyword">in</span> <span class="built_in">enumerate</span>(contents):</span><br><span class="line">            f.write(<span class="string">&#x27;%02d. &#x27;</span>%(idx)+ref)</span><br><span class="line">            f.write(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">                    </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Lists have been written into %s&#x27;</span>%(write_path))</span><br></pre></td></tr></table></figure></p>
<p>用到的其它函数：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">combine_authors</span>(<span class="params">author_list</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(author_list)==<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> author_list[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(author_list)==<span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27; and &#x27;</span>.join(author_list)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(author_list)&gt;<span class="number">2</span>:</span><br><span class="line">        new_list = <span class="string">&#x27;, &#x27;</span>.join(author_list[<span class="number">0</span>:-<span class="number">1</span>])</span><br><span class="line">        new_list += <span class="string">&#x27; and &#x27;</span>+author_list[-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> new_list</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ref_type2</span>(<span class="params">author_list, title, doi</span>):</span><br><span class="line">    </span><br><span class="line">    ref = <span class="string">&#x27;, &#x27;</span>.join([author_list,</span><br><span class="line">                     title,</span><br><span class="line">                     <span class="string">&#x27;Geophysical Journal International&#x27;</span>,</span><br><span class="line">                     doi.lower()+<span class="string">&#x27;.&#x27;</span>])</span><br><span class="line">    <span class="keyword">return</span> ref</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_authors</span>(<span class="params">issue</span>):</span><br><span class="line">    authors = issue.find(<span class="string">&#x27;div&#x27;</span>, <span class="string">&#x27;al-authors-list&#x27;</span>)</span><br><span class="line">    author_list = [d.string.title() <span class="keyword">for</span> d <span class="keyword">in</span> authors.find_all(<span class="string">&#x27;a&#x27;</span>)]</span><br><span class="line">    author_list = combine_authors(author_list)</span><br><span class="line">    <span class="keyword">return</span> author_list</span><br></pre></td></tr></table></figure><br>程序运行需执行如下命令：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">get_seg_paper_lists(卷号, 期号, 文件写入路径)</span><br></pre></td></tr></table></figure></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>抓取文献词条</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS下Anaconda及Tensorflow安装</title>
    <url>/2020/06/11/install_atk/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="CentOS7下深度学习环境配置（Anaconda-Tensorflow-Keras）"><a href="#CentOS7下深度学习环境配置（Anaconda-Tensorflow-Keras）" class="headerlink" title="CentOS7下深度学习环境配置（Anaconda+Tensorflow+Keras）"></a>CentOS7下深度学习环境配置（Anaconda+Tensorflow+Keras）</h1><h2 id="硬件信息查询"><a href="#硬件信息查询" class="headerlink" title="硬件信息查询"></a>硬件信息查询</h2><p>笔者的CPU和GPU型号分别如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> /proc/cpuinfo |grep name|<span class="built_in">cut</span> -f2 -d:|<span class="built_in">uniq</span> -c <span class="comment">#查看CPU型号</span></span><br><span class="line"> 12  Intel(R) Xeon(R) E-2286G CPU @ 4.00GHz</span><br><span class="line">$ lspci | grep -i nvidia 查看连接的GPU设备</span><br><span class="line">01:00.0 VGA compatible controller: NVIDIA Corporation TU102 [GeForce RTX 2080 Ti Rev. A] (rev a1)</span><br><span class="line">01:00.1 Audio device: NVIDIA Corporation TU102 High Definition Audio Controller (rev a1)</span><br><span class="line">01:00.2 USB controller: NVIDIA Corporation TU102 USB 3.1 Host Controller (rev a1)</span><br><span class="line">01:00.3 Serial bus controller [0c80]: NVIDIA Corporation TU102 USB Type-C UCSI Controller (rev a1)</span><br><span class="line"><span class="comment">#如果CUDA和驱动已经安装完成并且～/.bashrc也配置完成则可以通过 nvidia-smi 查询驱动及GPU信息。</span></span><br><span class="line">$ nvidia-smi <span class="comment">#输出GPU运行状态及驱动版本</span></span><br><span class="line">Tue Jun  9 11:30:14 2020       </span><br><span class="line">+-----------------------------------------------------------------------------+</span><br><span class="line">| NVIDIA-SMI 440.82       Driver Version: 440.82       CUDA Version: 10.2     |</span><br><span class="line">|-------------------------------+----------------------+----------------------+</span><br><span class="line">| GPU  Name        Persistence-M| Bus-Id        Disp.A | Volatile Uncorr. ECC |</span><br><span class="line">| Fan  Temp  Perf  Pwr:Usage/Cap|         Memory-Usage | GPU-Util  Compute M. |</span><br><span class="line">|===============================+======================+======================|</span><br><span class="line">|   0  GeForce RTX 208...  Off  | 00000000:01:00.0  On |                  N/A |</span><br><span class="line">| 66%   84C    P2   233W / 250W |  10969MiB / 11016MiB |     91%      Default |</span><br><span class="line">+-------------------------------+----------------------+----------------------+</span><br></pre></td></tr></table></figure>
<p>另外，对于 <strong>CUDA</strong> 和 <strong>cuDNN</strong> 版本的查询可通过以下方式进行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ nvcc --version <span class="comment">#查询cuda版本</span></span><br><span class="line">nvcc: NVIDIA (R) Cuda compiler driver</span><br><span class="line">Copyright (c) 2005-2018 NVIDIA Corporation</span><br><span class="line">Built on Sat_Aug_25_21:08:01_CDT_2018</span><br><span class="line">Cuda compilation tools, release 10.0, V10.0.130</span><br><span class="line"><span class="comment">#或者</span></span><br><span class="line">$ <span class="built_in">cat</span> /usr/local/cuda/version.txt</span><br><span class="line">CUDA Version 10.0.130</span><br><span class="line">$ <span class="built_in">cat</span> /usr/local/cuda/include/cudnn.h | grep CUDNN_MAJOR -A 2 <span class="comment">#查询cudnn版本</span></span><br><span class="line"><span class="comment">#define CUDNN_MAJOR 7</span></span><br><span class="line"><span class="comment">#define CUDNN_MINOR 6</span></span><br><span class="line"><span class="comment">#define CUDNN_PATCHLEVEL 5</span></span><br><span class="line">--</span><br><span class="line"><span class="comment">#define CUDNN_VERSION (CUDNN_MAJOR * 1000 + CUDNN_MINOR * 100 + CUDNN_PATCHLEVEL)</span></span><br><span class="line"><span class="comment">#include &quot;driver_types.h&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Anaconda-安装"><a href="#Anaconda-安装" class="headerlink" title="Anaconda 安装"></a>Anaconda 安装</h2><p>64位Linux的 <strong>Anacoda</strong> 安装包可以到<a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/">清华源</a>上下载，笔者下载安装的是5.3.1版本（<a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/Anaconda3-5.3.1-Linux-x86_64.sh">下载地址</a>），文件格式为 <strong>.sh</strong>，安装包下载完成后，我们进入到下载目录中，打开 <strong>terminal</strong> 并输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ bash Anaconda3-5.3.1-Linux-x86_64.sh -u <span class="comment"># -u可自定义安装目录</span></span><br><span class="line"><span class="comment">#进入安装后敲回车,直到出现界面并输入yes继续安装或者no退出安装:</span></span><br><span class="line">$ Please answer <span class="string">&#x27;yes&#x27;</span> or <span class="string">&#x27;no&#x27;</span>:<span class="string">&#x27;</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; yes</span></span><br><span class="line"><span class="string">Anaconda3 will now be installed into this location:</span></span><br><span class="line"><span class="string">/当前将要安装的目录</span></span><br><span class="line"><span class="string">  - Press ENTER to confirm the location</span></span><br><span class="line"><span class="string">  - Press CTRL-C to abort the installation</span></span><br><span class="line"><span class="string">  - Or specify a different location below</span></span><br><span class="line"><span class="string">[/home/wangsw/anaconda3] &gt;&gt;&gt; /此处输入你需要安装的目录</span></span><br><span class="line"><span class="string">#部分目录需要其它用户或者root权限，确认之后之后将会完成安装，最后会提示是否需要将Anaconda路径写入环境变量（推荐自动写入）以及是否需要使用VSCode（根据个人需要）：</span></span><br><span class="line"><span class="string">$ Do you wish the installer to initialize Anaconda3</span></span><br><span class="line"><span class="string">in your /root/.bashrc ? [yes|no]</span></span><br><span class="line"><span class="string">[no] &gt;&gt;&gt; no</span></span><br><span class="line"><span class="string">$ Do you wish to proceed with the installation of Microsoft VSCode? [yes|no]</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; no</span></span><br><span class="line"><span class="string">#此时安装已经完成。</span></span><br></pre></td></tr></table></figure>
<h2 id="conda-环境创建"><a href="#conda-环境创建" class="headerlink" title="conda 环境创建"></a>conda 环境创建</h2><p>然后我们开始配置 <strong>conda</strong> 环境，不同 <strong>conda</strong> 环境可以安装不同 <strong>python</strong> 版本以及 <strong>tensorflow</strong> 等版本，其相当于一个容器，可用于不同需求的生产环境。为了加速 <strong>conda</strong> 环境配置过程，与安装完系统后进行相同的操作：更新下载源（可使用清华源、中科大源等）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ conda config --show <span class="comment">#输入后找到 channels 属性可查看已有下载源，若没有镜像源则执行以下命令</span></span><br><span class="line">$ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/</span><br><span class="line">$ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span><br><span class="line">$ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/</span><br><span class="line">$ conda config --<span class="built_in">set</span> show_channel_urls <span class="built_in">yes</span> <span class="comment">#该命令可允许下载时显示源地址</span></span><br><span class="line">$ conda clean -i <span class="comment">#清除索引缓存，保证用的是镜像站提供的索引。</span></span><br><span class="line">$ conda config --show <span class="comment">#查看是否源地址是否更新完成</span></span><br></pre></td></tr></table></figure>
<p>更新完源之后我们建立深度学习环境，首先创建一个特定 <strong>python</strong> 版本的 <strong>conda</strong> 环境：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ conda create -n env_name python=3.x <span class="comment">#env_name处输入自己想要建立的环境名称，x处填写需要的python版本，笔者为了保证原有代码的可移植性，使用python3.6版本</span></span><br><span class="line">  Solving environment: \ <span class="comment">#环境配置中，耐心等待即可</span></span><br><span class="line">  <span class="comment">## Package Plan ##</span></span><br><span class="line">  environment location: /xxxxxx/Anaconda/envs/env_name</span><br><span class="line">  added / updated specs: </span><br><span class="line">    - python=3.6</span><br><span class="line"> </span><br><span class="line">The following packages will be downloaded:</span><br><span class="line">    package                    |            build</span><br><span class="line">    ---------------------------|-----------------</span><br><span class="line">    certifi-2020.4.5.2         |   py36h9f0ad1d_0         152 KB  https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge</span><br><span class="line">    ld_impl_linux-64-2.34      |       h53a641e_5         616 KB  https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge</span><br><span class="line">    ca-certificates-2020.4.5.2 |       hecda079_0         147 KB  https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge</span><br><span class="line">    ------------------------------------------------------------</span><br><span class="line">                                           Total:         914 KB</span><br><span class="line"></span><br><span class="line">The following NEW packages will be INSTALLED:</span><br><span class="line"></span><br><span class="line">    _libgcc_mutex:    0.1-conda_forge              https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge</span><br><span class="line">    _openmp_mutex:    4.5-0_gnu                    https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge</span><br><span class="line">    ca-certificates:  2020.4.5.2-hecda079_0        https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge</span><br><span class="line">    certifi:          2020.4.5.2-py36h9f0ad1d_0    https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge</span><br><span class="line">    ld_impl_linux-64: 2.34-h53a641e_5              https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge</span><br><span class="line">    libffi:           3.2.1-he1b5a44_1007          https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge</span><br><span class="line">    libgcc-ng:        9.2.0-h24d8f2e_2             https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge</span><br><span class="line">    libgomp:          9.2.0-h24d8f2e_2             https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge</span><br><span class="line">    libstdcxx-ng:     9.2.0-hdf63c60_2             https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge</span><br><span class="line">    ncurses:          6.1-hf484d3e_1002            https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge</span><br><span class="line">    openssl:          1.1.1g-h516909a_0            https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge</span><br><span class="line">    pip:              20.1.1-py_1                  https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge</span><br><span class="line">    python:           3.6.10-h8356626_1011_cpython https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge</span><br><span class="line">    python_abi:       3.6-1_cp36m                  https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge</span><br><span class="line">    readline:         8.0-hf8c457e_0               https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge</span><br><span class="line">    setuptools:       47.1.1-py36h9f0ad1d_0        https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge</span><br><span class="line">    sqlite:           3.30.1-hcee41ef_0            https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge</span><br><span class="line">    tk:               8.6.10-hed695b0_0            https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge</span><br><span class="line">    wheel:            0.34.2-py_1                  https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge</span><br><span class="line">    xz:               5.2.5-h516909a_0             https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge</span><br><span class="line">    zlib:             1.2.11-h516909a_1006         https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge</span><br><span class="line"></span><br><span class="line">Proceed ([y]/n)? <span class="comment">#输入y即可，可以看到安装包均从上文中配置的地址中下载</span></span><br><span class="line"></span><br><span class="line">Downloading and Extracting Packages</span><br><span class="line">ca-certificates-2020 | 147 KB    | <span class="comment">##################################### | 100% </span></span><br><span class="line">certifi-2020.4.5.2   | 152 KB    | <span class="comment">##################################### | 100% </span></span><br><span class="line">ld_impl_linux-64-2.3 | 616 KB    | <span class="comment">##################################### | 100% </span></span><br><span class="line">Preparing transaction: <span class="keyword">done</span></span><br><span class="line">Verifying transaction: <span class="keyword">done</span></span><br><span class="line">Executing transaction: <span class="keyword">done</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># To activate this environment, use:</span></span><br><span class="line"><span class="comment"># &gt; source activate env_name</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># To deactivate an active environment, use:</span></span><br><span class="line"><span class="comment"># &gt; source deactivate</span></span><br><span class="line"><span class="comment">#</span></span><br></pre></td></tr></table></figure><br>安装完成后，我们可以通过 <code>$ source activate env_name</code>来打开创建好的环境，<code>pip list</code>可查看当前环境下已经安装的轮子，<code>pip show [package_name]</code>可以查看轮子的版本等信息（输入时去掉中括号）。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(env_name)[root]$ pip list <span class="comment">#查看已安装轮子</span></span><br><span class="line">Package    Version</span><br><span class="line">---------- -------------------</span><br><span class="line">certifi    2020.4.5.2</span><br><span class="line">pip        20.1.1</span><br><span class="line">setuptools 47.1.1.post20200529</span><br><span class="line">wheel      0.34.2</span><br><span class="line">(env_name)[root]$ pip show certifi <span class="comment">#查看轮子信息</span></span><br><span class="line">Name: certifi</span><br><span class="line">Version: 2020.4.5.2</span><br><span class="line">Summary: Python package <span class="keyword">for</span> providing Mozilla<span class="string">&#x27;s CA Bundle.</span></span><br><span class="line"><span class="string">Home-page: https://certifiio.readthedocs.io/en/latest/</span></span><br><span class="line"><span class="string">Author: Kenneth Reitz</span></span><br><span class="line"><span class="string">Author-email: me@kennethreitz.com</span></span><br><span class="line"><span class="string">License: MPL-2.0</span></span><br><span class="line"><span class="string">Location: /..../Anaconda/envs/test/lib/python3.6/site-packages</span></span><br><span class="line"><span class="string">Requires: </span></span><br><span class="line"><span class="string">Required-by: </span></span><br></pre></td></tr></table></figure>
<p>同样的，为了加速 <strong>conda</strong> 环境内 <strong>pip</strong> 下载的速度我们首先更换下载源：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(env_name)[root]$ pip config <span class="built_in">set</span> global.index-url https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line">Writing to /..../.config/pip/pip.conf</span><br></pre></td></tr></table></figure>
<p>之后，可通过 <code>$pip install package</code> 的命令下载和安装轮子了（如果没有配置下载源的话，可以通过<code>$ pip install package -i https://pypi.tuna.tsinghua.edu.cn/simple</code>的方式临时使用 <strong>url</strong> 下载）。需要注意的是，该环境下安装的包只能在环境内使用，这也允许我们能够使用多个版本的生产环境，只需要<code>$ source activate env_name</code>即可。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#笔者使用的生产环境之一为：</span></span><br><span class="line">(env_name)[root]$ pip install tensorflow-gpu==1.14.0</span><br><span class="line">(env_name)[root]$ pip install keras==2.2.5</span><br><span class="line">(env_name)[root]$ pip install numpy==1.16.0</span><br><span class="line">(env_name)[root]$ <span class="built_in">source</span> deactivate <span class="comment">#退出已打开的环境env_name</span></span><br></pre></td></tr></table></figure>
<h2 id="conda-常用命令"><a href="#conda-常用命令" class="headerlink" title="conda 常用命令"></a>conda 常用命令</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ conda --version <span class="comment">#查看conda版本</span></span><br><span class="line">$ conda creat -n your_env_name python==3.x <span class="comment">#创建python版本为3.x的conda环境</span></span><br><span class="line">$ conda remove --name your_env_name --all <span class="comment">#删除已创建环境</span></span><br><span class="line">$ conda create --name new_env --<span class="built_in">clone</span> old_env <span class="comment">#创建新conda环境new_env并将old_env环境复制到前者中</span></span><br><span class="line">$ <span class="built_in">source</span> activate your_env_name <span class="comment">#激活已创建环境</span></span><br><span class="line">$ <span class="built_in">source</span> deactivate <span class="comment">#退出当前窗口中已激活环境</span></span><br><span class="line">$ conda info -e  <span class="comment">#查询已安装环境</span></span><br><span class="line">$ conda install --name your_env_name package_name <span class="comment">#在指定环境your_env_name中安装package_name包（例如conda install my_env tensorflow-gpu==2.0.0）</span></span><br><span class="line">$ conda update conda <span class="comment">#（不推荐）将conda更新至最新版本，但也会更新其它相关包</span></span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>装机</category>
      </categories>
      <tags>
        <tag>深度学习环境配置</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS下CUDA及cuDNN安装</title>
    <url>/2020/06/10/install_cudacudnn/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="工作站CentOS-7下CUDA驱动及cuDNN安装"><a href="#工作站CentOS-7下CUDA驱动及cuDNN安装" class="headerlink" title="工作站CentOS-7下CUDA驱动及cuDNN安装"></a>工作站CentOS-7下CUDA驱动及cuDNN安装</h1><h2 id="安装包选择及下载"><a href="#安装包选择及下载" class="headerlink" title="安装包选择及下载"></a>安装包选择及下载</h2><ul>
<li><strong>Nvidia驱动下载：</strong> 一般不使用 <strong>CUDA</strong> 安装包中的驱动程序，而是到<a href="https://www.nvidia.cn/Download/index.aspx?lang=cn">官方网站</a>根据 GPU 型号下载对应驱动，这里我们选择与 <strong>RTX2080Ti</strong> 对应的<a href="http://cn.download.nvidia.com/XFree86/Linux-x86_64/440.82/NVIDIA-Linux-x86_64-440.82.run">440.82-Linux 64-bit</a>版本，笔者首先安装的驱动，然后才装的 <strong>CUDA-10.0</strong> ，理论上二者先后顺序没有强制性。若先装 <strong>CUDA</strong> 的话记住<strong>不要不要不要不要安装自带的驱动程序</strong>，否则<strong>可能会出现重启后黑屏无法进入系统等问题</strong>。<strong>Ubuntu</strong> 中一般能够通过命令行操作删除驱动和 <strong>CUDA</strong>，但在 <strong>CentOS</strong> 系统中可能会导致无法进入终端命令行字符界面，完全黑屏时最粗暴的处理办法就是重装系统，<strong>grub</strong> 中的操作方式笔者没有研究过。当然了，如果先装驱动程序后装 <strong>CUDA</strong> ，自带的驱动自然也是不需要安装的。</li>
<li><strong>CUDA Toolkit</strong> 下载：版本根据实际需要进行选择，笔者最开始接触的GPU并行编程语言的时候就已经是 <strong>v10.0</strong> 了(现在最新版本为 <strong><a href="https://developer.nvidia.com/cuda-downloads?target_os=Linux">CUDA11</a></strong>)，本机器上安装的 <strong><a href="https://developer.nvidia.com/compute/cuda/10.0/Prod/local_installers/cuda-repo-rhel7-10-0-local-10.0.130-410.48-1.0-1.x86_64">CUDA_10.0.130</a></strong>（<a href="https://developer.nvidia.com/cuda-toolkit-archive">历史版本 <strong>CUDA</strong> 下载地址</a>）</li>
<li><strong>cuDNN下载</strong>：下载 <strong>cuDNN</strong> 前要先注册一个 <strong>Nvidia</strong> 账户，忘记密码的话通过官方渠道申请修改密码可能会遇到无法收到邮件的问题，这一问题暂时没有好的解决办法；如果没有账户的话直接注册一个即可，（注册账户的邮件能收到，修改密码的经常收不到，同时我们注意到官方开通了微信或者QQ登陆方式，但是我打不开。。。），<strong>cuDNN</strong> 版本与 <strong>CUDA</strong> 版本要对应上，这里笔者使用的是与 <strong>CUDA10.0</strong>对应的 <strong>cuDNN7</strong> (cudnn-10.0-linux-x64-v7.6.5.32，没有链接，刚改了密码又忘了登不上去了= =)。</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>CUDA Toolkit</th>
<th>Linuxx86_64驱动版本</th>
<th>Windowsx86_64驱动版本</th>
</tr>
</thead>
<tbody>
<tr>
<td>CUDA 10.2.89</td>
<td>&gt;= 440.33</td>
<td>&gt;= 441.22</td>
</tr>
<tr>
<td>CUDA 10.1 (10.1.105 general release, and updates)</td>
<td>&gt;= 418.39</td>
<td>&gt;= 418.96</td>
</tr>
<tr>
<td>CUDA 10.0.130</td>
<td>&gt;= 410.48</td>
<td>&gt;= 411.31</td>
</tr>
<tr>
<td>CUDA 9.2 (9.2.148 Update 1)</td>
<td>&gt;= 396.37</td>
<td>&gt;= 398.26</td>
</tr>
<tr>
<td>CUDA 9.2 (9.2.88)</td>
<td>&gt;= 396.26</td>
<td>&gt;= 397.44</td>
</tr>
<tr>
<td>CUDA 9.1 (9.1.85)</td>
<td>&gt;= 390.46</td>
<td>&gt;= 391.29</td>
</tr>
<tr>
<td>CUDA 9.0 (9.0.76)</td>
<td>&gt;= 384.81</td>
<td>&gt;= 385.54</td>
</tr>
<tr>
<td>CUDA 8.0 (8.0.61 GA2)</td>
<td>&gt;= 375.26</td>
<td>&gt;= 376.51</td>
</tr>
<tr>
<td>CUDA 8.0 (8.0.44)</td>
<td>&gt;= 367.48</td>
<td>&gt;= 369.30</td>
</tr>
</tbody>
</table>
</div>
<h2 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h2><p>在准备好以下三个文件后就可以开始安装了（最好先把它们都下载下来放到U盘里，做好多次重装系统的准备）</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cuda_10.0.130_410.48_linux.run <span class="comment">#CUDA Toolkit</span></span><br><span class="line">$ cudnn-10.0-linux-x64-v7.6.5.32.tgz <span class="comment">#cuDNN for CUDA10</span></span><br><span class="line">$ NVIDIA-Linux-x86_64-440.82.run <span class="comment">#Nvidia-driver for RTX2080Ti</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>Nvidia 驱动及CUDA安装</strong></li>
</ul>
<p>首先查看是否开启了默认的 <strong>nouveau</strong> 驱动，如果输入<code>lsmod | grep nouveau</code> 没有任何提示的话则已经关闭了该驱动，若有提示，则需要首先禁用该驱动:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root]$ <span class="built_in">cp</span> /etc/modprobe.d/blacklist.conf /etc/modprobe.d/blacklist.conf.back <span class="comment">#备份原有黑名单(如果提示没有此文件的话可以在该目录下创建一个新的同名文件，然后再进行后续操作)</span></span><br><span class="line">[root]$ <span class="built_in">echo</span> -e <span class="string">&quot;blacklist nouveau\noptions nouveau modeset=0&quot;</span> &gt; /etc/modprobe.d/blacklist.conf <span class="comment">#禁用nouveau驱动</span></span><br><span class="line">[root]$ <span class="built_in">mv</span> /boot/initramfs-$(<span class="built_in">uname</span> -r).img /boot/initramfs-$(<span class="built_in">uname</span> -r).img.back <span class="comment">#备份initramfs</span></span><br><span class="line">[root]$ dracut /boot/initramfs-$(<span class="built_in">uname</span> -r).img $(<span class="built_in">uname</span> -r) --force <span class="comment">#重建initramfs</span></span><br><span class="line">[root]$ init 6 <span class="comment">#重启</span></span><br><span class="line">[root]$ <span class="built_in">cd</span> /../../ <span class="comment">#切换到驱动所在目录</span></span><br><span class="line">[root]$ sh ./NVIDIA-Linux-x86_64-440.82.run <span class="comment">#执行安装过程(安装如果卡在Verifying archive integrity... Error in check sums 00000000 000000,重新到官网上选择自己显卡型号的驱动下载再次安装即可)</span></span><br><span class="line">[root]$ nvidia-smi <span class="comment">#查看驱动是否安装成功，若顺利输出GPU信息则成功，或者切换到Toolkit的Samples中编译并运行带着的例子，显示Result=PASS则能够顺利运行CUDA程序。</span></span><br><span class="line">[root]$ sh ./cuda_10.0.130_410.48_linux.run <span class="comment">#安装CUDA Toolkit，记住不要安装里面带着的驱动</span></span><br><span class="line">[root]$ reboot <span class="comment">#安装完成重启，顺利进入图形界面～</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>cuDNN</strong>安装</li>
</ul>
<p>话不多说直接上代码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root]$ <span class="built_in">cd</span> /../../ <span class="comment">#切换到cuDNN安装包所在目录</span></span><br><span class="line">[root]$ tar -xzvf cudnn-10.0-linux-x64-v7.6.5.32.tgz <span class="comment">#解压cudnn到当前文件夹</span></span><br><span class="line">[root]$ <span class="built_in">cp</span> cuda/include/cudnn.h /usr/local/cuda-10.0/include/</span><br><span class="line">[root]$ <span class="built_in">cp</span> cuda/lib64/libcudnn* /usr/local/cuda/lib64/</span><br><span class="line">[root]$ <span class="built_in">chmod</span> a+r /usr/local/cuda-10.0/include/cudnn.h /usr/local/cuda/lib64/libcudnn*</span><br><span class="line"><span class="comment"># 系统环境下解决：以下两步为解决tensorflow运行中找不到链接文件的问题，如果CUDA版本不同请自主更改系统路径</span></span><br><span class="line">[root]$ <span class="built_in">cp</span> /usr/local/cuda-10.0/lib64/libcublas.so.10.0 /usr/local/lib/libcublas.so.10.0 &amp;&amp; sudo ldconfig</span><br><span class="line">[root]$ <span class="built_in">cp</span> /usr/local/cuda-10.0/lib64/libcufft.so.10.0 /usr/local/lib/libcufft.so.10.0 &amp;&amp; sudo ldconfig</span><br><span class="line"><span class="comment"># Conda环境下解决：</span></span><br><span class="line">[root]$ conda install cudatoolkit=10.0 -c https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/linux-64/ <span class="comment"># 解决思路：在conda环境中重新安装cudatoolkit和cudnn</span></span><br><span class="line">[root]$ conda install cudnn==7.6.5 -c https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/linux-64/ <span class="comment"># </span></span><br><span class="line">[username]$ vim ~/.bashrc <span class="comment">#个人账户下CUDA相关环境变量的配置</span></span><br><span class="line"><span class="comment">#--------------------------------------------------#</span></span><br><span class="line">CUDA_HOME=/usr/local/cuda-10.0</span><br><span class="line">PATH=<span class="variable">$PATH</span>:/usr/local/cuda-10.0/bin</span><br><span class="line">LD_LIBRARY_PATH=/usr/local/cuda-10.0/lib64</span><br><span class="line"><span class="built_in">export</span> CUDA_HOME PATH LD_LIBRARY_PATH</span><br><span class="line"><span class="comment">#--------------------------------------------------#</span></span><br><span class="line">[username]$ <span class="built_in">source</span> ~/.bashrc <span class="comment">#配置完成后立即更新环境变量</span></span><br></pre></td></tr></table></figure>
<ul>
<li>查看是否安装成功</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root]$ nvcc --version <span class="comment">#查看编译器及CUDA版本</span></span><br><span class="line">[root]$ nvidia-smi <span class="comment">#查看GPU信息、驱动版本</span></span><br><span class="line">[root]$ <span class="built_in">cat</span> /usr/local/cuda/include/cudnn.h | grep CUDNN_MAJOR -A 2 <span class="comment">#查看cuDNN版本</span></span><br></pre></td></tr></table></figure>
<h2 id="进阶设置"><a href="#进阶设置" class="headerlink" title="进阶设置"></a>进阶设置</h2><h3 id="1-安装温度监控器"><a href="#1-安装温度监控器" class="headerlink" title="1.  安装温度监控器"></a>1.  安装温度监控器</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root]$ yum install lm_sensors <span class="comment">#下载安装lm_sensors插件</span></span><br><span class="line">[root]$ /usr/sbin/sensors-detect <span class="comment">#运行sensors-detect配置程序</span></span><br><span class="line">[notroot]$ sensors <span class="comment">#查看已允许检测设备的当前状态</span></span><br></pre></td></tr></table></figure>
<h3 id="2-手动控制-GPU-风扇转速"><a href="#2-手动控制-GPU-风扇转速" class="headerlink" title="2. 手动控制 GPU 风扇转速"></a>2. 手动控制 <strong>GPU</strong> 风扇转速</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root]$ <span class="built_in">cp</span> /etc/X11/xorg.conf /etc/X11/xorg.conf.back <span class="comment">#备份原有xorg配置文件</span></span><br><span class="line">[root]$ vim xorg.conf</span><br><span class="line"><span class="comment">#-----------File Start--------------#</span></span><br><span class="line">Section <span class="string">&quot;Device&quot;</span></span><br><span class="line">       Identifier  <span class="string">&quot;Videocard0&quot;</span></span><br><span class="line">       Driver      <span class="string">&quot;nvidia&quot;</span></span><br><span class="line">       Option <span class="string">&quot;Coolbits&quot;</span> <span class="string">&quot;4&quot;</span> <span class="comment">#增加该行内容后重启，可在Applications-other-Nvidia X Server Settings-GPU-Thermal Settings</span></span><br><span class="line">EndSection</span><br><span class="line"><span class="comment">#-----------File End--------------#</span></span><br><span class="line">[root]$ nvidia-settings -a <span class="string">&quot;[gpu:0]/GPUFanControlState=0&quot;</span> <span class="comment">#恢复GPU转速随温度控制</span></span><br></pre></td></tr></table></figure>
<h3 id="3-常用-GPU-相关命令"><a href="#3-常用-GPU-相关命令" class="headerlink" title="3. 常用 GPU 相关命令"></a>3. 常用 GPU 相关命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ nvidia-smi -L <span class="comment">#列出所有可使用的GPU设备</span></span><br><span class="line">$ nvidia-smi -l <span class="comment">#与nvidia-smi功能相同但带有自动刷新功能（不清空输出缓存区）</span></span><br><span class="line">$ nvidia-smi -q <span class="comment">#查看所有GPU设备信息</span></span><br><span class="line">$ nvidia-smi –pm 0/1 <span class="comment">#设置持久模式：0/DISABLED,1/ENABLED</span></span><br><span class="line">$ nvidia-smi –e 0/1 <span class="comment">#切换ECC支持：0/DISABLED, 1/ENABLED</span></span><br><span class="line">$ nvidia-smi –p 0/1 <span class="comment">#重置ECC错误计数：0/VOLATILE, 1/AGGREGATE</span></span><br><span class="line">$ nvidia-smi –c <span class="comment">#设置计算应用模式：0/DEFAULT,1/EXCLUSIVE_PROCESS,2/PROHIBITED</span></span><br><span class="line">$ nvidia-smi –r <span class="comment">#GPU复位</span></span><br><span class="line">$ nvidia-smi –vm <span class="comment">#设置GPU虚拟化模式</span></span><br><span class="line">$ nvidia-smi –ac xxx,xxx <span class="comment">#设置GPU运行的工作频率。e.g. nvidia-smi –ac2000,800</span></span><br><span class="line">$ nvidia-smi –rac <span class="comment">#0/1 将时钟频率重置为默认值</span></span><br><span class="line">$ nvidia-smi –acp <span class="comment">#切换-ac和-rac的权限要求，0/UNRESTRICTED, 1/RESTRICTED</span></span><br><span class="line">$ nvidia-smi –pl <span class="comment">#指定最大电源管理限制（瓦特）</span></span><br><span class="line">$ nvidia-smi –am 0/1 <span class="comment">#启用或禁用计数模式，0/DISABLED,1/ENABLED</span></span><br><span class="line">$ nvidia-smi –caa <span class="comment">#清除缓冲区中的所有已记录PID，0/DISABLED,1/ENABLED</span></span><br></pre></td></tr></table></figure>
<h3 id="4-动态监控"><a href="#4-动态监控" class="headerlink" title="4. 动态监控"></a>4. 动态监控</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#实际上，可以使用watch命令实现动态监控(不需要root权限)</span></span><br><span class="line">$ watch -n 1 sensors <span class="comment"># 1表示每隔一秒刷新sensors</span></span><br><span class="line">$ watch -n 1 nvidia-smi <span class="comment">#同理可动态监控GPU运行状态，以判断Tensorfow是否正确使用了GPU运行</span></span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>装机</category>
      </categories>
      <tags>
        <tag>CUDA及cuDNN下载与安装</tag>
      </tags>
  </entry>
  <entry>
    <title>Dell工作站CentOS-7装机</title>
    <url>/2020/06/07/installation/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="工作站CentOS7装机"><a href="#工作站CentOS7装机" class="headerlink" title="工作站CentOS7装机"></a>工作站CentOS7装机</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>本次装机的工作站型号为<strong>Dell Precision T3630</strong>，搭载有<strong>Intel(R)Xoen@E2286G</strong>处理器（6核心/12线程，4.00GHz），512G固态硬盘、1T机械硬盘以及<strong>RTX2080Ti</strong>显卡一张（单涡轮）。文章将分为以下几部分介绍：<br><span id="more"></span></p>
<ol>
<li><strong>CentOS7</strong>系统安装；</li>
<li>显卡驱动、<strong>CUDA Toolkit</strong>以及<strong>cuDNN</strong>安装；</li>
<li>深度学习环境配置，诸如常用的框架 <strong>Tensorflow</strong>、<strong>Keras</strong>等；</li>
</ol>
<p><em>本章节主要介绍第一部分内容，其它内容将在其它日志中更新，欢迎关注。需要注意的是除系统iso文件外，其他所有安装包作者均在安装完的系统内部下载的（主机插了网线，下载速度比较快，卧室离路由器太远收不到5GHz的信号，2.5GHz下载实在是太慢了），如果没有有线网络的小伙伴可以考虑将手机接到主机上联网下载，而且这台工作站支持Type-c接口哦。</em></p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p><em>准备工作</em>：一个6G及以上内存的U盘（用于镜像文件的制作，CentOS7安装文件大小为4.8G），一个U盘启动制作工具以及CentOS-7-x86_64-xxx.iso镜像文件一个。<br>U盘制作工具使用<a href="https://cn.ultraiso.net/xiazai.html">UltraISO</a>，镜像文件使用国内的<a href="http://mirrors.aliyun.com/centos/7/isos/x86_64/">阿里云源</a>下载，作者安装的是DVD版本（<a href="http://mirrors.aliyun.com/centos/7/isos/x86_64/CentOS-7-x86_64-DVD-2003.iso">CentOS-7-x86_64-DVD-2003.iso</a>），文件大小为4.5G，此安装包内能够满足一般用户的需求，并且在安装过程中可以根据实际需要对packages进行选择。选择此版本的原因是保持与实验室工作站环境的一致性，尽量减少代码移植过程中出现的问题（但人工智能的代码的可移植性是比较差的，其主要与<em>Tensorflow</em>、<em>Keras</em>等框架的版本相关）。</p>
<h2 id="CentOS7-64bit系统安装"><a href="#CentOS7-64bit系统安装" class="headerlink" title="CentOS7-64bit系统安装"></a>CentOS7-64bit系统安装</h2><h3 id="U盘启动制作"><a href="#U盘启动制作" class="headerlink" title="U盘启动制作"></a>U盘启动制作</h3><ol>
<li>下载并安装UltraISO（<a href="https://cn.ultraiso.net/xiazai.html">下载地址</a>）；</li>
<li>下载CentosOS-7镜像文件（<a href="http://mirrors.aliyun.com/centos/7/isos/x86_64/">下载地址</a>），选择DVD版本（<a href="http://mirrors.aliyun.com/centos/7/isos/x86_64/CentOS-7-x86_64-DVD-2003.iso">CentOS-7-x86_64-DVD-2003.iso</a>）；</li>
<li>备用电脑中插入U盘（制作启动U盘需要将其格式化，所以先要备份好U盘中的原始数据）；</li>
<li>打开UltraISO程序—-<strong>继续试用</strong>；<br><img src="/2020/06/07/installation/ultraiso_enter.png" alt="UltraISO"></li>
<li>单击左上角<strong>文件</strong>—-<strong>打开</strong>；<br><img src="/2020/06/07/installation/ultraiso_open.png" alt="UltraISOstart"></li>
<li>选择下载好的iso文件；<br><img src="/2020/06/07/installation/ultraiso_select.png" alt="SelectISO"></li>
<li><strong>启动</strong>—-<strong>写入硬盘映像</strong><br><img src="/2020/06/07/installation/ultraiso_start.png" alt="WriteSelect"></li>
<li>在<strong>硬盘驱动器</strong>一栏选择自己的U盘，其他设置保持默认，然后单击<strong>写入</strong>开始U盘启动制作过程；<br><img src="/2020/06/07/installation/ultraiso_write.png" alt="WriteToUdisk"></li>
<li>写入完成后我们可以看到U盘盘符的名字有些奇怪(UltraISO软件问题，使用其他U盘启动制作工具可能会解决该问题)，如果直接用它安装系统会出现错误，这时我们要修改U盘的盘符(U盘处右键—-属性)为引号内的内容“ <strong>CENTOS7</strong> ”（必须为大写）；<br><img src="/2020/06/07/installation/u_modify.png" alt="ModifyU"></li>
<li>然后进入<em>U盘/EFI/BOOT</em>，在目录中找到grub.cfg文件并打开，将其中所有的 <strong>CentOS\x207\x20x86_64</strong> 替换为 <strong>CENTOS7</strong>（与U盘盘符保持一致），这样启动盘就制作完成了。<br><img src="/2020/06/07/installation/grub.png" alt="Grub"></li>
</ol>
<h3 id="系统安装"><a href="#系统安装" class="headerlink" title="系统安装"></a>系统安装</h3><p> 作者使用的主机没有预装其它系统，准备只安装 <strong>CentOS7</strong> 用于科研。</p>
<ol>
<li>启动主机，在显示器显示 <strong><em>DELL</em></strong> 商标时 按下 <strong>F2</strong> 进入 <strong>BIOS</strong> 设置界面；<br><img src="/2020/06/07/installation/f2.jpg" alt="F2"></li>
<li>在 <strong>Settings—-General—-Boot Squence</strong> 右侧选择 <strong>UEFI</strong> 模式并点击下方的 <strong>Apply</strong> 按钮；<br><img src="/2020/06/07/installation/uefi.jpg" alt="BOOT"></li>
<li>在 <strong>Settings—-System Configuration—-SATA Operation</strong> 右侧选择 <strong>AHCI</strong> （默认为 <strong>RAID ON</strong>）使硬盘处于可发现模式，点击下方的 <strong>Apply</strong> 按钮；<br><img src="/2020/06/07/installation/ahci.jpg" alt="AHCI"></li>
<li>按下 <strong>Esc</strong> 保存设置，重启主机并在 <strong><em>DELL</em></strong> 商标界面按下 <strong>F12</strong>进入启动盘选择界面 ，确认 <strong>Boot mode</strong> 是否为 <strong>UEFI</strong> 以及 <strong>Secure Boot</strong> 是否为 <strong>off</strong> 状态，若状态有误则返回 <strong>BIOS</strong> 重新设置；<br><img src="/2020/06/07/installation/f10.jpg" alt="SELECTU"></li>
<li>若没有错误，选择 <strong>UEFI BOOT: </strong>下方的U盘并按回车、进入；</li>
<li>在安装界面选择 <strong>Install CentOS7</strong>；<br><img src="/2020/06/07/installation/install_centos7.jpg" alt="CENTOS7"></li>
<li><strong>SOFTWARE SELECTION</strong> 选择 <strong>GNOME Desktop</strong>，右侧可自定义需要安装的软件包以及环境；<br><img src="/2020/06/07/installation/selection.jpg" alt="SOFTWAVESELECTION"></li>
<li><strong>INSTALLATION DESTINATION</strong>  选择512G的固态硬盘并选择自动分区（在硬盘选择界面下方 <strong>Other Storage Options—-Partitioning</strong> 处选择 <strong>Automatically configure partitioning</strong> ）</li>
<li><strong>Begin Installation</strong>；</li>
<li>系统安装过程中需要完成用户信息的设置，等待完成后 <strong>Reboot</strong>进入系统。</li>
</ol>
<h2 id="系统环境配置"><a href="#系统环境配置" class="headerlink" title="系统环境配置"></a>系统环境配置</h2><p>在 <strong>CentOS</strong> 使用过程中，我们经常需要从网络上下载各种安装包， <strong>yum(CentOS)</strong> 或 <strong>apt-get(Ubuntu)</strong> 是比较常用的方式，但是系统自带的安装源服务器都在国外，下载速度非常慢，因此我们需要使用国内的诸如清华源、豆瓣源、阿里源等加速下载，下面介绍一些简单的下载加速技巧。<br>（以下操作均需要在 <strong>root</strong> 权限下运行）首先，查看系统是否安装有 <strong>wget</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ wget --version</span><br></pre></td></tr></table></figure>
<p>如果未安装的话首先使用 <strong>yum</strong> 进行安装（）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root]$ yum -y install wget</span><br><span class="line"><span class="comment"># -y 表示安装的自动选择</span></span><br></pre></td></tr></table></figure>
<p>再次查询即可看到 <strong>wget</strong> 的安装位置、版本等信息。<br>然后备份系统原有的 <strong>yum</strong> 下载源并下载阿里源、生成缓存：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root] <span class="built_in">cp</span> /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.bak</span><br><span class="line">[root] wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo <span class="comment">#阿里云安装，也可以安装网易等源</span></span><br><span class="line">[root] yum makecache <span class="comment">#生成缓存</span></span><br></pre></td></tr></table></figure>
<p>安装ntfs-3g以挂载ntfs格式的硬盘<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root] wget https://tuxera.com/opensource/ntfs-3g_ntfsprogs-2017.3.23.tgz</span><br><span class="line">[root] tar zxvf ntfs-3g_ntfsprogs-2017.3.23.tgz</span><br><span class="line">[root] ./configure</span><br><span class="line">[root] <span class="built_in">cd</span> ntfs-3g_ntfsprogs-2017.3.23/</span><br><span class="line">[root] make</span><br><span class="line">[root] make install</span><br><span class="line">[root] mount -t ntfs-3g /deb/sda2 /mnt/data/</span><br></pre></td></tr></table></figure><br>设置开机自动挂载硬盘</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root] <span class="built_in">cd</span> /etc</span><br><span class="line">[root] <span class="built_in">cp</span> fstab fstab.bak</span><br><span class="line">[root] vim fstab</span><br><span class="line"><span class="comment">##---file start---##</span></span><br><span class="line">/dev/sda(替换为自己的盘符)         /mnt/data(替换为自己需要挂载的路径)  ntfs-3g  defaults  0 0</span><br><span class="line"><span class="comment">##---file end--##</span></span><br></pre></td></tr></table></figure>
<p>这时就可以畅快地使用 <code>yum -y install</code>畅快地下载各种安装包啦。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>装机</category>
      </categories>
      <tags>
        <tag>CentOS系统安装</tag>
      </tags>
  </entry>
  <entry>
    <title>常用链接</title>
    <url>/2020/08/02/links/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="常用链接查询"><a href="#常用链接查询" class="headerlink" title="常用链接查询"></a>常用链接查询</h1><ul>
<li><h2 id="文献相关"><a href="#文献相关" class="headerlink" title="文献相关"></a>文献相关</h2></li>
</ul>
<ol>
<li><p><strong>arxiv</strong>文献下载过慢问题：</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[Answer] 文献链接中 https://arxiv.org 换成 http://xxx.itp.ac.cn</span><br></pre></td></tr></table></figure>
</li>
<li><p>利用<strong>doi</strong>下载文献：</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[Answer] http://sci-hub.ren/</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>SEG</strong>文献下载：</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[Answer] https://library.seg.org/</span><br><span class="line">[Answer] https://ifc.cup.edu.cn <span class="comment">#CUP-VPN</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>地震勘探领域（中文）：</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[Answer] http://www.geophy.cn/CN/volumn/home.shtml <span class="comment">#地球物理学报</span></span><br><span class="line">[Answer] http://journal08.magtechjournal.com/Jwk_ogp/CN/volumn/home.shtml <span class="comment">#石油地球物理勘探</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li><h2 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h2>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[Answer] http://academictorrents.com/ <span class="comment">#种子下载，可搭配VUZE</span></span><br><span class="line">[Answer] https://pan.baidu.com/s/1rQWLNmh2RczmNkry9dfDdg <span class="comment"># CelebA  密码:v65m</span></span><br><span class="line">[Answer] https://pan.baidu.com/s/1j_JOdpjF53h_af6GSHha3w <span class="comment"># ffhq 密码:tkp5</span></span><br></pre></td></tr></table></figure>
</li>
<li><h2 id="预训练模型"><a href="#预训练模型" class="headerlink" title="预训练模型"></a>预训练模型</h2>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[Answer] <span class="comment"># inception-v4_weights_tf_dim_ordering_tf_kernels_notop.h5</span></span><br><span class="line">[Answer] <span class="comment"># inception-v4_weights_tf_dim_ordering_tf_kernels.h5</span></span><br><span class="line">[Answer] <span class="comment"># inception_v3_weights_tf_dim_ordering_tf_kernels.h5</span></span><br><span class="line">[Answer] <span class="comment"># vgg19_weights_tf_dim_ordering_tf_kernels_notop.h5</span></span><br><span class="line">[Answer] <span class="comment"># vgg19.npy</span></span><br><span class="line">[Answer] <span class="comment"># vgg16.npy</span></span><br><span class="line">[Answer] <span class="comment"># inception_v3_features.pkl (styleGAN)</span></span><br><span class="line">[Answer] <span class="comment"># karras2019stylegan-ffhq-1024x1024.pkl (styleGAN)</span></span><br></pre></td></tr></table></figure>
</li>
<li><h2 id="深度学习框架"><a href="#深度学习框架" class="headerlink" title="深度学习框架"></a>深度学习框架</h2><ol>
<li><p>Oneflow</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">https://www.oneflow.org/ <span class="comment"># official website</span></span><br><span class="line">https://github.com/Oneflow-Inc/oneflow <span class="comment"># codes</span></span><br><span class="line">https://docs.oneflow.org/ <span class="comment"># doc</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Tensorflow</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">https://tensorflow.google.cn/</span><br><span class="line">https://github.com/tensorflow/tensorflow</span><br></pre></td></tr></table></figure>
</li>
<li><p>Keras</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">https://keras.io/ <span class="comment"># official website</span></span><br><span class="line">https://github.com/keras-team/keras <span class="comment"># codes</span></span><br><span class="line">https://keras.io/zh/ <span class="comment"># doc</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Pytorch</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">https://pytorch.org/ <span class="comment"># official website</span></span><br><span class="line">https://github.com/pytorch/pytorch <span class="comment"># codes</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><ol>
<li>Blog   <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">https://www.tablesgenerator.com/markdown_tables <span class="comment"># Markdown表格生成器</span></span><br></pre></td></tr></table></figure></li>
<li>天然地震<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">http://seismo-live.org/</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>commons</category>
      </categories>
      <tags>
        <tag>链接</tag>
      </tags>
  </entry>
  <entry>
    <title>OBSpy天然地震I</title>
    <url>/2020/09/02/obspy1/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="天然地震"><a href="#天然地震" class="headerlink" title="天然地震"></a>天然地震</h1><h2 id="地震数据中Channel描述"><a href="#地震数据中Channel描述" class="headerlink" title="地震数据中Channel描述"></a>地震数据中Channel描述</h2><div class="table-container">
<table>
<thead>
<tr>
<th>Channel</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>EHZ/EHN/EHE</td>
<td>Short Period 100 sps</td>
</tr>
<tr>
<td>BHZ/BHN/BHE</td>
<td>Broad Band 20 sps</td>
</tr>
<tr>
<td>LHZ/LHN/LHE</td>
<td>Long Period 1 sps</td>
</tr>
<tr>
<td>VHZ/VHN/VHE</td>
<td>Very Long Period 0.1 sps</td>
</tr>
<tr>
<td>BCI</td>
<td>Broad Band Calibration Signal</td>
</tr>
<tr>
<td>ECI</td>
<td>Short Period Cal</td>
</tr>
<tr>
<td>LOG</td>
<td>Console Log</td>
</tr>
<tr>
<td>ACE</td>
<td>Administrative Clock Error</td>
</tr>
<tr>
<td>LCQ</td>
<td>1hz Clock Quality</td>
</tr>
<tr>
<td>OCF</td>
<td>Opaque Configuration File</td>
</tr>
</tbody>
</table>
</div>
<h2 id="天然地震数据处理包obspy教程"><a href="#天然地震数据处理包obspy教程" class="headerlink" title="天然地震数据处理包obspy教程"></a>天然地震数据处理包obspy教程</h2><p><a href="https://krischer.github.io/seismo_live_build/html/ObsPy/07_Basic_Processing_Exercise_solution_wrapper.html">obspy教程，以Tohoku-Oki:2011-03-11日本大地震为例</a></p>
<h3 id="台站数据访问方法"><a href="#台站数据访问方法" class="headerlink" title="台站数据访问方法"></a>台站数据访问方法</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> obspy</span><br><span class="line"><span class="keyword">from</span> obspy.clients.fdsn <span class="keyword">import</span> Client</span><br><span class="line"></span><br><span class="line">c_event = Client(<span class="string">&quot;IRIS&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Event time.</span></span><br><span class="line">event_time = obspy.UTCDateTime(<span class="string">&quot;2011-03-11T05:46:23.2&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Get the event information. The temporal and magnitude constraints make it unique</span></span><br><span class="line">cat = c_event.get_events(starttime=event_time - <span class="number">10</span>, endtime=event_time + <span class="number">10</span>,</span><br><span class="line">                         minmagnitude=<span class="number">9</span>)</span><br><span class="line">cat.plot()</span><br><span class="line">c = Client(<span class="string">&quot;IRIS&quot;</span>)</span><br><span class="line"><span class="comment"># Download station information at the response level!</span></span><br><span class="line">inv = c.get_stations(network=<span class="string">&quot;II&quot;</span>, station=<span class="string">&quot;TLY&quot;</span>, location=<span class="string">&quot;*&quot;</span>, channel=<span class="string">&quot;BH?&quot;</span>,</span><br><span class="line">                     starttime=event_time - <span class="number">60</span>, endtime=event_time + <span class="number">3600</span>,</span><br><span class="line">                     level=<span class="string">&quot;response&quot;</span>)</span><br><span class="line">inv.plot()</span><br><span class="line"><span class="comment"># Download 3 component waveforms.</span></span><br><span class="line"><span class="comment"># The unit of startime and endtime is seconds.</span></span><br><span class="line">st = c.get_waveforms(network=<span class="string">&quot;II&quot;</span>, station=<span class="string">&quot;TLY&quot;</span>, location=<span class="string">&quot;*&quot;</span>,</span><br><span class="line">                     channel=<span class="string">&quot;BH?&quot;</span>, starttime=event_time - <span class="number">60</span>,</span><br><span class="line">                     endtime=event_time + <span class="number">3600</span>)</span><br><span class="line"><span class="comment"># Build-in plot method</span></span><br><span class="line">st[<span class="number">0</span>].plot()</span><br><span class="line"><span class="comment"># Get the data</span></span><br><span class="line">traces = st[<span class="number">0</span>].data</span><br></pre></td></tr></table></figure>
<p>以上代码中，<code>cat</code>、<code>inv</code>和<code>st</code>的<code>plot</code>方法分别绘制了地震事件、台站位置信息以及波形信息。<br><img src="/2020/09/02/obspy1/cat.png" alt="cat"><br><img src="/2020/09/02/obspy1/inv.png" alt="inv"><br><img src="/2020/09/02/obspy1/trace.png" alt="trace"></p>
<h3 id="利用MassDownloader下载数据"><a href="#利用MassDownloader下载数据" class="headerlink" title="利用MassDownloader下载数据"></a>利用MassDownloader下载数据</h3><p><a href="https://docs.obspy.org/packages/autogen/obspy.clients.fdsn.mass_downloader.html">台站数据下载教程(obspy.clients.fdsn.mass_downloader)</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> obspy</span><br><span class="line"><span class="keyword">from</span> obspy.clients.fdsn.mass_downloader <span class="keyword">import</span> CircularDomain, \</span><br><span class="line">    Restrictions, MassDownloader</span><br><span class="line"></span><br><span class="line">origin_time = obspy.UTCDateTime(<span class="number">2011</span>, <span class="number">3</span>, <span class="number">11</span>, <span class="number">5</span>, <span class="number">47</span>, <span class="number">32</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Circular domain around the epicenter. This will download all data between</span></span><br><span class="line"><span class="comment"># 70 and 90 degrees distance from the epicenter. This module also offers</span></span><br><span class="line"><span class="comment"># rectangular and global domains. More complex domains can be defined by</span></span><br><span class="line"><span class="comment"># inheriting from the Domain class.</span></span><br><span class="line">domain = CircularDomain(latitude=<span class="number">37.52</span>, longitude=<span class="number">143.04</span>,</span><br><span class="line">                        minradius=<span class="number">70.0</span>, maxradius=<span class="number">90.0</span>)</span><br><span class="line"></span><br><span class="line">restrictions = Restrictions(</span><br><span class="line">    <span class="comment"># Get data from 5 minutes before the event to one hour after the</span></span><br><span class="line">    <span class="comment"># event. This defines the temporal bounds of the waveform data.</span></span><br><span class="line">    starttime=origin_time - <span class="number">5</span> * <span class="number">60</span>,</span><br><span class="line">    endtime=origin_time + <span class="number">3600</span>,</span><br><span class="line">    <span class="comment"># You might not want to deal with gaps in the data. If this setting is</span></span><br><span class="line">    <span class="comment"># True, any trace with a gap/overlap will be discarded.</span></span><br><span class="line">    reject_channels_with_gaps=<span class="literal">True</span>,</span><br><span class="line">    <span class="comment"># And you might only want waveforms that have data for at least 95 % of</span></span><br><span class="line">    <span class="comment"># the requested time span. Any trace that is shorter than 95 % of the</span></span><br><span class="line">    <span class="comment"># desired total duration will be discarded.</span></span><br><span class="line">    minimum_length=<span class="number">0.95</span>,</span><br><span class="line">    <span class="comment"># No two stations should be closer than 10 km to each other. This is</span></span><br><span class="line">    <span class="comment"># useful to for example filter out stations that are part of different</span></span><br><span class="line">    <span class="comment"># networks but at the same physical station. Settings this option to</span></span><br><span class="line">    <span class="comment"># zero or None will disable that filtering.</span></span><br><span class="line">    minimum_interstation_distance_in_m=<span class="number">10E3</span>,</span><br><span class="line">    <span class="comment"># Only HH or BH channels. If a station has HH channels, those will be</span></span><br><span class="line">    <span class="comment"># downloaded, otherwise the BH. Nothing will be downloaded if it has</span></span><br><span class="line">    <span class="comment"># neither. You can add more/less patterns if you like.</span></span><br><span class="line">    channel_priorities=[<span class="string">&quot;HH[ZNE]&quot;</span>, <span class="string">&quot;BH[ZNE]&quot;</span>],</span><br><span class="line">    <span class="comment"># Location codes are arbitrary and there is no rule as to which</span></span><br><span class="line">    <span class="comment"># location is best. Same logic as for the previous setting.</span></span><br><span class="line">    location_priorities=[<span class="string">&quot;&quot;</span>, <span class="string">&quot;00&quot;</span>, <span class="string">&quot;10&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># No specified providers will result in all known ones being queried.</span></span><br><span class="line">mdl = MassDownloader()</span><br><span class="line"><span class="comment"># The data will be downloaded to the ``./waveforms/`` and ``./stations/``</span></span><br><span class="line"><span class="comment"># folders with automatically chosen file names.</span></span><br><span class="line">mdl.download(domain, restrictions, mseed_storage=<span class="string">&quot;waveforms&quot;</span>,</span><br><span class="line">             stationxml_storage=<span class="string">&quot;stations&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>以上代码会将时间<code>origin_time</code>之前5分钟、之后1小时以内，区域范围为圆形的<code>domain</code>（以经纬度以及环形区域为限定）的数据下载到当前目录下的<code>./waveform</code>文件夹中，台站数据则存储在<code>./stations</code>中。</p>
<h3 id="本地文件读取-以-mseed为例-及显示"><a href="#本地文件读取-以-mseed为例-及显示" class="headerlink" title="本地文件读取(以.mseed为例)及显示"></a>本地文件读取(以.mseed为例)及显示</h3><p>演示三通道数据读取与显示<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> obspy</span><br><span class="line"><span class="keyword">from</span> obspy.core <span class="keyword">import</span> read</span><br><span class="line">path = <span class="string">r&#x27;./waveforms/&#x27;</span></span><br><span class="line">tc = read(path+<span class="string">&#x27;AG.HHAR.00.HHE__20110311T054232Z__20110311T064732Z.mseed&#x27;</span>)</span><br><span class="line">tc += read(path+<span class="string">&#x27;AG.HHAR.00.HHN__20110311T054232Z__20110311T064732Z.mseed&#x27;</span>)</span><br><span class="line">tc += read(path+<span class="string">&#x27;AG.HHAR.00.HHZ__20110311T054232Z__20110311T064732Z.mseed&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(tc)</span><br><span class="line"><span class="comment"># Save plot to file</span></span><br><span class="line">tc.plot(outfile=<span class="string">&#x27;test.png&#x27;</span>)</span><br></pre></td></tr></table></figure><br>输出：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span> Trace(s) <span class="keyword">in</span> Stream:</span><br><span class="line">AG.HHAR<span class="number">.00</span>.HHE | <span class="number">2011</span>-03-11T05:<span class="number">42</span>:<span class="number">32.000000</span>Z - <span class="number">2011</span>-03-11T06:<span class="number">47</span>:<span class="number">32.000000</span>Z | <span class="number">100.0</span> Hz, <span class="number">390001</span> samples</span><br><span class="line">AG.HHAR<span class="number">.00</span>.HHN | <span class="number">2011</span>-03-11T05:<span class="number">42</span>:<span class="number">32.000000</span>Z - <span class="number">2011</span>-03-11T06:<span class="number">47</span>:<span class="number">32.000000</span>Z | <span class="number">100.0</span> Hz, <span class="number">390001</span> samples</span><br><span class="line">AG.HHAR<span class="number">.00</span>.HHZ | <span class="number">2011</span>-03-11T05:<span class="number">42</span>:<span class="number">32.000000</span>Z - <span class="number">2011</span>-03-11T06:<span class="number">47</span>:<span class="number">32.000000</span>Z | <span class="number">100.0</span> Hz, <span class="number">390001</span> samples</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">当流中的Traces过多时，print(stream)只会打印部分Trace，此时可通过print(stream.__str__(extended=True))来打印流中的所有Trace。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure></p>
<p>基础绘图:<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Basic plotting</span></span><br><span class="line">tc.plot()</span><br></pre></td></tr></table></figure><br><img src="/2020/09/02/obspy1/tc.png" alt="tc"></p>
<p>自定义绘图:<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Customized Plots</span></span><br><span class="line">dt = tc[<span class="number">0</span>].stats.starttime</span><br><span class="line">tc.plot(color=<span class="string">&#x27;red&#x27;</span>, number_of_ticks=<span class="number">7</span>,</span><br><span class="line">       tick_rotation=<span class="number">5</span>, tick_format=<span class="string">&#x27;%I:%M %p&#x27;</span>,</span><br><span class="line">       starttime=dt + <span class="number">60</span>*<span class="number">60</span>, endtime=dt + <span class="number">60</span>*<span class="number">60</span> + <span class="number">120</span>)</span><br></pre></td></tr></table></figure><br><img src="/2020/09/02/obspy1/tc_customized.png" alt="tc"></p>
<p>使用Matplotlib进行自定义绘图：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Custom Plotting using Matplotlib</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">fig = plt.figure()</span><br><span class="line">ax = fig.add_subplot(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">ax.plot(tc[<span class="number">0</span>].times(<span class="string">&quot;matplotlib&quot;</span>), tc[<span class="number">0</span>].data, <span class="string">&quot;b-&quot;</span>)</span><br><span class="line">ax.xaxis_date()</span><br><span class="line">fig.autofmt_xdate()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><br><img src="/2020/09/02/obspy1/tc_customized_mat.png" alt="tc"></p>
<p>按小时绘制一整天道记录(文件中必须含有整天的数据)：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tc = read(path+<span class="string">&#x27;BW.ALTM..EHE__20120101T000000Z__20120102T000000Z.mseed&#x27;</span>)</span><br><span class="line">tc.plot(<span class="built_in">type</span>=<span class="string">&#x27;dayplot&#x27;</span>)</span><br></pre></td></tr></table></figure><br><img src="/2020/09/02/obspy1/tc_day.png" alt="tc"></p>
<p>plot中显示地震事件<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> obspy <span class="keyword">import</span> read</span><br><span class="line">st = read(<span class="string">&quot;./BW.ALTM..EHE__20121207T000000Z__20121208T000000Z.mseed&quot;</span>)</span><br><span class="line"><span class="comment">#st.filter(&quot;lowpass&quot;, freq=0.1, corners=2)</span></span><br><span class="line">st.plot(<span class="built_in">type</span>=<span class="string">&quot;dayplot&quot;</span>, interval=<span class="number">60</span>, right_vertical_labels=<span class="literal">False</span>,</span><br><span class="line">        vertical_scaling_range=<span class="number">5e3</span>, one_tick_per_line=<span class="literal">True</span>,</span><br><span class="line">        color=[<span class="string">&#x27;k&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;g&#x27;</span>], show_y_UTC_label=<span class="literal">False</span>,</span><br><span class="line">        events=&#123;<span class="string">&#x27;min_magnitude&#x27;</span>: <span class="number">6.5</span>&#125;)</span><br></pre></td></tr></table></figure><br><img src="/2020/09/02/obspy1/japan20121207.png" alt="tc"></p>
<h2 id="地震台站Google地图及信息查询"><a href="#地震台站Google地图及信息查询" class="headerlink" title="地震台站Google地图及信息查询"></a><a href="https://www.fdsn.org/networks/detail/II/">地震台站Google地图</a>及信息查询</h2><h3 id="Network-Codes"><a href="#Network-Codes" class="headerlink" title="Network Codes"></a>Network Codes</h3><p>地震网络编码查询：<a href="https://www.fdsn.org/networks/?initial=1">https://www.fdsn.org/networks/?initial=1</a></p>
<h3 id="Global-Seismograph-Network-IRIS-IDA"><a href="#Global-Seismograph-Network-IRIS-IDA" class="headerlink" title="Global Seismograph Network - IRIS/IDA"></a>Global Seismograph Network - IRIS/IDA</h3><h4 id="FDSN-Network-Information"><a href="#FDSN-Network-Information" class="headerlink" title="FDSN Network Information"></a>FDSN Network Information</h4><div class="table-container">
<table>
<thead>
<tr>
<th>FDSN code</th>
<th>II</th>
<th>Network name</th>
<th>Global Seismograph Network - IRIS/IDA (GSN)</th>
</tr>
</thead>
<tbody>
<tr>
<td>Start year</td>
<td>1986</td>
<td>Operated by</td>
<td>Scripps Institution of Oceanography (SIO)</td>
</tr>
<tr>
<td>End year</td>
<td>-</td>
<td>Deployment region</td>
<td>Global</td>
</tr>
<tr>
<td>Network Website</td>
<td><a href="http://ida.ucsd.edu/">http://ida.ucsd.edu/</a></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<h4 id="Stations-in-this-Network"><a href="#Stations-in-this-Network" class="headerlink" title="Stations in this Network"></a>Stations in this Network</h4><div class="table-container">
<table>
<thead>
<tr>
<th>Station Code</th>
<th>Station Name</th>
<th>Latitude</th>
<th>Longitude</th>
<th>Data Center(s)</th>
</tr>
</thead>
<tbody>
<tr>
<td>AAK</td>
<td>Ala Archa, Kyrgyzstan</td>
<td>42.6375</td>
<td>74.4942</td>
<td>IRISDMC</td>
</tr>
<tr>
<td>ABKT</td>
<td>Alibek, Turkmenistan</td>
<td>37.9304</td>
<td>58.1189</td>
<td>IRISDMC</td>
</tr>
<tr>
<td>ABPO</td>
<td>Ambohimpanompo, Madagascar</td>
<td>-19.018</td>
<td>47.229</td>
<td>IRISDMC</td>
</tr>
<tr>
<td>ALE</td>
<td>Alert, NU, Canada</td>
<td>82.5033</td>
<td>-62.35</td>
<td>IRISDMC</td>
</tr>
<tr>
<td>ARTI</td>
<td>Arti, Russia</td>
<td>56.3879</td>
<td>58.3849</td>
<td>IRISDMC</td>
</tr>
<tr>
<td>ARU</td>
<td>Arti, Russia</td>
<td>56.4302</td>
<td>58.5625</td>
<td>IRISDMC</td>
</tr>
<tr>
<td>ASCN</td>
<td>Butt Crater, Ascension Island</td>
<td>-7.9327</td>
<td>-14.3601</td>
<td>IRISDMC</td>
</tr>
<tr>
<td>BFO</td>
<td>Black Forest Observatory, Schiltach, Germany</td>
<td>48.3301</td>
<td>8.3296</td>
<td>IRISDMC</td>
</tr>
<tr>
<td>BORG</td>
<td>Borgarfjordur, Asbjarnarstadir, Iceland</td>
<td>64.7474</td>
<td>-21.3268</td>
<td>IRISDMC</td>
</tr>
<tr>
<td>BORK</td>
<td>Burabay, Kazakhstan</td>
<td>53.0461</td>
<td>70.3184</td>
<td>IRISDMC</td>
</tr>
<tr>
<td>BRVK</td>
<td>Borovoye, Kazakhstan</td>
<td>53.0581</td>
<td>70.2828</td>
<td>IRISDMC</td>
</tr>
<tr>
<td>CMLA</td>
<td>Cha de Macela, Sao Miguel Island, Azores</td>
<td>37.7637</td>
<td>-25.5243</td>
<td>IRISDMC</td>
</tr>
<tr>
<td>COCO</td>
<td>West Island, Cocos (Keeling) Islands</td>
<td>-12.1901</td>
<td>96.8349</td>
<td>IRISDMC</td>
</tr>
<tr>
<td>DGAR</td>
<td>Diego Garcia, Chagos Islands, Indian Ocean</td>
<td>-7.4121</td>
<td>72.4525</td>
<td>IRISDMC</td>
</tr>
<tr>
<td>EFI</td>
<td>Mount Kent, East Falkland Island</td>
<td>-51.6753</td>
<td>-58.0637</td>
<td>IRISDMC</td>
</tr>
<tr>
<td>ERM</td>
<td>Erimo, Hokkaido Island, Japan</td>
<td>42.015</td>
<td>143.1572</td>
<td>IRISDMC</td>
</tr>
<tr>
<td>ESK</td>
<td>Eskdalemuir, Scotland, UK</td>
<td>55.3167</td>
<td>-3.205</td>
<td>IRISDMC</td>
</tr>
<tr>
<td>FFC</td>
<td>Flin Flon, Canada</td>
<td>54.725</td>
<td>-101.9783</td>
<td>IRISDMC</td>
</tr>
<tr>
<td>GAR</td>
<td>Garm, Tajikistan</td>
<td>39.0052</td>
<td>70.3328</td>
<td>IRISDMC</td>
</tr>
<tr>
<td>HOPE</td>
<td>Hope Point, South Georgia Island</td>
<td>-54.2836</td>
<td>-36.4879</td>
<td>IRISDMC</td>
</tr>
<tr>
<td>IASL</td>
<td>Albuquerque Seismological Laboratory, N.Mex.</td>
<td>34.946201</td>
<td>-106.456703</td>
<td>IRISDMC</td>
</tr>
<tr>
<td>IBFO</td>
<td>Black Forest Observatory, Schiltach, Germany</td>
<td>48.331902</td>
<td>8.3311</td>
<td>IRISDMC</td>
</tr>
<tr>
<td>JTS</td>
<td>Las Juntas de Abangares, Costa Rica</td>
<td>10.2908</td>
<td>-84.9525</td>
<td>IRISDMC</td>
</tr>
<tr>
<td>KAPI</td>
<td>Kappang, Sulawesi, Indonesia</td>
<td>-5.0142</td>
<td>119.7517</td>
<td>IRISDMC</td>
</tr>
<tr>
<td>KDAK</td>
<td>Kodiak Island, Alaska, USA</td>
<td>57.7828</td>
<td>-152.5835</td>
<td>IRISDMC</td>
</tr>
<tr>
<td>KIV</td>
<td>Kislovodsk, Russia</td>
<td>43.9562</td>
<td>42.6888</td>
<td>IRISDMC</td>
</tr>
<tr>
<td>KURK</td>
<td>Kurchatov, Kazakhstan</td>
<td>50.7154</td>
<td>78.6202</td>
<td>IRISDMC</td>
</tr>
<tr>
<td>KWAJ</td>
<td>Kwajalein Atoll, Pacific Ocean</td>
<td>8.8019</td>
<td>167.613</td>
<td>IRISDMC</td>
</tr>
<tr>
<td>KWJN</td>
<td>Gagan, Kwajalein Atoll, Marshall Islands</td>
<td>9.2873</td>
<td>167.5369</td>
<td>IRISDMC</td>
</tr>
<tr>
<td>LVZ</td>
<td>Lovozero, Russia</td>
<td>67.8979</td>
<td>34.6514</td>
<td>IRISDMC</td>
</tr>
<tr>
<td>MBAR</td>
<td>Mbarara, Uganda</td>
<td>-0.6019</td>
<td>30.7382</td>
<td>IRISDMC</td>
</tr>
<tr>
<td>MSEY</td>
<td>Mahe, Seychelles</td>
<td>-4.6737</td>
<td>55.4792</td>
<td>IRISDMC</td>
</tr>
<tr>
<td>MSVF</td>
<td>Monasavu, Fiji</td>
<td>-17.7448</td>
<td>178.0528</td>
<td>IRISDMC</td>
</tr>
<tr>
<td>NIL</td>
<td>Nilore, Pakistan</td>
<td>33.6506</td>
<td>73.2686</td>
<td>IRISDMC</td>
</tr>
<tr>
<td>NNA</td>
<td>Nana, Peru</td>
<td>-11.9875</td>
<td>-76.8422</td>
<td>IRISDMC</td>
</tr>
<tr>
<td>NRIL</td>
<td>Norilsk, Russia</td>
<td>69.5049</td>
<td>88.4414</td>
<td>IRISDMC</td>
</tr>
<tr>
<td>NVS</td>
<td>Novosibirsk, Russia</td>
<td>54.8404</td>
<td>83.2346</td>
<td>IRISDMC</td>
</tr>
<tr>
<td>OBN</td>
<td>Obninsk, Russia</td>
<td>55.1146</td>
<td>36.5674</td>
<td>IRISDMC</td>
</tr>
<tr>
<td>PALK</td>
<td>Pallekele, Sri Lanka</td>
<td>7.2728</td>
<td>80.7022</td>
<td>IRISDMC</td>
</tr>
<tr>
<td>PFO</td>
<td>Pinon Flat, California, USA</td>
<td>33.6092</td>
<td>-116.4553</td>
<td>IRISDMC</td>
</tr>
<tr>
<td>RAYN</td>
<td>Ar Rayn, Saudi Arabia</td>
<td>23.5225</td>
<td>45.5032</td>
<td>IRISDMC</td>
</tr>
<tr>
<td>RPN</td>
<td>Rapanui, Easter Island, Chile</td>
<td>-27.1267</td>
<td>-109.3344</td>
<td>IRISDMC</td>
</tr>
<tr>
<td>SACV</td>
<td>Santiago Island, Cape Verde</td>
<td>14.9702</td>
<td>-23.6085</td>
<td>IRISDMC</td>
</tr>
<tr>
<td>SHEL</td>
<td>Horse Pasture, St. Helena Island</td>
<td>-15.9594</td>
<td>-5.7455</td>
<td>IRISDMC</td>
</tr>
<tr>
<td>SIMI</td>
<td>Simiganj, Tajikistan</td>
<td>38.6585</td>
<td>69.0083</td>
<td>IRISDMC</td>
</tr>
<tr>
<td>SUR</td>
<td>Sutherland, South Africa</td>
<td>-32.3797</td>
<td>20.8117</td>
<td>IRISDMC</td>
</tr>
<tr>
<td>TAU</td>
<td>Hobart, Tasmania, Australia</td>
<td>-42.9099</td>
<td>147.3204</td>
<td>IRISDMC</td>
</tr>
<tr>
<td>TLY</td>
<td>Talaya, Russia</td>
<td>51.6807</td>
<td>103.6438</td>
<td>IRISDMC</td>
</tr>
<tr>
<td>UOSS</td>
<td>Univ. of Sharjah, Sharjah, United Arab Emirates</td>
<td>24.9453</td>
<td>56.2042</td>
<td>IRISDMC</td>
</tr>
<tr>
<td>WRAB</td>
<td>Tennant Creek, NT, Australia</td>
<td>-19.9336</td>
<td>134.36</td>
<td>IRISDMC</td>
</tr>
<tr>
<td>XBFO</td>
<td>Black Forest Observatory, Schiltach, Germany</td>
<td>48.3301</td>
<td>8.3296</td>
<td>IRISDMC</td>
</tr>
<tr>
<td>XPF</td>
<td>Pinon Flat, California, USA</td>
<td>33.6092</td>
<td>-116.4533</td>
<td>IRISDMC</td>
</tr>
<tr>
<td>XPFO</td>
<td>Pinon Flat, California, USA</td>
<td>33.6107</td>
<td>-116.4555</td>
<td>IRISDMC</td>
</tr>
</tbody>
</table>
</div>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>obspy</category>
      </categories>
      <tags>
        <tag>天然地震</tag>
      </tags>
  </entry>
  <entry>
    <title>OBSpy天然地震II</title>
    <url>/2020/09/03/obspy2/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="OBSpy教程之获取地震事件"><a href="#OBSpy教程之获取地震事件" class="headerlink" title="OBSpy教程之获取地震事件"></a>OBSpy教程之获取地震事件</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> obspy <span class="keyword">import</span> UTCDateTime</span><br><span class="line"><span class="keyword">from</span> obspy.geodetics.flinnengdahl <span class="keyword">import</span> FlinnEngdahl</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_events</span>(<span class="params">starttime, endtime, minmagnitude</span>):</span><br><span class="line">    <span class="keyword">from</span> obspy.clients.fdsn <span class="keyword">import</span> Client</span><br><span class="line">    c = Client(<span class="string">&quot;IRIS&quot;</span>)</span><br><span class="line">    events = c.get_events(starttime=starttime,</span><br><span class="line">                          endtime=endtime,</span><br><span class="line">                          minmagnitude=minmagnitude)</span><br><span class="line">    <span class="keyword">return</span> events</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_region_and_mag</span>(<span class="params">event</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">hasattr</span>(event, <span class="string">&quot;preferred_origin&quot;</span>):</span><br><span class="line">    <span class="comment"># Get the time from the preferred origin, alternatively the first</span></span><br><span class="line">    <span class="comment"># origin.</span></span><br><span class="line">        origin = event.preferred_origin()</span><br><span class="line">        <span class="keyword">if</span> origin <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> event.origins:</span><br><span class="line">                origin = event.origins[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        time = origin.time</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Do the same for the magnitude.</span></span><br><span class="line">        mag = event.preferred_magnitude()</span><br><span class="line">        <span class="keyword">if</span> mag <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> event.magnitudes:</span><br><span class="line">                mag = event.magnitudes[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">if</span> mag <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            mag = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">        	<span class="comment"># mag.mag/mag.magnitude_type:获取震级、震级单位类型</span></span><br><span class="line">            mag = <span class="string">&quot;%.1f %s&quot;</span> % (mag.mag, mag.magnitude_type)</span><br><span class="line">		<span class="comment"># 根据经纬度获取地区名</span></span><br><span class="line">        region = FlinnEngdahl().get_region(origin.longitude,</span><br><span class="line">                                           origin.latitude)</span><br><span class="line">        <span class="comment">#or region = event.event_descriptions[0].text</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> region, mag, time</span><br><span class="line"></span><br><span class="line">starttime = UTCDateTime(<span class="string">&#x27;2019-08-31T23:59:59.840000Z&#x27;</span>)</span><br><span class="line">endtime = UTCDateTime(<span class="string">&#x27;2020-08-31T23:59:59.840000Z&#x27;</span>)</span><br><span class="line">minmagnitude = <span class="number">6.5</span></span><br><span class="line">events = get_events(starttime, endtime, minmagnitude)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="built_in">print</span>(events)</span><br><span class="line">31 Event(s) <span class="keyword">in</span> Catalog:</span><br><span class="line">2020-08-30T21:20:29.655000Z |  +0.769,  -29.833 | 6.5 mww</span><br><span class="line">2020-08-21T04:09:52.276000Z |  -6.670, +123.493 | 6.9 mww</span><br><span class="line">...</span><br><span class="line">2019-09-25T23:46:43.029000Z |  -3.460, +128.368 | 6.5 Mww</span><br><span class="line">2019-09-01T15:54:20.411000Z | -20.360, -178.567 | 6.6 mww</span><br><span class="line">To see all events call <span class="string">&#x27;print(CatalogObject.__str__(print_all=True))&#x27;</span></span><br><span class="line">&gt;&gt;&gt; <span class="keyword">for</span> i <span class="keyword">in</span> range(len(events)):</span><br><span class="line">....region, mag, time = get_region_and_mag(events[i])</span><br><span class="line">....<span class="built_in">print</span>(region, mag, time)</span><br><span class="line">CENTRAL MID-ATLANTIC RIDGE 6.5 mww 2020-08-30T21:20:29.655000Z</span><br><span class="line">BANDA SEA 6.9 mww 2020-08-21T04:09:52.276000Z</span><br><span class="line">SOUTHERN SUMATRA, INDONESIA 6.9 mww 2020-08-18T22:29:24.731000Z</span><br><span class="line">SOUTHERN SUMATRA, INDONESIA 6.8 mww 2020-08-18T22:23:59.478000Z</span><br><span class="line">SAMAR, PHILIPPINES 6.6 mww 2020-08-18T00:03:48.698000Z</span><br><span class="line">ALASKA PENINSULA 7.8 Mww 2020-07-22T06:12:44.593000Z</span><br><span class="line">EASTERN NEW GUINEA REG., P.N.G. 7.0 mww 2020-07-17T02:50:22.162000Z</span><br><span class="line">JAVA SEA 6.7 Mww 2020-07-06T22:54:47.897000Z</span><br><span class="line">NEAR COAST OF OAXACA, MEXICO 7.4 mww 2020-06-23T15:29:04.329000Z</span><br><span class="line">SOUTH OF KERMADEC ISLANDS 7.4 Mww 2020-06-18T12:49:53.747000Z</span><br><span class="line">RYUKYU ISLANDS, JAPAN 6.6 Mww 2020-06-13T15:51:24.069000Z</span><br><span class="line">NORTHERN CHILE 6.8 mww 2020-06-03T07:35:34.844000Z</span><br><span class="line">NEVADA 6.5 Mww 2020-05-15T11:03:27.176000Z</span><br><span class="line">SANTA CRUZ ISLANDS 6.6 mww 2020-05-12T22:41:12.177000Z</span><br><span class="line">BANDA SEA 6.8 Mww 2020-05-06T13:53:56.960000Z</span><br><span class="line">CRETE, GREECE 6.6 mww 2020-05-02T12:51:06.662000Z</span><br><span class="line">BONIN ISLANDS, JAPAN REGION 6.6 Mww 2020-04-18T08:25:37.081000Z</span><br><span class="line">WESTERN IDAHO 6.8 Ml 2020-03-31T23:52:31.094000Z</span><br><span class="line">EAST OF KURIL ISLANDS 7.5 Mww 2020-03-25T02:49:20.896000Z</span><br><span class="line">KURIL ISLANDS 7.0 mww 2020-02-13T10:33:44.492000Z</span><br><span class="line">CUBA REGION 7.7 mww 2020-01-28T19:10:24.963000Z</span><br><span class="line">TURKEY 6.7 Mww 2020-01-24T17:55:13.987000Z</span><br><span class="line">MINDANAO, PHILIPPINES 6.8 mww 2019-12-15T06:11:51.155000Z</span><br><span class="line">NORTHERN MOLUCCA SEA 7.1 Mww 2019-11-14T16:17:40.582000Z</span><br><span class="line">FIJI ISLANDS REGION 6.5 Mww 2019-11-08T10:44:44.876000Z</span><br><span class="line">TONGA ISLANDS 6.6 Mww 2019-11-04T22:43:32.280000Z</span><br><span class="line">MINDANAO, PHILIPPINES 6.5 mww 2019-10-31T01:11:19.122000Z</span><br><span class="line">MINDANAO, PHILIPPINES 6.6 Mww 2019-10-29T01:04:43.863000Z</span><br><span class="line">OFF COAST OF CENTRAL CHILE 6.7 mww 2019-09-29T15:57:53.236000Z</span><br><span class="line">SERAM, INDONESIA 6.5 Mww 2019-09-25T23:46:43.029000Z</span><br><span class="line">FIJI ISLANDS REGION 6.6 mww 2019-09-01T15:54:20.411000Z</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">events.plot()</span><br></pre></td></tr></table></figure>
<p><img src="/2020/09/03/obspy2/events.png" alt="events"></p>
<p>上述代码获取了从starttime到endtime之间一年以内，震级为6.5级以上的地震事件，并将其发生的地理位置、震级和时间（UTC）打印出来。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>obspy</category>
      </categories>
      <tags>
        <tag>天然地震</tag>
      </tags>
  </entry>
  <entry>
    <title>OBSpy天然地震III</title>
    <url>/2020/09/06/obspy3/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="天然地震"><a href="#天然地震" class="headerlink" title="天然地震"></a>天然地震</h1><h2 id="OBSpy教程之Client"><a href="#OBSpy教程之Client" class="headerlink" title="OBSpy教程之Client"></a>OBSpy教程之Client</h2><h3 id="获取不同Client的url"><a href="#获取不同Client的url" class="headerlink" title="获取不同Client的url"></a>获取不同Client的url</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> obspy.clients.fdsn <span class="keyword">import</span> Client</span><br><span class="line">c=Client(base_url=<span class="string">&quot;IRIS&quot;</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">base_url: Base URL of FDSN web service compatible server</span></span><br><span class="line"><span class="string">(e.g. &quot;http://service.iris.edu&quot;) or key string for recognized</span></span><br><span class="line"><span class="string">server (one of &#x27;BGR&#x27;, &#x27;EMSC&#x27;, &#x27;ETH&#x27;, &#x27;GEONET&#x27;, &#x27;GFZ&#x27;, &#x27;ICGC&#x27;,</span></span><br><span class="line"><span class="string">&#x27;INGV&#x27;, &#x27;IPGP&#x27;, &#x27;IRIS&#x27;, &#x27;ISC&#x27;, &#x27;KNMI&#x27;, &#x27;KOERI&#x27;, &#x27;LMU&#x27;, &#x27;NCEDC&#x27;,</span></span><br><span class="line"><span class="string">&#x27;NIEP&#x27;, &#x27;NOA&#x27;, &#x27;ODC&#x27;, &#x27;ORFEUS&#x27;, &#x27;RASPISHAKE&#x27;, &#x27;RESIF&#x27;, &#x27;SCEDC&#x27;,</span></span><br><span class="line"><span class="string">&#x27;TEXNET&#x27;, &#x27;UIB-NORSAR&#x27;, &#x27;USGS&#x27;, &#x27;USP&#x27;).</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">   The list below get from &#x27;Client(abbr).base_url&#x27;, where abbr</span></span><br><span class="line"><span class="string">   is the key string of server.</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th>Client_abbr</th>
<th>base_url</th>
</tr>
</thead>
<tbody>
<tr>
<td>BGR</td>
<td><a href="http://eida.bgr.de">http://eida.bgr.de</a></td>
</tr>
<tr>
<td>EMSC</td>
<td><a href="http://www.seismicportal.eu">http://www.seismicportal.eu</a></td>
</tr>
<tr>
<td>ETH</td>
<td><a href="http://eida.ethz.ch">http://eida.ethz.ch</a></td>
</tr>
<tr>
<td>GEONET</td>
<td><a href="http://service.geonet.org.nz">http://service.geonet.org.nz</a></td>
</tr>
<tr>
<td>GFZ</td>
<td><a href="http://geofon.gfz-potsdam.de">http://geofon.gfz-potsdam.de</a></td>
</tr>
<tr>
<td>ICGC</td>
<td><a href="http://ws.icgc.cat">http://ws.icgc.cat</a></td>
</tr>
<tr>
<td>INGV</td>
<td><a href="http://webservices.ingv.it">http://webservices.ingv.it</a></td>
</tr>
<tr>
<td>IPGP</td>
<td><a href="http://ws.ipgp.fr">http://ws.ipgp.fr</a></td>
</tr>
<tr>
<td>IRIS</td>
<td><a href="http://service.iris.edu">http://service.iris.edu</a></td>
</tr>
<tr>
<td>ISC</td>
<td><a href="http://isc-mirror.iris.washington.edu">http://isc-mirror.iris.washington.edu</a></td>
</tr>
<tr>
<td>KNMI</td>
<td><a href="http://rdsa.knmi.nl">http://rdsa.knmi.nl</a></td>
</tr>
<tr>
<td>KOERI</td>
<td><a href="http://eida.koeri.boun.edu.tr">http://eida.koeri.boun.edu.tr</a></td>
</tr>
<tr>
<td>LMU</td>
<td><a href="http://erde.geophysik.uni-muenchen.de">http://erde.geophysik.uni-muenchen.de</a></td>
</tr>
<tr>
<td>NCEDC</td>
<td><a href="http://service.ncedc.org">http://service.ncedc.org</a></td>
</tr>
<tr>
<td>NIEP</td>
<td><a href="http://eida-sc3.infp.ro">http://eida-sc3.infp.ro</a></td>
</tr>
<tr>
<td>NOA</td>
<td><a href="http://eida.gein.noa.gr">http://eida.gein.noa.gr</a></td>
</tr>
<tr>
<td>ODC</td>
<td><a href="http://www.orfeus-eu.org">http://www.orfeus-eu.org</a></td>
</tr>
<tr>
<td>ORFEUS</td>
<td><a href="http://www.orfeus-eu.org">http://www.orfeus-eu.org</a></td>
</tr>
<tr>
<td>RASPISHAKE</td>
<td><a href="http://fdsnws.raspberryshakedata.com">http://fdsnws.raspberryshakedata.com</a></td>
</tr>
<tr>
<td>RESIF</td>
<td><a href="http://ws.resif.fr">http://ws.resif.fr</a></td>
</tr>
<tr>
<td>SCEDC</td>
<td><a href="http://service.scedc.caltech.edu">http://service.scedc.caltech.edu</a></td>
</tr>
<tr>
<td>TEXNET</td>
<td><a href="http://rtserve.beg.utexas.edu">http://rtserve.beg.utexas.edu</a></td>
</tr>
<tr>
<td>UIB-NORSAR</td>
<td><a href="http://eida.geo.uib.no">http://eida.geo.uib.no</a></td>
</tr>
<tr>
<td>USGS</td>
<td><a href="http://earthquake.usgs.gov">http://earthquake.usgs.gov</a></td>
</tr>
<tr>
<td>USP</td>
<td><a href="http://sismo.iag.usp.br">http://sismo.iag.usp.br</a></td>
</tr>
</tbody>
</table>
</div>
<h3 id="在地图上显示network中的台站位置"><a href="#在地图上显示network中的台站位置" class="headerlink" title="在地图上显示network中的台站位置"></a>在地图上显示network中的台站位置</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">c = Client(<span class="string">&quot;IRIS&quot;</span>)</span><br><span class="line">cgt = c.get_stations(network=<span class="string">&quot;II&quot;</span>)</span><br><span class="line">cgt.plot()</span><br></pre></td></tr></table></figure>
<p><img src="/2020/09/06/obspy3/IRIS_II.png" alt="cgt"></p>
<h3 id="根据日期获取指定台站数据并按天分割"><a href="#根据日期获取指定台站数据并按天分割" class="headerlink" title="根据日期获取指定台站数据并按天分割"></a>根据日期获取指定台站数据并按天分割</h3><p>当需要下载指定台站、指定日期范围内的地震数据时，可以使用以下代码。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> obspy</span><br><span class="line"><span class="keyword">from</span> obspy.clients.fdsn.mass_downloader <span class="keyword">import</span> RectangularDomain, Restrictions, MassDownloader</span><br><span class="line"><span class="keyword">from</span> obspy <span class="keyword">import</span> UTCDateTime</span><br><span class="line"></span><br><span class="line">domain = RectangularDomain(minlatitude=-<span class="number">90</span>,</span><br><span class="line">                           maxlatitude=<span class="number">90</span>,</span><br><span class="line">                           minlongitude=-<span class="number">180</span>, </span><br><span class="line">                           maxlongitude=<span class="number">180</span>)</span><br><span class="line"></span><br><span class="line">restrictions = Restrictions(starttime=UTCDateTime(<span class="number">2020</span>, <span class="number">7</span>, <span class="number">20</span>),</span><br><span class="line">                            endtime=UTCDateTime(<span class="number">2020</span>, <span class="number">7</span>, <span class="number">22</span>), </span><br><span class="line">                            chunklength_in_sec=<span class="number">86400</span>, </span><br><span class="line">                            network=<span class="string">&quot;II&quot;</span>, </span><br><span class="line">                            station=<span class="string">&quot;KDAK&quot;</span>, </span><br><span class="line">                            location=<span class="string">&quot;*&quot;</span>,</span><br><span class="line">                            channel=<span class="string">&quot;*&quot;</span>, </span><br><span class="line">                            reject_channels_with_gaps=<span class="literal">False</span>, </span><br><span class="line">                            minimum_length=<span class="number">0.0</span>, </span><br><span class="line">                            minimum_interstation_distance_in_m=<span class="number">100.0</span>)</span><br><span class="line">mdl = MassDownloader()<span class="comment"># providers=[&quot;IRIS&quot;]</span></span><br><span class="line">mdl.download(domain,</span><br><span class="line">             restrictions, </span><br><span class="line">             mseed_storage=<span class="string">&quot;./data/KDAK/waveforms&quot;</span>, </span><br><span class="line">             stationxml_storage=<span class="string">&quot;./data/KDAK/stations&quot;</span>)</span><br></pre></td></tr></table></figure><br>以上代码中，下载了从<code>starttime</code>到<code>endtime</code>范围内，网络<code>II</code>、台站<code>KDAK</code>的所有通道数据，并将其截取为每个文件86400s长度（即一天）</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>obspy</category>
      </categories>
      <tags>
        <tag>天然地震</tag>
      </tags>
  </entry>
  <entry>
    <title>OBSpy天然地震IV</title>
    <url>/2020/09/08/obspy4/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="天然地震"><a href="#天然地震" class="headerlink" title="天然地震"></a>天然地震</h1><h2 id="OBSpy教程之获取到时"><a href="#OBSpy教程之获取到时" class="headerlink" title="OBSpy教程之获取到时"></a>OBSpy教程之获取到时</h2><p>09月08日18时04分在山东青岛市崂山区海域（北纬35.96度，东经120.82度）发生3.0级地震，震源深度13千米。（<a href="http://news.ceic.ac.cn/CD20200908180457.html">@中国地震台网</a>）<br>这里我们使用OBSpy获取上海某台站记录的此地震波形。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> obspy</span><br><span class="line"><span class="keyword">from</span> obspy.clients.fdsn <span class="keyword">import</span> Client</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">event_time = obspy.UTCDateTime(<span class="string">&quot;2020-09-08T10:04:44.5&quot;</span>)</span><br><span class="line">inv = c_event.get_stations(network=<span class="string">&quot;IC&quot;</span>,</span><br><span class="line">                           station=<span class="string">&quot;BJT&quot;</span>, <span class="comment">#BeiJing(lat:40.0183,lon:116.1679)</span></span><br><span class="line">                           level=<span class="string">&quot;response&quot;</span>)</span><br><span class="line">inv.extend(c_event.get_stations(network=<span class="string">&quot;IC&quot;</span>,</span><br><span class="line">                                station=<span class="string">&quot;SSE&quot;</span>, <span class="comment">#ShangHai(lat:31.0948,lon:121.1908)</span></span><br><span class="line">                                level=<span class="string">&quot;response&quot;</span>))</span><br><span class="line">client = Client(<span class="string">&quot;IRIS&quot;</span>)</span><br><span class="line">st = client.get_waveforms(network=<span class="string">&quot;IC&quot;</span>, </span><br><span class="line">                          station=<span class="string">&quot;*&quot;</span>,</span><br><span class="line">                          location=<span class="string">&quot;*&quot;</span>, </span><br><span class="line">                          channel=<span class="string">&quot;BH*&quot;</span>, </span><br><span class="line">                          starttime=event_time - <span class="number">10</span> * <span class="number">60</span>, </span><br><span class="line">                          endtime=event_time + <span class="number">10</span> * <span class="number">60</span>)</span><br><span class="line">st.write(<span class="string">&#x27;./QingDaoEvent20200908/QDshock.mseed&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/2020/09/08/obspy4/stations.png" alt="stations.png"><br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">25 Trace(s) <span class="keyword">in</span> Stream:</span><br><span class="line"></span><br><span class="line">IC.BJT.00.BH1 | 2020-09-08T09:54:44.519539Z - 2020-09-08T10:14:44.469539Z | 20.0 Hz, 24000 samples</span><br><span class="line">...</span><br><span class="line">(23 other traces)</span><br><span class="line">...</span><br><span class="line">IC.QIZ.00.BHZ | 2020-09-08T09:54:44.519538Z - 2020-09-08T10:14:44.469538Z | 20.0 Hz, 24000 samples</span><br><span class="line"></span><br><span class="line">[Use <span class="string">&quot;print(Stream.__str__(extended=True))&quot;</span> to <span class="built_in">print</span> all Traces]</span><br></pre></td></tr></table></figure><br>台网：<a href="https://www.fdsn.org/networks/detail/IC/">IC</a>，共获取了25道记录，以位于北京白家疃的BJT台站数据为例，计算地震波到达此站的UTC时并将P波到时绘制在图上。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> obspy.taup <span class="keyword">import</span> TauPyModel</span><br><span class="line"><span class="keyword">from</span> obspy.geodetics <span class="keyword">import</span> locations2degrees</span><br><span class="line">m = TauPyModel(model=<span class="string">&quot;ak135&quot;</span>, verbose=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">st = st.select(station=<span class="string">&quot;BJT&quot;</span>)</span><br><span class="line">Trace = <span class="number">0</span></span><br><span class="line">qd_event_latitude = <span class="number">35.96</span></span><br><span class="line">qd_event_longitude = <span class="number">120.82</span></span><br><span class="line">qd_event_depth = <span class="number">13</span> <span class="comment">#km</span></span><br><span class="line"><span class="comment">#coords = inv.get_coordinates(st[0].get_id())</span></span><br><span class="line"><span class="comment"># coords = &#123;&quot;longitude&quot;:121.445,</span></span><br><span class="line"><span class="comment">#           &quot;latitude&quot;: 31.213&#125;</span></span><br><span class="line">coords = &#123;<span class="string">&quot;longitude&quot;</span>:<span class="number">116.1679</span>,</span><br><span class="line">          <span class="string">&quot;latitude&quot;</span>: <span class="number">40.0183</span>&#125;</span><br><span class="line">distance = locations2degrees(qd_event_latitude, </span><br><span class="line">                             qd_event_longitude,</span><br><span class="line">                             coords[<span class="string">&quot;latitude&quot;</span>],</span><br><span class="line">                             coords[<span class="string">&quot;longitude&quot;</span>])</span><br><span class="line">arrivals = m.get_ray_paths(distance_in_degree=distance,</span><br><span class="line">                           source_depth_in_km=qd_event_depth)</span><br><span class="line">first_arrival = event_time + arrivals[<span class="number">0</span>].time</span><br><span class="line">delta = first_arrival - st[Trace].stats.starttime</span><br><span class="line">time = np.arange(<span class="number">0</span>, st[Trace].stats.npts/ st[Trace].stats.sampling_rate, st[Trace].stats.delta)</span><br><span class="line">fig, axes = plt.subplots(nrows = <span class="number">1</span>, ncols = <span class="number">1</span> , figsize = (<span class="number">16</span>,<span class="number">4</span>))</span><br><span class="line">axes.plot(time, st[Trace].data, color = <span class="string">&#x27;black&#x27;</span>)</span><br><span class="line">axes.axvline(delta, color = <span class="string">&#x27;red&#x27;</span>)</span><br><span class="line">axes.set_xlabel(<span class="string">&quot;Time [s]&quot;</span>+st[Trace].stats.channel)</span><br></pre></td></tr></table></figure>
<p><img src="/2020/09/08/obspy4/traveltime.png" alt="traveltime"></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>obspy</category>
      </categories>
      <tags>
        <tag>天然地震</tag>
      </tags>
  </entry>
  <entry>
    <title>OBSpy installation Q&amp;A</title>
    <url>/2020/09/05/obspy_install/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="Q-amp-A-of-installation-of-obspy"><a href="#Q-amp-A-of-installation-of-obspy" class="headerlink" title="Q&amp;A of installation of obspy"></a>Q&amp;A of installation of obspy</h1><h2 id="Q-ImportError-Neither-Basemap-nor-Cartopy-could-be-imported"><a href="#Q-ImportError-Neither-Basemap-nor-Cartopy-could-be-imported" class="headerlink" title="Q: ImportError: Neither Basemap nor Cartopy could be imported."></a>Q: ImportError: Neither Basemap nor Cartopy could be imported.</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[user]$ conda install basemap</span><br></pre></td></tr></table></figure>
<h2 id="Q-ImportError-cannot-import-name-‘is-scalar’"><a href="#Q-ImportError-cannot-import-name-‘is-scalar’" class="headerlink" title="Q: ImportError: cannot import name ‘is scalar’"></a>Q: ImportError: cannot import name ‘is scalar’</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[user]$ pip install matplotlib==<span class="number">3.0</span><span class="number">.0</span></span><br></pre></td></tr></table></figure>
<h2 id="Q-AttributeError-‘Axes’-object-has-no-attribute-‘get-axis-bgcolor’"><a href="#Q-AttributeError-‘Axes’-object-has-no-attribute-‘get-axis-bgcolor’" class="headerlink" title="Q: AttributeError: ‘Axes’ object has no attribute ‘get axis bgcolor’"></a>Q: AttributeError: ‘Axes’ object has no attribute ‘get axis bgcolor’</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[user]$ vim ~/.conda/envs/seismic/lib/python3<span class="number">.6</span>/site-packages/mpl_toolkits/basemap/__init__.py</span><br><span class="line"><span class="comment"># Change the directory of you own basemap installaion dir.</span></span><br><span class="line">[user]$ <span class="comment"># replace all &#x27;get_axis_bgcolor&#x27; with &#x27;get_facecolor()&#x27; in file __init__.py</span></span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>obspy</category>
      </categories>
      <tags>
        <tag>天然地震</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux中论文写作环境搭建</title>
    <url>/2020/07/02/paper_env/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="文字编辑器"><a href="#文字编辑器" class="headerlink" title="文字编辑器"></a>文字编辑器</h1><p>使用 <a href="https://linux.wps.cn/">WPS for linux</a>，安装包格式为rpm，安装过程如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[usrname]$ rpm -ivh wps-office-11.1.0.9522-1.x86_64.rpm</span><br><span class="line"><span class="comment">#安装完成后可能会缺少相关字体，例如中文论文常用的宋体、黑体等，可以从windows中拷贝到linux下，将ttf字体文件复制到/usr/share/fonts/wps-office文件夹中，重启wps即可看到中文字体</span></span><br><span class="line">[usrname]$ wps <span class="comment"># 安装包中包含PDF、Presentation、Spreadsheets和Writter</span></span><br></pre></td></tr></table></figure>
<p>常用部分中文 <strong>ttf</strong> 格式字体<a href="https://pan.baidu.com/s/19eR8GaxYuE6ISLGdVGWUDg">百度网盘(提取码:s7lq)</a>。</p>
<h1 id="公式编辑器"><a href="#公式编辑器" class="headerlink" title="公式编辑器"></a>公式编辑器</h1><p>使用 <strong><a href="https://www.xm1math.net/texmaker/download.html">texmaker</a></strong>，实际上完全可以使用 <strong>texmaker</strong> 完成整个论文撰写工作。（<code>#texmaker 的下载要注意与qt版本相对应</code>）<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[usrname]$ tar -jxvf texmaker-5.0.3.tar.bz2</span><br><span class="line">[usrname]$ <span class="built_in">cd</span> texmaker-5.0.3/</span><br><span class="line">[usrname]$ qmake texmaker.pro</span><br><span class="line">[usrname]$ make &amp;&amp; make install</span><br><span class="line">[usrname]$ texmaker</span><br></pre></td></tr></table></figure></p>
<h1 id="安装32位wine"><a href="#安装32位wine" class="headerlink" title="安装32位wine"></a>安装32位wine</h1><p>在研究 <strong>LaTex</strong> 搭配 <strong>python</strong> 中的 <code>pandoc</code>实现 <code>tex2word</code> 无果后（经由<code>pandoc</code>转换出的word文件会丢失部分 <strong>tex</strong> 中设置好的格式，可能是<code>\usepackage</code>导致的；但如果只需要由 <strong>tex</strong> 生成 <strong>pdf</strong>文件，LaTex还是值得深入学习一下的），退而求其次，本来想通过wine安装 <strong>MS office</strong>，但转念一想不如装个 <strong>MathTpye</strong> 来的方便，结果也没好装到哪去。。。</p>
<p>为了使用32位MathType，首先安装32位wine，小编安装的是<a href="https://dl.winehq.org/wine/source/5.0/wine-5.0.1.tar.xz">5.0.1版本源码</a>，由于主机环境为x86_64，所以我们需要为系统安装32位依赖环境，否则无法执行 <strong>./configure</strong> ：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root]$ yum install glibc-devel.i686 dbus-devel.i686 freetype-devel.i686 pulseaudio-libs-devel.i686 </span><br><span class="line"> libX11-devel.i686 mesa-libGLU-devel.i686 libICE-devel.i686 libXext-devel.i686 libXcursor-devel.i686 </span><br><span class="line"> libXi-devel.i686 libXxf86vm-devel.i686 libXrender-devel.i686 libXinerama-devel.i686 libXcomposite-devel.i686 </span><br><span class="line"> libXrandr-devel.i686 mesa-libGL-devel.i686 mesa-libOSMesa-devel.i686 libxml2-devel.i686 libxslt-devel.i686 </span><br><span class="line"> zlib-devel.i686 gnutls-devel.i686 ncurses-devel.i686 sane-backends-devel.i686 libv4l-devel.i686 </span><br><span class="line"> libgphoto2-devel.i686 libexif-devel.i686 lcms2-devel.i686 gettext-devel.i686 isdn4k-utils-devel.i686 </span><br><span class="line"> cups-devel.i686 fontconfig-devel.i686 gsm-devel.i686 libjpeg-turbo-devel.i686 pkgconfig.i686  </span><br><span class="line"> libtiff-devel.i686 unixODBC.i686 openldap-devel.i686 alsa-lib-devel.i686 audiofile-devel.i686 </span><br><span class="line"> freeglut-devel.i686 giflib-devel.i686 gstreamer-devel.i686 gstreamer-plugins-base-devel.i686 libXmu-devel.i686 </span><br><span class="line"> libXxf86dga-devel.i686 libieee1284-devel.i686 libpng-devel.i686 librsvg2-devel.i686 </span><br><span class="line"> libstdc++-devel.i686 libusb-devel.i686 unixODBC-devel.i686 qt-devel.i686</span><br><span class="line">[root]$ yum install libXext.i686</span><br><span class="line">[root]$ yum install libXext.x86_64</span><br><span class="line">[root]$ yum install ia32-libs.i686</span><br><span class="line">[root]$ yum install xulrunner.i686</span><br><span class="line">[root]$ yum install libX11-devel freetype-devel zlib-devel libxcb-devel</span><br><span class="line">[root]$ tar -xvf wine-5.0.1.tar.xz</span><br><span class="line">[root]$ <span class="built_in">cd</span> wine-5.0.1</span><br><span class="line">[root]$ ./configure</span><br><span class="line">[root]$ make <span class="comment">#make耗费时间比较长，耐心等待即可</span></span><br><span class="line">[root]$ make install</span><br><span class="line">[root]$ wine --version <span class="comment">#查看32位wine版本</span></span><br></pre></td></tr></table></figure><br>然后执行<code>winecfg</code>，如果系统默认语言为 <strong>en</strong>，此时看到的 <strong>wine</strong> 配置界面应同样为英文，若系统已经安装了中文字体，例如 <strong>simsun.ttf</strong> 等，在 <strong>terminal</strong> 执行<code>export LANG=zh_CN.utf8</code> 即可将语言临时调整为中文。</p>
<h1 id="中文版MathType安装及语言配置"><a href="#中文版MathType安装及语言配置" class="headerlink" title="中文版MathType安装及语言配置"></a>中文版MathType安装及语言配置</h1><p>下载好 <strong>Mathtype</strong> 之后，打开系统（屏幕左上角）的<code>Applications &gt; Wine &gt; Wine Software uninstaller</code>，点击其中的<code>install</code>并选择安装包即可完成安装。可以通过<code>Applications &gt; Wine &gt; MathType</code>打开公式编辑器。</p>
<p>如果字体出现乱码等情况，首先要考虑是否系统环境与wine环境不一致所导致，详情请参考：<a href="http://linux-wiki.cn/wiki/zh-hans/wine%E7%9A%84%E4%B8%AD%E6%96%87%E6%98%BE%E7%A4%BA%E4%B8%8E%E5%AD%97%E4%BD%93%E8%AE%BE%E7%BD%AE">这位热心网友的解答</a>。</p>
<p>小编在修改完<code>~/.wine/system.reg</code>以及<code>~/.wine//drive_c/windows/win.ini</code>（root用户和普通用户根目录下都含有此文件，均做修改并不能解决字体部分乱码问题，怀疑是系统语言的限制）后运行 <strong>MathType</strong> 过程中出现部分中文字体为 ？？？的情况，再次运行<code>export LANG=zh_CN.utf8</code>即可显示所有中文字体。（测试发现，如果系统环境为en，需要在每次启动MathType时在terminal中临时切换为中文，即运行上述代码。或者，使用 <code>alias</code> 为软件创建命令行快捷打开方式）。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>paper</category>
      </categories>
      <tags>
        <tag>Linux&amp;Windows--cross</tag>
      </tags>
  </entry>
  <entry>
    <title>pyseis--基于conv的声波正演模拟</title>
    <url>/2020/08/20/pyseis_fdtd_basedonconv/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="基于神经网络中卷积操作的标量声波方程正演模拟"><a href="#基于神经网络中卷积操作的标量声波方程正演模拟" class="headerlink" title="基于神经网络中卷积操作的标量声波方程正演模拟"></a>基于神经网络中卷积操作的标量声波方程正演模拟</h1><p>编写一个声波方程的正演模拟程序，是入门地震数据处理中数值模拟这一领域的基础，同时也是后续做<strong>RTM</strong>、<strong>FWI</strong>等方向的基础。个人一般用<strong>C</strong>、<strong>C++</strong> 或者<strong>CUDA</strong>编写<strong>CPU(GPU)</strong> 版本的程序，对于初入这一行业的小白来讲门槛比较高，既要掌握语言语法、还要将偏微分方程“变现”（将其离散化并变为计算机语言），并且后续代码的移植也非常困难；但好处是可操作性强（可以直接对内存、显存进行操作），代码可读性强（不会像python一样过一阵再看自己写的代码就看不懂了）。</p>
<p>所以… … …</p>
<p>之前做过一些尝试，把<strong>C</strong>的正演程序直接改成<strong>python</strong>的语法，但是发现效率极其低下，已经找不到当时的代码了，回忆了一下应该是思维定式（菜）惹的祸：波场计算的时候用<strong>for</strong>循环处理了<strong>numpy</strong>数组（大误），现在想想是真的菜。</p>
<p>下面我们以深度学习中卷积操作的视角重新审视一下基于有限差分的标量声波方程正演模拟。</p>
<h2 id="标量声波方程"><a href="#标量声波方程" class="headerlink" title="标量声波方程"></a>标量声波方程</h2><p>我们首先来看二维空间中的波动方程，<br><img src="/2020/08/20/pyseis_fdtd_basedonconv/scalar_o.gif" alt="img"><br>左侧是<strong>u</strong>对时间的二阶导数，右侧是<strong>u</strong>对空间的二阶偏导数与源<strong>f</strong>之和，为求解 <strong>t</strong>时刻 <strong>(i, j)</strong> 处的波场分量，首先需要将其离散化。我们一般将二维空间中的拉普拉斯算子用Taylor展开的形式来逼近，用<strong>k</strong>、<strong>k-1</strong>、和<strong>k-2</strong>表示相邻的三个时刻，空间步长<strong>dx=dz=dh</strong>,时间步长为<strong>dt</strong>，介质速度为<strong>Vp</strong>，则有<br><img src="/2020/08/20/pyseis_fdtd_basedonconv/scalar.gif" alt="scalar"><br>我们会发现它实质上是一个迭代的过程，这里给出的公式只能够计算一个时间切片内的波场，在编程计算时，计算完<strong>k</strong>时刻波场后，需要将<strong>k</strong>和<strong>k-1</strong>时刻分别更新为<strong>k-1</strong>和<strong>k-2</strong>时刻，这样就可以计算下一个”k”时刻的波场(对应实际的k+1)。</p>
<h2 id="神经网络中的卷积操作"><a href="#神经网络中的卷积操作" class="headerlink" title="神经网络中的卷积操作"></a>神经网络中的卷积操作</h2><p>神经网络中的二维卷积实质上是卷积核与像素矩阵pixel-wise的互相关、求和，它与一维信号中的卷积还不太一样<br><img src="/2020/08/20/pyseis_fdtd_basedonconv/conv.gif" alt="conv"><br>图片来自(<a href="https://www.jianshu.com/p/1ea2949c0056">简书</a>)<br>动图中可以很明显地看出，单层的卷积计算也并不是很复杂，只是拿一个window在已知的输入上滑动，这个window就是神经网络卷积、反卷积中的卷积核kernel，滑动的步长被称为stride，边缘处灰色值被称为padding(用于填充边缘保证输入和输出的大小)，kernel和输入的每一个block相乘相加即可得到输出的一个像素值。</p>
<h2 id="基于卷积op的有限差分"><a href="#基于卷积op的有限差分" class="headerlink" title="基于卷积op的有限差分"></a>基于卷积op的有限差分</h2><p>很久之前就在想有没有办法能够将正演接入神经网络中，利用python中现成的工具包快速完成一些复杂的计算，这要涉及到数据流问题、输入输出转换问题、数据接口问题等等。前一阵利用<strong>pycuda</strong>完成了几个版本的正演模拟(常规网格标量声波和一阶速度应力交错网格弹性波)计算<strong>package</strong>，能够通过简单的输入速度模型(<strong>numpy</strong>)和参数设置生成数据流并怼到神经网络里面，但是<strong>pycuda</strong>的底层代码还是用<strong>CUDA</strong>写的，只是通过它的<strong>SourceMoudle</strong>来编译运行，所以不能直接接到<strong>TF</strong>的<strong>Graph</strong>中，进行更加高级的运算，比如求导等(<strong>package</strong>中有未公开发表的部分，待发表后将源码放出)。</p>
<p>要想利用<strong>TF</strong>等框架的自动微分，就必须要使用<strong>TF</strong>原生的函数或者定义 <code>@tf.function</code>来追踪变量，由此有了以下尝试。</p>
<p>我们观察离散格式的标量声波方程中带有求和符号的一项，可以看到它是每一个点上沿着<strong>x</strong>方向和<strong>z</strong>方向的求和叠加，假设有限差分精度为<strong>2N</strong>，那么求和项中的系数可以通过求解以下方程得到<br><img src="/2020/08/20/pyseis_fdtd_basedonconv/coes.gif" alt="coes"></p>
<p>仔细观察即可发现，每个(i,j)处横向或纵向的求和都可以用以该点为中心，长度和宽度均为<strong>2*N+1</strong>的<strong>block</strong>与一个相同大小的卷积核<strong>f</strong>进行卷积来代替，例如当差分精度为<strong>4</strong>时，卷积核的大小应为<strong>5x5</strong>，以(i,j)为中心的求和(dx=dz=dh)可以用如下卷积操作代替(注：第一个矩阵中的省略号不代表值为0，只是其与卷积核相乘后的值为0，当网格不同方向的大小不同时需要区分水平方向卷积核以及垂直方向卷积核)，那么整个卷积就可以写为<code>tf.nn.depthwise_conv2d(input=x, filter=f, strides=[1, 1, 1, 1], padding=&#39;SAME&#39;)</code><br><img src="/2020/08/20/pyseis_fdtd_basedonconv/conv1.gif" alt="conv1"></p>
<p>基本原理如上所述，这样一来，我们就可以利用TF框架来实现正演模拟了(完整的代码请联系shaowinw@geophyai.com，小站流量不多了，暂不提供下载功能)。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>pyseis</category>
      </categories>
      <tags>
        <tag>fdtd</tag>
      </tags>
  </entry>
  <entry>
    <title>pyseis--有限差分系数计算</title>
    <url>/2020/08/16/pyseis_v0.0.1_normal_coes/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="正演模拟中二阶导数差分系数计算"><a href="#正演模拟中二阶导数差分系数计算" class="headerlink" title="正演模拟中二阶导数差分系数计算"></a>正演模拟中二阶导数差分系数计算</h1><h2 id="整数网格点二阶导数的任意偶数阶精度有限差分系数计算"><a href="#整数网格点二阶导数的任意偶数阶精度有限差分系数计算" class="headerlink" title="整数网格点二阶导数的任意偶数阶精度有限差分系数计算"></a>整数网格点二阶导数的任意偶数阶精度有限差分系数计算</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> numpy.linalg <span class="keyword">import</span> solve</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Normal_Grid_Coefficients</span>(<span class="params">N, diff_order = <span class="number">2</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Coefficients of arbitrary even order Taylor</span></span><br><span class="line"><span class="string">        expansion when the discrete values are at </span></span><br><span class="line"><span class="string">        integral grid point. Such as for normal grid</span></span><br><span class="line"><span class="string">        second-order acoustic forward modeling.</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        Parameters:</span></span><br><span class="line"><span class="string">        ----------</span></span><br><span class="line"><span class="string">        N : Half-order of Taylor expansion or the</span></span><br><span class="line"><span class="string">            length of unilateral operator.</span></span><br><span class="line"><span class="string">        diff_order : Not used in this method. Just</span></span><br><span class="line"><span class="string">            for notice.</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        Returns:</span></span><br><span class="line"><span class="string">        ----------</span></span><br><span class="line"><span class="string">        out : 1-D ndarray.</span></span><br><span class="line"><span class="string">        The length of output is (2*N+1) with the </span></span><br><span class="line"><span class="string">        first coefficient is C0.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    holder = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">        matrix = []</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">            matrix.append(np.power((i+<span class="number">1</span>)**j, <span class="number">2</span>))</span><br><span class="line">        holder.append(matrix)</span><br><span class="line">    holder = np.array(holder).T</span><br><span class="line">    constant = np.zeros(N)</span><br><span class="line">    constant[<span class="number">0</span>] = <span class="number">1.0</span></span><br><span class="line">    x = solve(holder, constant)</span><br><span class="line">    </span><br><span class="line">    t1 = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">        x[i] = x[i]/np.power(i+<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">        t1+=x[i]</span><br><span class="line">    </span><br><span class="line">    coes = np.zeros(N+<span class="number">1</span>)</span><br><span class="line">    coes[<span class="number">0</span>] = -<span class="number">2</span>*t1</span><br><span class="line">    coes[<span class="number">1</span>:<span class="built_in">len</span>(coes)] = x</span><br><span class="line">    <span class="keyword">return</span> coes</span><br></pre></td></tr></table></figure>
<h2 id="半网格点一阶导数的任意偶数阶精度有限差分系数计算"><a href="#半网格点一阶导数的任意偶数阶精度有限差分系数计算" class="headerlink" title="半网格点一阶导数的任意偶数阶精度有限差分系数计算"></a>半网格点一阶导数的任意偶数阶精度有限差分系数计算</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">Staggered_Grid_Coefficients</span>(<span class="params">N, diff_order = <span class="number">1</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Coefficients of arbitrary even order Taylor</span></span><br><span class="line"><span class="string">        expansion when the discrete values are at </span></span><br><span class="line"><span class="string">        half grid point. Such as for staggered grid</span></span><br><span class="line"><span class="string">        first-order velocity-stress elastic forward</span></span><br><span class="line"><span class="string">        modeling.</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        Parameters:</span></span><br><span class="line"><span class="string">        ----------</span></span><br><span class="line"><span class="string">        N : Half-order of Taylor expansion or the</span></span><br><span class="line"><span class="string">            length of unilateral operator.</span></span><br><span class="line"><span class="string">        diff_order : Differential order of discretization,</span></span><br><span class="line"><span class="string">            not used in this method. Just for notice.</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        Returns:</span></span><br><span class="line"><span class="string">        ----------</span></span><br><span class="line"><span class="string">        out : 1-D ndarray.</span></span><br><span class="line"><span class="string">        The length of output is (2*N).</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    holder = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">        matrix = []</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">            matrix.append(np.power(<span class="number">2</span>*j+<span class="number">1</span>, <span class="number">2</span> * (i + <span class="number">1</span>) - <span class="number">1</span>))</span><br><span class="line">        holder.append(matrix)</span><br><span class="line">    holder = np.array(holder)</span><br><span class="line">    constant = np.zeros(N)</span><br><span class="line"></span><br><span class="line">    constant[<span class="number">0</span>] = <span class="number">1.0</span><span class="comment">#*f</span></span><br><span class="line">    x = solve(holder, constant)</span><br><span class="line">    </span><br><span class="line">    coes = np.zeros(N)</span><br><span class="line">    coes[<span class="number">0</span>:<span class="built_in">len</span>(coes)] = x</span><br><span class="line">    <span class="keyword">return</span> coes</span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>pyseis</category>
      </categories>
      <tags>
        <tag>差分系数</tag>
      </tags>
  </entry>
  <entry>
    <title>Python之import argparse</title>
    <url>/2020/06/21/python_argparse/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="Python之命令行解析—argparse"><a href="#Python之命令行解析—argparse" class="headerlink" title="Python之命令行解析—argparse"></a>Python之命令行解析—argparse</h1><p>在 <strong>terminal</strong> 执行 <strong>.py</strong> 文件经常遇到。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">import</span> argparse</span><br><span class="line">$ Aparser = argparse.ArgumentParser(</span><br><span class="line">		    prog=<span class="literal">None</span>, <span class="comment">#给程序起名儿，默认为sys.argv[0]</span></span><br><span class="line">		    usage=<span class="literal">None</span>, <span class="comment">#参数用法备注，默认从参数中自动生成</span></span><br><span class="line">		    description=<span class="literal">None</span>, <span class="comment">#程序目的备注，显示在help之前</span></span><br><span class="line">		    epilog=<span class="literal">None</span>, <span class="comment">#参数描述后跟着的解释，显示在help之后</span></span><br><span class="line">		    parents=[], <span class="comment">#由ArgumentParser对象组成的列表，它们的arguments选项会被包含到新ArgumentParser对象中。(类似于继承)</span></span><br><span class="line">		    formatter_class=&lt;<span class="keyword">class</span> <span class="string">&#x27;argparse.HelpFormatter&#x27;</span>&gt;, <span class="comment">#help输出格式</span></span><br><span class="line">		    prefix_chars=<span class="string">&#x27;-&#x27;</span>, <span class="comment">#每个参数的前缀，默认为‘- arg’</span></span><br><span class="line">		    fromfile_prefix_chars=<span class="literal">None</span>, <span class="comment">#前缀字符，放置在文件名之前</span></span><br><span class="line">		    argument_default=<span class="literal">None</span>, <span class="comment">#没用到</span></span><br><span class="line">		    conflict_handler=<span class="string">&#x27;error&#x27;</span>, <span class="comment">#冲突解决，保持默认</span></span><br><span class="line">		    add_help=<span class="literal">True</span>, <span class="comment">#是否增加-h/-help选项 (默认为True)。设为False时，help信息里面不再显示-h –help信息.</span></span><br><span class="line">		    allow_abbrev=<span class="literal">True</span>, <span class="comment">#允许较长的参数名称使用缩写</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><br>测试代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">##aarparse.py:测试argparse</span></span><br><span class="line"><span class="comment">##aarparse.py:测试argparse</span></span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line">parser = argparse.ArgumentParser(prog = <span class="string">&#x27;我叫测试程序&#x27;</span>, description=<span class="string">&#x27;测试argparse模块&#x27;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&#x27;--第一个参数&#x27;</span>, metavar = <span class="string">&#x27;&lt;参数备注&gt;&#x27;</span>, default = <span class="number">1996</span>,</span><br><span class="line">                    <span class="built_in">help</span>=<span class="string">&#x27;显示第一个参数的用处&#x27;</span>, <span class="built_in">type</span> = <span class="built_in">int</span>)</span><br><span class="line">parser.add_argument(<span class="string">&#x27;--第二个参数&#x27;</span>, metavar = <span class="string">&#x27;&lt;参数备注&gt;&#x27;</span>,</span><br><span class="line">                    <span class="built_in">help</span>=<span class="string">&#x27;显示第二个参数的用处&#x27;</span>, <span class="built_in">type</span> = <span class="built_in">int</span>)</span><br><span class="line">parser.add_argument(<span class="string">&#x27;--third_parameter&#x27;</span>, <span class="built_in">type</span> = <span class="built_in">str</span>, default = <span class="string">&#x27;input&#x27;</span>, <span class="built_in">help</span> = <span class="string">&#x27;what will third_parameter do?&#x27;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&#x27;--choices&#x27;</span>, <span class="built_in">type</span> = <span class="built_in">int</span>, default = <span class="number">1</span> , choices =[<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;8&#x27;</span>], <span class="built_in">help</span> = <span class="string">&#x27;choose a number from chioces&#x27;</span>)</span><br><span class="line">args = parser.parse_args()</span><br><span class="line"><span class="keyword">if</span> args.第一个参数 == <span class="number">2020</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;今年是2020年。&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;今年是&#x27;</span> + <span class="built_in">str</span>(args.第一个参数) + <span class="string">&#x27;年。&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;choices = &#x27;</span> + <span class="built_in">str</span>(args.choices))</span><br></pre></td></tr></table></figure>
<p>测试结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ python aarparse.py -h</span><br><span class="line">usage: 我叫测试程序 [-h] [--第一个参数 &lt;参数备注&gt;] [--第二个参数 &lt;参数备注&gt;]</span><br><span class="line">              [--third_parameter THIRD_PARAMETER] [--choices &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">8</span>&#125;]</span><br><span class="line"></span><br><span class="line">测试argparse模块</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line">  -h, --<span class="built_in">help</span>            show this <span class="built_in">help</span> message <span class="keyword">and</span> exit</span><br><span class="line">  --第一个参数 &lt;参数备注&gt;        显示第一个参数的用处</span><br><span class="line">  --第二个参数 &lt;参数备注&gt;        显示第二个参数的用处</span><br><span class="line">  --third_parameter THIRD_PARAMETER</span><br><span class="line">                        what will third_parameter do?</span><br><span class="line">  --choices &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">8</span>&#125;     choose a number <span class="keyword">from</span> chioces</span><br><span class="line">$ python aarparse.py</span><br><span class="line">今年是<span class="number">1996</span>年。</span><br><span class="line">choices = <span class="number">1</span></span><br><span class="line">$ python aarparse.py --第一个参数 <span class="number">2020</span> --choices <span class="number">3</span></span><br><span class="line">今年是<span class="number">2020</span>年。</span><br><span class="line">choices = <span class="number">3</span></span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>argparse</tag>
      </tags>
  </entry>
  <entry>
    <title>Python之深copy与浅copy</title>
    <url>/2020/07/13/python_copy/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="C和Python中简单变量的拷贝问题"><a href="#C和Python中简单变量的拷贝问题" class="headerlink" title="C和Python中简单变量的拷贝问题"></a>C和Python中简单变量的拷贝问题</h1><p>所谓浅拷贝，即变量之间的差异只体现在声明的名称上，他们实质上指向同一块内存地址；而深拷贝则是内存地址完全不相同的两个变量。<br>在C中(包括C++,CUDA)，两个值相同的变量内存地址是不同的，而在python中则不太一样，下面我们通过几个例子了解一下python中浅拷贝和深拷贝问题。</p>
<h1 id="C"><a href="#C" class="headerlink" title="C"></a>C</h1><p>用代码说话。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;addr of a = %p\n&quot;</span>, &amp;a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;addr of b = %p\n&quot;</span>, &amp;b);</span><br><span class="line">a = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;addr of a = %p\n&quot;</span>, &amp;a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;addr of b = %p\n&quot;</span>, &amp;b);</span><br><span class="line">b = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;addr of a = %p\n&quot;</span>, &amp;a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;addr of b = %p\n&quot;</span>, &amp;b);</span><br><span class="line">[usr]./test_shallowcopy_ofC.out</span><br><span class="line">addr of a = <span class="number">0x7ffdb8b0344c</span></span><br><span class="line">addr of b = <span class="number">0x7ffdb8b03448</span></span><br><span class="line">addr of a = <span class="number">0x7ffdb8b0344c</span></span><br><span class="line">addr of b = <span class="number">0x7ffdb8b03448</span></span><br><span class="line">addr of a = <span class="number">0x7ffdb8b0344c</span></span><br><span class="line">addr of b = <span class="number">0x7ffdb8b03448</span></span><br><span class="line"><span class="comment">// 整个过程中a,b的地址并没有发生改变</span></span><br></pre></td></tr></table></figure></p>
<h1 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h1><h2 id="简单变量"><a href="#简单变量" class="headerlink" title="简单变量"></a>简单变量</h2><p>用代码说话。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># copypy.py</span></span><br><span class="line">a = <span class="number">1</span></span><br><span class="line">b = <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;addr_of_a=&quot;</span>,<span class="built_in">hex</span>(<span class="built_in">id</span>(a))) <span class="comment"># 输出a的16进制地址</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;addr_of_b=&quot;</span>,<span class="built_in">hex</span>(<span class="built_in">id</span>(b)))</span><br><span class="line">a = <span class="number">2</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;addr_of_a=&quot;</span>,<span class="built_in">hex</span>(<span class="built_in">id</span>(a)))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;addr_of_b=&quot;</span>,<span class="built_in">hex</span>(<span class="built_in">id</span>(b)))</span><br><span class="line">b = <span class="number">2</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;addr_of_a=&quot;</span>,<span class="built_in">hex</span>(<span class="built_in">id</span>(a)))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;addr_of_b=&quot;</span>,<span class="built_in">hex</span>(<span class="built_in">id</span>(b)))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>python copypy.py</span><br><span class="line">addr_of_a= <span class="number">0x563c06329320</span></span><br><span class="line">addr_of_b= <span class="number">0x563c06329320</span></span><br><span class="line"><span class="comment"># 当初始化的两个变量值相同时，其地址相同</span></span><br><span class="line">addr_of_a= <span class="number">0x563c06329340</span></span><br><span class="line">addr_of_b= <span class="number">0x563c06329320</span></span><br><span class="line"><span class="comment"># 改变某一个变量后其地址也会发生改变</span></span><br><span class="line">addr_of_a= <span class="number">0x563c06329340</span></span><br><span class="line">addr_of_b= <span class="number">0x563c06329340</span></span><br><span class="line"><span class="comment"># 将两个变量改变为相同的值，他们的地址也会变为相同</span></span><br></pre></td></tr></table></figure>
<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>所以，当使用直接赋值的方式<code>b = a</code>进行变量值的传递时可能会出现问题，当两个变量只是简单的两个数值时似乎并没有什么不同，我们再看以下例子。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># test_copylist.py</span></span><br><span class="line">a = [<span class="literal">True</span>, [<span class="literal">True</span>, <span class="literal">True</span>], <span class="literal">True</span>]</span><br><span class="line">b = a</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;a=&#x27;</span>,a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;b=&#x27;</span>,b)</span><br><span class="line">a[<span class="number">0</span>] = <span class="literal">False</span></span><br><span class="line">a[<span class="number">1</span>][<span class="number">0</span>] = [<span class="literal">False</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;a=&#x27;</span>,a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;b=&#x27;</span>,b)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>python test_copylist.py</span><br><span class="line">a=[<span class="literal">True</span>, [<span class="literal">True</span>, <span class="literal">True</span>], <span class="literal">True</span>]</span><br><span class="line">b=[<span class="literal">True</span>, [<span class="literal">True</span>, <span class="literal">True</span>], <span class="literal">True</span>]</span><br><span class="line">a=[<span class="literal">False</span>, [[<span class="literal">False</span>], <span class="literal">True</span>], <span class="literal">True</span>]</span><br><span class="line">b=[<span class="literal">False</span>, [[<span class="literal">False</span>], <span class="literal">True</span>], <span class="literal">True</span>]</span><br><span class="line"><span class="comment"># 可以看到当a的值改变时，b的值也会随之变化；</span></span><br><span class="line"><span class="comment"># 这是因为a和b均指向了相同的内存地址；</span></span><br><span class="line"><span class="comment"># 在C语言中这种情况是不会发生的</span></span><br></pre></td></tr></table></figure>
<p>这显然不是我们想看到结果，如果要实现C中赋值的效果(深拷贝)，就需要用到<code>copy</code>模块，模块中有<code>copy.copy()</code>和<code>copy.deepcopy()</code>两个函数，我们看一下使用方法：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># test_copylist2.py</span></span><br><span class="line"><span class="keyword">import</span> copy</span><br><span class="line">a = [<span class="literal">True</span>, [<span class="literal">True</span>, <span class="literal">True</span>], <span class="literal">False</span>]</span><br><span class="line">b = a</span><br><span class="line">copy_a = copy.copy(a)</span><br><span class="line">dcopy_a = copy.deepcopy(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Before change&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;addr_of_a=&#x27;</span>,<span class="built_in">hex</span>(<span class="built_in">id</span>(a)))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;addr_of_b=&#x27;</span>,<span class="built_in">hex</span>(<span class="built_in">id</span>(b)))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;a=&#x27;</span>,a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;copy_a=&#x27;</span>,copy_a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;dcopy_a=&#x27;</span>,dcopy_a)</span><br><span class="line"></span><br><span class="line">a[<span class="number">0</span>] = <span class="literal">False</span></span><br><span class="line">a[<span class="number">1</span>][<span class="number">0</span>] = <span class="literal">False</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;After change&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;addr_of_a=&#x27;</span>,<span class="built_in">hex</span>(<span class="built_in">id</span>(a)))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;addr_of_b=&#x27;</span>,<span class="built_in">hex</span>(<span class="built_in">id</span>(b)))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;a=&#x27;</span>,a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;copy_a=&#x27;</span>,copy_a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;dcopy_a=&#x27;</span>,dcopy_a)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>python test_copylist2.py</span><br><span class="line">Before change</span><br><span class="line">addr_of_a= <span class="number">0x7f8562f439c8</span></span><br><span class="line">addr_of_b= <span class="number">0x7f8562f439c8</span></span><br><span class="line">a= [<span class="literal">True</span>, [<span class="literal">True</span>, <span class="literal">True</span>], <span class="literal">False</span>]</span><br><span class="line">copy_a= [<span class="literal">True</span>, [<span class="literal">True</span>, <span class="literal">True</span>], <span class="literal">False</span>]</span><br><span class="line">dcopy_a= [<span class="literal">True</span>, [<span class="literal">True</span>, <span class="literal">True</span>], <span class="literal">False</span>]</span><br><span class="line">After change</span><br><span class="line">addr_of_a= <span class="number">0x7f8562f439c8</span></span><br><span class="line">addr_of_b= <span class="number">0x7f8562f439c8</span></span><br><span class="line">a= [<span class="literal">False</span>, [<span class="literal">False</span>, <span class="literal">True</span>], <span class="literal">False</span>]</span><br><span class="line">b= [<span class="literal">False</span>, [<span class="literal">False</span>, <span class="literal">True</span>], <span class="literal">False</span>] <span class="comment"># a is b=True</span></span><br><span class="line">copy_a= [<span class="literal">True</span>, [<span class="literal">False</span>, <span class="literal">True</span>], <span class="literal">False</span>]</span><br><span class="line"><span class="comment"># copy.copy无法拷贝第二级列表</span></span><br><span class="line">dcopy_a= [<span class="literal">True</span>, [<span class="literal">True</span>, <span class="literal">True</span>], <span class="literal">False</span>]</span><br><span class="line"><span class="comment"># copy.deeocopy将创建一个新的变量并从源变量copy值</span></span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>如果想要实现C中的拷贝效果，即字面意义上的变量赋值，需要使用<code>y=copy.deepcopy(x)</code>(后续x的变化不会改变y的值)。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>copy</tag>
      </tags>
  </entry>
  <entry>
    <title>Python之更换matplotlib字体</title>
    <url>/2020/06/24/python_fontofmatplotlib.pyplot/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="更换plt字体"><a href="#更换plt字体" class="headerlink" title="更换plt字体"></a>更换plt字体</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#Windows环境为Win10，系统自带字体为ttf格式</span></span><br><span class="line">[Windows10]<span class="comment"># C:\Windows\Fonts</span></span><br><span class="line">[Linux]<span class="comment"># cd /../../Fonts #找个地方建个文件夹，把win的字体copy进去</span></span><br><span class="line"><span class="comment">##------.py Start------##</span></span><br><span class="line"><span class="comment">#以win10中New Times字体为例</span></span><br><span class="line"><span class="built_in">times</span> = matplotlib.font_manager.FontProperties(fname=<span class="string">&#x27;/Fonts/TIMES.TTF&#x27;</span>)</span><br><span class="line">fontname = <span class="built_in">times</span></span><br><span class="line">plt.xticks(fontproperties=fontname, fontsize=12)<span class="comment">#x轴标签</span></span><br><span class="line">plt.yticks(fontproperties=fontname, fontsize=12)<span class="comment">#y轴标签</span></span><br><span class="line">plt.xlabel(<span class="string">&#x27;x&#x27;</span>, fontproperties=fontname, fontsize=14)<span class="comment">#x坐标轴</span></span><br><span class="line">plt.ylabel(<span class="string">&#x27;y&#x27;</span>, fontproperties=fontname, fontsize=14)<span class="comment">#y坐标轴</span></span><br><span class="line">plt.legend(prop=fontname,fontsize=12)<span class="comment">#图例</span></span><br><span class="line">plt.show()</span><br><span class="line"><span class="comment">##------.py End------##</span></span><br></pre></td></tr></table></figure>
<p>全局字体设置<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#plt.colorbar字体更换</span></span><br><span class="line">[linux]<span class="comment"># cd /home/usrname/.cache/matplotlib</span></span><br><span class="line">[linux]<span class="comment"># vim fontlist-v310.json fontlist-v310.json</span></span><br><span class="line"><span class="comment"># 在ttflist中添加你想要的字体</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="string">&quot;fname&quot;</span>: <span class="string">&quot;字体路径&quot;</span>,</span><br><span class="line">   <span class="string">&quot;name&quot;</span>: <span class="string">&quot;Times New Roman&quot;</span>, <span class="comment">#调用时的字体名称</span></span><br><span class="line">   <span class="string">&quot;style&quot;</span>: <span class="string">&quot;normal&quot;</span>,</span><br><span class="line">   <span class="string">&quot;variant&quot;</span>: <span class="string">&quot;normal&quot;</span>,</span><br><span class="line">   <span class="string">&quot;weight&quot;</span>: 700,</span><br><span class="line">   <span class="string">&quot;stretch&quot;</span>: <span class="string">&quot;normal&quot;</span>,</span><br><span class="line">   <span class="string">&quot;size&quot;</span>: <span class="string">&quot;scalable&quot;</span>,</span><br><span class="line">   <span class="string">&quot;__class__&quot;</span>: <span class="string">&quot;FontEntry&quot;</span></span><br><span class="line"> &#125;,</span><br><span class="line">[linux]<span class="comment"># 在程序中设置plt的全局字体</span></span><br><span class="line"><span class="comment">##------.py Start------##</span></span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.family&#x27;</span>] = <span class="string">&#x27;Times New Roman&#x27;</span></span><br><span class="line"><span class="comment">##------.py End------##</span></span><br></pre></td></tr></table></figure></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>font</tag>
      </tags>
  </entry>
  <entry>
    <title>地震数据波形变密度绘图</title>
    <url>/2020/10/05/python_wiggle_trace/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="地震数据变密度显示"><a href="#地震数据变密度显示" class="headerlink" title="地震数据变密度显示"></a>地震数据变密度显示</h1><p>以下代码节选自fatiando包的vis.mpl.seismic_wiggle模块</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot</span><br><span class="line"><span class="keyword">import</span> numpy</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">seismic_wiggle</span>(<span class="params">section, dt=<span class="number">0.004</span>, ranges=<span class="literal">None</span>, scale=<span class="number">1.</span>,</span></span><br><span class="line"><span class="params">                   color=<span class="string">&#x27;k&#x27;</span>, normalize=<span class="literal">False</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Plot a seismic section (numpy 2D array matrix) as wiggles.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Parameters:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    * section :  二维数组，第一个维度为时间，第二个维度为导数</span></span><br><span class="line"><span class="string">        matrix of traces (first dimension time, second dimension traces)</span></span><br><span class="line"><span class="string">    * dt : float</span></span><br><span class="line"><span class="string">        时间采样率（默认四毫秒）</span></span><br><span class="line"><span class="string">    * ranges : (x1, x2)</span></span><br><span class="line"><span class="string">        水平最大最小值（默认为道号）</span></span><br><span class="line"><span class="string">    * scale : float</span></span><br><span class="line"><span class="string">        比例因子</span></span><br><span class="line"><span class="string">    * color : tuple of strings</span></span><br><span class="line"><span class="string">        Color for filling the wiggle, positive  and negative lobes.</span></span><br><span class="line"><span class="string">    * normalize :</span></span><br><span class="line"><span class="string">        True: 使用全局最大和最小值将所有道的数据归一化到[-0.5, 0.5]</span></span><br><span class="line"><span class="string">    .. warning::</span></span><br><span class="line"><span class="string">        Slow for more than 200 traces, in this case decimate your</span></span><br><span class="line"><span class="string">        data or use ``seismic_image``.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    npts, ntraces = section.shape  <span class="comment"># time/traces</span></span><br><span class="line">    <span class="keyword">if</span> ntraces &lt; <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">raise</span> IndexError(<span class="string">&quot;Nothing to plot&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> npts &lt; <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">raise</span> IndexError(<span class="string">&quot;Nothing to plot&quot;</span>)</span><br><span class="line">    t = numpy.linspace(<span class="number">0</span>, dt*npts, npts)</span><br><span class="line">    amp = <span class="number">1.</span>  <span class="comment"># normalization factor</span></span><br><span class="line">    gmin = <span class="number">0.</span>  <span class="comment"># global minimum</span></span><br><span class="line">    toffset = <span class="number">0.</span>  <span class="comment"># offset in time to make 0 centered</span></span><br><span class="line">    <span class="keyword">if</span> normalize:</span><br><span class="line">        gmax = section.<span class="built_in">max</span>()</span><br><span class="line">        gmin = section.<span class="built_in">min</span>()</span><br><span class="line">        amp = (gmax-gmin)</span><br><span class="line">        toffset = <span class="number">0.5</span></span><br><span class="line">    pyplot.ylim(<span class="built_in">max</span>(t), <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span> ranges <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        ranges = (<span class="number">0</span>, ntraces)</span><br><span class="line">    x0, x1 = ranges</span><br><span class="line">    <span class="comment"># horizontal increment</span></span><br><span class="line">    dx = <span class="built_in">float</span>((x1-x0)/ntraces)</span><br><span class="line">    pyplot.xlim(x0, x1)</span><br><span class="line">    <span class="keyword">for</span> i, trace <span class="keyword">in</span> <span class="built_in">enumerate</span>(section.transpose()):</span><br><span class="line">        tr = (((trace-gmin)/amp)-toffset)*scale*dx</span><br><span class="line">        x = x0+i*dx  <span class="comment"># x positon for this trace</span></span><br><span class="line">        pyplot.plot(x+tr, t, <span class="string">&#x27;k&#x27;</span>)</span><br><span class="line">        pyplot.fill_betweenx(t, x+tr, x, tr &gt; <span class="number">0</span>, color=color)</span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>pyseis</category>
      </categories>
      <tags>
        <tag>地震数据绘图</tag>
      </tags>
  </entry>
  <entry>
    <title>OBSpy+rf接收函数计算</title>
    <url>/2020/12/25/recfunc/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="Receiver-Function-profile-with-rf-package"><a href="#Receiver-Function-profile-with-rf-package" class="headerlink" title="Receiver Function profile with rf package"></a>Receiver Function profile with rf package</h1><h3 id="本文档翻译自https-nbviewer-jupyter-org-github-trichter-notebooks-blob-master-receiver-function-profile-chile-ipynb"><a href="#本文档翻译自https-nbviewer-jupyter-org-github-trichter-notebooks-blob-master-receiver-function-profile-chile-ipynb" class="headerlink" title="本文档翻译自https://nbviewer.jupyter.org/github/trichter/notebooks/blob/master/receiver_function_profile_chile.ipynb"></a>本文档翻译自<a href="https://nbviewer.jupyter.org/github/trichter/notebooks/blob/master/receiver_function_profile_chile.ipynb">https://nbviewer.jupyter.org/github/trichter/notebooks/blob/master/receiver_function_profile_chile.ipynb</a></h3><p>此ipynb脚本借助<a href="https://github.com/trichter/rf">rf软件包</a>使用智利北部的IPOC数据演示了receiver function的计算和剖面叠加。此脚本依赖项ObsPy，rf，h5py，obspyh5和tqdm。首先，我们导入必要的函数，并为目录，地震和波形文件定义文件名。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> obspy <span class="keyword">import</span> read_inventory, read_events, UTCDateTime <span class="keyword">as</span> UTC</span><br><span class="line"><span class="keyword">from</span> obspy.clients.fdsn <span class="keyword">import</span> Client</span><br><span class="line"><span class="keyword">from</span> rf <span class="keyword">import</span> read_rf, RFStream</span><br><span class="line"><span class="keyword">from</span> rf <span class="keyword">import</span> get_profile_boxes, iter_event_data, IterMultipleComponents</span><br><span class="line"><span class="keyword">from</span> rf.imaging <span class="keyword">import</span> plot_profile_map</span><br><span class="line"><span class="keyword">from</span> rf.profile <span class="keyword">import</span> profile</span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">	创建-&gt;data文件夹并定义文件名称</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">data = os.path.join(<span class="string">&#x27;data&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">invfile = data + <span class="string">&#x27;rf_profile_stations.xml&#x27;</span></span><br><span class="line">catfile = data + <span class="string">&#x27;rf_profile_events.xml&#x27;</span></span><br><span class="line">datafile = data + <span class="string">&#x27;rf_profile_data.h5&#x27;</span></span><br><span class="line">rffile = data + <span class="string">&#x27;rf_profile_rfs.h5&#x27;</span></span><br><span class="line">profilefile = data + <span class="string">&#x27;rf_profile_profile.h5&#x27;</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(data):  <span class="comment"># create data folder if necessary</span></span><br><span class="line">    os.mkdir(data)</span><br></pre></td></tr></table></figure>
<p>如有必要，可以下载震级5.5和6.5之间的2010年库存数据和事件并作图。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(invfile):</span><br><span class="line">    client = Client(<span class="string">&#x27;GFZ&#x27;</span>)</span><br><span class="line">    inventory = client.get_stations(network=<span class="string">&#x27;CX&#x27;</span>, channel=<span class="string">&#x27;BH?&#x27;</span>, level=<span class="string">&#x27;channel&#x27;</span>,</span><br><span class="line">                                    minlatitude=-<span class="number">24</span>, maxlatitude=-<span class="number">19</span>)</span><br><span class="line">    inventory.write(invfile, <span class="string">&#x27;STATIONXML&#x27;</span>)</span><br><span class="line">inventory = read_inventory(invfile)</span><br><span class="line">inventory.plot(label=<span class="literal">False</span>)</span><br><span class="line">fig = inventory.plot(<span class="string">&#x27;local&#x27;</span>, color_per_network=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">coords = inventory.get_coordinates(<span class="string">&#x27;CX.PB01..BHZ&#x27;</span>)</span><br><span class="line">lonlat = (coords[<span class="string">&#x27;longitude&#x27;</span>], coords[<span class="string">&#x27;latitude&#x27;</span>])</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(catfile):</span><br><span class="line">    client = Client()</span><br><span class="line">    kwargs = &#123;<span class="string">&#x27;starttime&#x27;</span>: UTC(<span class="string">&#x27;2010-01-01&#x27;</span>), <span class="string">&#x27;endtime&#x27;</span>: UTC(<span class="string">&#x27;2011-01-01&#x27;</span>), </span><br><span class="line">              <span class="string">&#x27;latitude&#x27;</span>: lonlat[<span class="number">1</span>], <span class="string">&#x27;longitude&#x27;</span>: lonlat[<span class="number">0</span>],</span><br><span class="line">              <span class="string">&#x27;minradius&#x27;</span>: <span class="number">30</span>, <span class="string">&#x27;maxradius&#x27;</span>: <span class="number">90</span>,</span><br><span class="line">              <span class="string">&#x27;minmagnitude&#x27;</span>: <span class="number">5.5</span>, <span class="string">&#x27;maxmagnitude&#x27;</span>: <span class="number">6.5</span>&#125;</span><br><span class="line">    catalog = client.get_events(**kwargs)</span><br><span class="line">    catalog.write(catfile, <span class="string">&#x27;QUAKEML&#x27;</span>)</span><br><span class="line">catalog = read_events(catfile)</span><br><span class="line">fig = catalog.plot(label=<span class="literal">None</span>) </span><br></pre></td></tr></table></figure>
<p><img src="/2020/12/25/recfunc/download.png" alt="inventory"><br><img src="/2020/12/25/recfunc/2.png" alt="stations"><br>然后，我们使用<code>iter_event_data</code>迭代器下载波形数据，并将其保存到<code>HDF5</code>文件中。 迭代器通过应用<code>rfstats</code>函数自动将必要的标头插入流中。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(datafile):</span><br><span class="line">    client = Client(<span class="string">&#x27;GFZ&#x27;</span>)</span><br><span class="line">    stream = RFStream()</span><br><span class="line">    <span class="keyword">with</span> tqdm() <span class="keyword">as</span> pbar:</span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> iter_event_data(catalog, inventory, client.get_waveforms, pbar=pbar):</span><br><span class="line">            stream.extend(s)</span><br><span class="line">    stream.write(datafile, <span class="string">&#x27;H5&#x27;</span>)    </span><br></pre></td></tr></table></figure>
<p><img src="/2020/12/25/recfunc/88events.png" alt="events"><br>我们再次读取数据，并使用<code>IterMultipleComponents</code>对其进行遍历。 该迭代器为每个事件和台站返回一个三分量流。 我们过滤数据，相对于P波起始点进行修剪，计算接收函数并应用<code>Ps</code>偏移校正。 此后，绘制一个站的L分量和某些站的Q分量。 接收函数的L分量在0s处显示预期的峰值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data = read_rf(datafile, <span class="string">&#x27;H5&#x27;</span>)</span><br><span class="line">stream = RFStream()</span><br><span class="line"><span class="keyword">for</span> stream3c <span class="keyword">in</span> tqdm(IterMultipleComponents(data, <span class="string">&#x27;onset&#x27;</span>, <span class="number">3</span>)):</span><br><span class="line">    stream3c.<span class="built_in">filter</span>(<span class="string">&#x27;bandpass&#x27;</span>, freqmin=<span class="number">0.5</span>, freqmax=<span class="number">2</span>)</span><br><span class="line">    stream3c.trim2(-<span class="number">25</span>, <span class="number">75</span>, <span class="string">&#x27;onset&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(stream3c) != <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    stream3c.rf()</span><br><span class="line">    stream3c.moveout()</span><br><span class="line">    stream.extend(stream3c)</span><br><span class="line">stream.write(rffile, <span class="string">&#x27;H5&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(stream)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3273 Trace(s) in Stream:</span><br><span class="line"></span><br><span class="line">Prf CX.HMBCX..BHT | -25.0s - 75.0s onset:2010-01-27T17:52:02.949998Z | 20.0 Hz, 2001 samples | mag:5.8 dist:53.1 baz:92.8 slow:6.40 (Ps moveout)</span><br><span class="line">...</span><br><span class="line">(3271 other traces)</span><br><span class="line">...</span><br><span class="line">Prf CX.PSGCX..BHL | -25.0s - 75.0s onset:2010-12-31T16:39:31.150000Z | 20.0 Hz, 2001 samples | mag:5.5 dist:47.7 baz:70.2 slow:6.40 (Ps moveout)</span><br><span class="line"></span><br><span class="line">[Use &quot;print(Stream.__str__(extended=True))&quot; to print all Traces]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">stream = read_rf(rffile, <span class="string">&#x27;H5&#x27;</span>)</span><br><span class="line">kw = &#123;<span class="string">&#x27;trim&#x27;</span>: (-<span class="number">5</span>, <span class="number">20</span>), <span class="string">&#x27;fillcolors&#x27;</span>: (<span class="string">&#x27;black&#x27;</span>, <span class="string">&#x27;gray&#x27;</span>), <span class="string">&#x27;trace_height&#x27;</span>: <span class="number">0.1</span>&#125;</span><br><span class="line">stream.select(component=<span class="string">&#x27;L&#x27;</span>, station=<span class="string">&#x27;PB01&#x27;</span>).sort([<span class="string">&#x27;back_azimuth&#x27;</span>]).plot_rf(**kw)</span><br><span class="line"><span class="keyword">for</span> sta <span class="keyword">in</span> (<span class="string">&#x27;PB01&#x27;</span>, <span class="string">&#x27;PB04&#x27;</span>):</span><br><span class="line">    stream.select(component=<span class="string">&#x27;Q&#x27;</span>, station=sta).sort([<span class="string">&#x27;back_azimuth&#x27;</span>]).plot_rf(**kw)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/2020/12/25/recfunc/PB01BHL.png" alt="PB01BHL"><br><img src="/2020/12/25/recfunc/PB01BHQ.png" alt="PB01BHQ"><br><img src="/2020/12/25/recfunc/PB04BHQ.png" alt="PB04BHQ"><br>最后，我们通过在70 km的深度中穿入点经度来堆叠接收函数，并绘制剖面。 <code>get_profile_boxes</code>函数用于定义要叠加的区域。 方位角为90度，以定义东西走向。 使用<code>plot_profile_map</code>绘制域。 该剖面由配置剖面函数生成。 使用剖面函数而不是<code>RFStream.profile</code>方法可以显示进度条（对于大型数据集，也可以直接从光盘中feedRF数据）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">stream = read_rf(rffile, <span class="string">&#x27;H5&#x27;</span>)</span><br><span class="line">ppoints = stream.ppoints(<span class="number">70</span>)</span><br><span class="line">boxes = get_profile_boxes((-<span class="number">21.3</span>, -<span class="number">70.7</span>), <span class="number">90</span>, np.linspace(<span class="number">0</span>, <span class="number">180</span>, <span class="number">73</span>), width=<span class="number">530</span>)</span><br><span class="line">plt.figure(figsize=(<span class="number">10</span>, <span class="number">10</span>))</span><br><span class="line">plot_profile_map(boxes, inventory=inventory, ppoints=ppoints)</span><br><span class="line">pstream = profile(tqdm(stream), boxes)</span><br><span class="line">pstream.write(profilefile, <span class="string">&#x27;H5&#x27;</span>)</span><br><span class="line">plt.show()</span><br><span class="line"><span class="built_in">print</span>(pstream)</span><br></pre></td></tr></table></figure>
<p><img src="/2020/12/25/recfunc/5.png" alt="pstream"><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">213 Trace(s) in Stream:</span><br><span class="line"></span><br><span class="line">Prf profile (L) | -25.0s - 75.0s | 20.0 Hz, 2001 samples | pos:1.25km slow:6.40 (Ps moveout)</span><br><span class="line">...</span><br><span class="line">(211 other traces)</span><br><span class="line">...</span><br><span class="line">Prf profile (T) | -25.0s - 75.0s | 20.0 Hz, 2001 samples | pos:178.75km slow:6.40 (Ps moveout)</span><br><span class="line"></span><br><span class="line">[Use &quot;print(Stream.__str__(extended=True))&quot; to print all Traces]</span><br></pre></td></tr></table></figure></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pstream = read_rf(profilefile)</span><br><span class="line">pstream.trim2(-<span class="number">5</span>, <span class="number">20</span>, <span class="string">&#x27;onset&#x27;</span>)</span><br><span class="line">pstream.select(channel=<span class="string">&#x27;??Q&#x27;</span>).normalize().plot_profile(scale=<span class="number">1.5</span>, top=<span class="string">&#x27;hist&#x27;</span>)</span><br><span class="line">plt.gcf().set_size_inches(<span class="number">15</span>, <span class="number">10</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/2020/12/25/recfunc/6.png" alt="pstream"></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>obspy</category>
      </categories>
      <tags>
        <tag>天然地震</tag>
      </tags>
  </entry>
  <entry>
    <title>SEGY格式数据读取之SEGYIO</title>
    <url>/2021/06/07/segyio_01/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="SEGYIO包使用简介"><a href="#SEGYIO包使用简介" class="headerlink" title="SEGYIO包使用简介"></a>SEGYIO包使用简介</h1><p>本文简要介绍<code>python</code>包<code>SEGYIO</code>(安装方法：<code>pip install segyio==1.5.1</code>)的使用。<br><code>SEGIO</code>Git链接：<a href="https://github.com/equinor/segyio">https://github.com/equinor/segyio</a></p>
<p>在使用马达加斯加处理地震数据时，遇到了需要读取<code>SEGY</code>格式数据的情况(<code>book/rsf/su/rsflab16</code>)。为了更好地利用<code>python</code>对国际通用格式的地震数据进行处理，结合<code>book/rsf/su/rsflab16</code>中的需求，我们简要介绍如何在<code>python</code>中使用<code>SEGYIO</code>包快速读取此类格式的数据。</p>
<p>我们利用<code>SEGYIO</code>主要解决马达加斯加源码示例<code>book/rsf/su/rsflab16</code>中的以下需求：</p>
<ol>
<li>读取<code>SEGY</code>格式文件中的剖面数据；</li>
<li>读取<code>SEGY</code>格式文件中偏移距和CDP号数据；</li>
<li>根据CDP道集号从$1$中抽取数据</li>
</ol>
<p>注：在<code>book/rsf/su/rsflab16</code>文件夹下执行<code>scons</code>即可下载本次实验用到的<code>SEGY</code>文件<code>seismic.segy</code>。</p>
<h1 id="读取SEGY道集信息"><a href="#读取SEGY道集信息" class="headerlink" title="读取SEGY道集信息"></a>读取SEGY道集信息</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> segyio</span><br><span class="line">root_path = <span class="string">r&#x27;your_file_path&#x27;</span></span><br><span class="line"><span class="keyword">with</span> segyio.<span class="built_in">open</span>(os.path.join(root_path, <span class="string">&#x27;seismic.segy&#x27;</span>)) <span class="keyword">as</span> segyfile:</span><br><span class="line">    <span class="comment"># Memory map file for faster reading (especially if file is big...)</span></span><br><span class="line">    segyfile.mmap()</span><br><span class="line"> 	index = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 打印第index道的道头信息</span></span><br><span class="line">    <span class="built_in">print</span>(segyfile.header[index])</span><br></pre></td></tr></table></figure>
<p>输出(只列出了部分信息)：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;TRACE_SEQUENCE_LINE: <span class="number">1</span>, TRACE_SEQUENCE_FILE: <span class="number">1</span>, FieldRecord: <span class="number">3</span>, TraceNumber: <span class="number">1</span>, </span><br><span class="line">EnergySourcePoint: <span class="number">101</span>, CDP: <span class="number">1</span>, CDP_TRACE: <span class="number">1</span>, offset: -<span class="number">3237</span>, </span><br><span class="line">ReceiverGroupElevation: -<span class="number">10</span>, SourceSurfaceElevation: -<span class="number">6</span>, SourceDepth: <span class="number">0</span>, ReceiverDatumElevation: <span class="number">0</span>,</span><br><span class="line">SourceDatumElevation: <span class="number">0</span>, SourceWaterDepth: <span class="number">0</span>, GroupWaterDepth: <span class="number">0</span>, ElevationScalar: <span class="number">1</span>, </span><br><span class="line">SourceGroupScalar: <span class="number">1</span>, SourceX: <span class="number">3237</span>, SourceY: <span class="number">0</span>, GroupX: <span class="number">0</span>,</span><br><span class="line">GroupY: <span class="number">0</span>, CoordinateUnits: <span class="number">3</span>, MuteTimeEND: <span class="number">48</span>, TRACE_SAMPLE_COUNT: <span class="number">1500</span>, </span><br><span class="line">TRACE_SAMPLE_INTERVAL: <span class="number">4000</span></span><br></pre></td></tr></table></figure></p>
<h1 id="读取剖面数据"><a href="#读取剖面数据" class="headerlink" title="读取剖面数据"></a>读取剖面数据</h1><p>如果只读取其中的数据，则可以利用以下方法：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data = segyio.tools.cube(os.path.join(root_path, <span class="string">&#x27;seismic.segy&#x27;</span>))</span><br><span class="line">data = np.squeeze(data)</span><br><span class="line"><span class="comment"># data.shape=(120120, 1500)</span></span><br></pre></td></tr></table></figure><br>输出<code>data</code>的<code>shape</code>时可以发现，这里将所有道的数据都读取到了一个数组中，知道了每炮对应的道数后，我们可以手动对这些数据按炮进行划分：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">DATA = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> tqdm.trange(<span class="number">120120</span>//<span class="number">120</span>):</span><br><span class="line">	DATA.append(data[i*<span class="number">120</span>:(i+<span class="number">1</span>)*<span class="number">120</span>,:])</span><br><span class="line">DATA = np.array(DATA)</span><br><span class="line"><span class="comment"># DATA.shape = (1001, 1500, 50)</span></span><br></pre></td></tr></table></figure></p>
<h1 id="偏移距和CDP号读取"><a href="#偏移距和CDP号读取" class="headerlink" title="偏移距和CDP号读取"></a>偏移距和CDP号读取</h1><p>偏移距和CDP号存储在每一道的道头中，我们可以使用如下方法获得二者信息：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> segyio.<span class="built_in">open</span>(os.path.join(root_path, <span class="string">&#x27;seismic.segy&#x27;</span>)) <span class="keyword">as</span> segyfile:</span><br><span class="line">    <span class="comment"># Memory map file for faster reading (especially if file is big...)</span></span><br><span class="line">    segyfile.mmap()</span><br><span class="line">    CDP = segyfile.attributes(segyio.TraceField.CDP)[:]</span><br><span class="line">    OFFSET = segyfile.attributes(segyio.TraceField.offset)[:]</span><br></pre></td></tr></table></figure><br>以上代码中<code>CDP</code>和<code>OFFSET</code>中存储的偏移距和CDP号数据与SConstruct源码中的如下代码所生成的<code>cdp.rsf</code>和<code>offset.rsf</code>文件中数据是相对应且一致的。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># SConstruct 源码读取偏移距和CDP号</span></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> (<span class="string">&#x27;cdp&#x27;</span>,<span class="string">&#x27;offset&#x27;</span>):</span><br><span class="line">    Flow(key,<span class="string">&#x27;tseismic&#x27;</span>,</span><br><span class="line">         <span class="string">&#x27;dd type=float | headermath output=%s&#x27;</span> % key)</span><br></pre></td></tr></table></figure></p>
<h1 id="根据CDP道集号从-1-中抽取数据"><a href="#根据CDP道集号从-1-中抽取数据" class="headerlink" title="根据CDP道集号从$1$中抽取数据"></a>根据CDP道集号从$1$中抽取数据</h1><p>首先来看<code>SConstruct</code>源码：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Capture a single CMP</span></span><br><span class="line">Flow(<span class="string">&#x27;cdpmask&#x27;</span>,<span class="string">&#x27;cdp&#x27;</span>,<span class="string">&#x27;mask min=265 max=265&#x27;</span>)</span><br><span class="line">Flow(<span class="string">&#x27;cdp265&#x27;</span>,<span class="string">&#x27;seismic cdpmask&#x27;</span>,</span><br><span class="line">     <span class="string">&#x27;headerwindow mask=$&#123;SOURCES[1]&#125; | pow pow1=2&#x27;</span>)</span><br><span class="line">Flow(<span class="string">&#x27;offset265&#x27;</span>,<span class="string">&#x27;offset cdpmask&#x27;</span>,</span><br><span class="line">     <span class="string">&#x27;headerwindow mask=$&#123;SOURCES[1]&#125;&#x27;</span>)</span><br></pre></td></tr></table></figure><br>以上源码中，第一个<code>Flow</code>生成了一个与<code>cdp</code>中数据等长的全零元素数组，令与<code>cdp</code>中数字<code>265</code>对应的索引为1，其余位置为0。另外，第三个<code>Flow</code>还利用<code>cdpmask.rsf</code>文件从偏移距数据中抽取了<code>CDP</code>号为<code>265</code>的位置对应的数值。例如：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 若</span></span><br><span class="line">cdp = [<span class="number">2</span>, <span class="number">33</span>, <span class="number">256</span>, <span class="number">265</span>, <span class="number">8</span>, <span class="number">265</span>]</span><br><span class="line">offset = [<span class="number">1</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">16</span>, <span class="number">2</span>, <span class="number">32</span>]</span><br><span class="line"><span class="comment"># 则</span></span><br><span class="line">cdpmask = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">offset265= [<span class="number">16</span>, <span class="number">32</span>]</span><br></pre></td></tr></table></figure><br>然后从原始数据中抽取了<code>CDP</code>号为<code>265</code>的道形成了新的数据，在利用<code>sfpow</code>对新数据进行增益处理后生成了<code>cdp265.rsf</code>文件。</p>
<p>这相当于利用<code>numpy</code>数组进行如下操作：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cdp_data = data[np.where(cdp==<span class="number">265</span>)[<span class="number">0</span>]]</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">power</span>(<span class="params">data, p = <span class="number">2</span>, o = <span class="number">0.</span>, d = <span class="number">1.</span>, axis = -<span class="number">1</span></span>):</span><br><span class="line">	<span class="comment"># p：增益指数项</span></span><br><span class="line">	<span class="comment"># o：起始位置</span></span><br><span class="line">	<span class="comment"># d：时间采样间隔</span></span><br><span class="line">	<span class="comment"># axis：沿哪个轴进行增益</span></span><br><span class="line">    nx = data.shape[axis]</span><br><span class="line">    reps = data.shape[<span class="number">0</span>]</span><br><span class="line">    scale = np.zeros((<span class="number">1</span>, nx))</span><br><span class="line">    x_range = np.arange(<span class="number">0</span>, nx) + <span class="number">1</span></span><br><span class="line">    scale = np.power(o+x_range*d, p)</span><br><span class="line">    <span class="keyword">return</span> data*scale, scale</span><br><span class="line">cdp_data_power, scale = power(cdp_data, d=<span class="number">0.004</span>)</span><br><span class="line">offset265 = OFFSET[np.where(cdp==<span class="number">265</span>)[<span class="number">0</span>]]</span><br></pre></td></tr></table></figure><br>代码中<code>np.where(cdp==265)</code>输出了数组<code>cdp</code>中元素值为<code>265</code>的坐标索引，例如：<code>cdp=[2, 33, 256, 265, 8, 265],np.where(cdp==265)=[3, 5]</code>，由于原<code>cdp</code>数据为二维数组，因此这里我们只输出其第一个维度索引值。上述代码中numpy数组<code>cdp_data_power</code>中的数据与<code>cdp265.rsf</code>文件的数据是一致的，并且<code>offset265</code>与文件<code>offset265.rsf</code>文件中数据也是一致的。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>SEGYIO</category>
      </categories>
      <tags>
        <tag>编程开发</tag>
      </tags>
  </entry>
  <entry>
    <title>第二章 梯度优化前言</title>
    <url>/2022/12/19/seismic_inversion_2/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="梯度优化-前言"><a href="#梯度优化-前言" class="headerlink" title="梯度优化-前言"></a>梯度优化-前言</h1><p>定义关于实函数$f(\rm \textbf x)$的无约束最优化问题（Fletcher, 1987）为，寻找一个最优的模型矢量$\rm \textbf x^{\ast}$ 满足以下条件：</p>
<script type="math/tex; mode=display">f(\rm \textbf x^{\ast} ) ≤ f(\rm \textbf x)\tag{2.1}</script><p>通常会将模型惩罚函数$g(\rm \textbf x))$加入数据目标函数中：</p>
<script type="math/tex; mode=display">\epsilon=f(\rm \textbf x)+\lambda g(\rm \textbf x), \tag{2.3}</script><p>其中，$\lambda &gt;0$为标量参数，用于平衡控制减少惩罚函数和增大目标函数。例如，在测井位置有速度曲线$\rm \textbf x^{well}$，应该强制让反演的速度模型$\rm \textbf x$在测井位置处等于声速曲线，有$g(\rm \textbf x)=||\rm \textbf x -\rm \textbf x^{well}||^2$。较大的$\lambda$意味着目标函数更多的确保反演模型接测井值，而尽管可能会导致预测数据和观测数据的误差较大。</p>
<h2 id="两类优化方法"><a href="#两类优化方法" class="headerlink" title="两类优化方法"></a>两类优化方法</h2><p>优化方法主要包括<strong>全局优化</strong>和<strong>梯度优化</strong>两种（Gill et al., 1981）。在<strong>全局优化方法</strong>中，需要在整个模型空间中寻找$\rm \textbf x^{\ast}$使得公式$2.3$目标函数$\epsilon$最小来避免陷入局部极小。常用的全局优化算法有Monte Carlo方法(Fu and Hu, 1997)、线性和非线性编程(Horst and Pardalos, 1995),、模拟退火、遗传算法(Sen and Stoffa, 1995),和混合算法(Sen and Stoffa, 1992).等。如果优化问题足够小或者计算机足够快，地震反演就可以使用全局优化算法(Sen and<br>Stoffa, 1991; 1992; 1995)。但在实际的地震反演问题中往往是不可取的。<br>另一类优化方法是沿着目标函数的downhill方向迭代搜索模型矢量，然后在第一次局部极小时停止，即<strong>梯度优化方法</strong>。相对于全局优化方法来讲这类方法需要更小的迭代次数就可以收敛，并且无需耗费巨大的计算量和存储量，常用算法有共轭梯度法（CG）和最速下降法等。这类方法的劣势在于容易陷入局部极小。如果初始模型选择不准确，就会陷入局部极小。如图2.1所示，如果选取的初始模型靠近左侧起始位置，那么反演会很快陷入局部极小，而如果选取的模型在右侧位置，反演则能够收敛到全局最小，但是选取一个好的初始模型以跳过局部极小在实际资料的反演中是不现实的。多尺度反演(Bunks et al., 1995; Nemeth et al., 1997; Ravaut et al., 2004; Krebs et al., 2009),可以很好地解决这一问题，能够使反演跳过局部极小并收敛到全局最小或其附近。<br><img src="/2022/12/19/seismic_inversion_2/Figure2.1.png" alt="Figure2.1"></p>
<h2 id="多尺度策略"><a href="#多尺度策略" class="headerlink" title="多尺度策略"></a>多尺度策略</h2><p>在多尺度反中，通常要对地震数据做低通滤波以使其更简单，基于滤波后数据的目标函数也会更平滑。然后，通过梯度搜索来拟合平滑的目标函数，进而在后续的反演中添加更高频或更复杂的数据。重复以上步骤直到数据中所有的分量都反演完成。多尺度策略的变种包括骨骼化数据(Luo and Schuster, 1991a; 1991b)在前期反演中限制有限偏移距和有限时窗等。多尺度波形反演的结果显示(Bunks et al., 1995; Ravaut et al., 2004; Krebs et al., 2009)，多尺度梯度优化对于地震数据全波形反演而言是至关重要的。</p>
<h1 id="2-1-数学定义"><a href="#2-1-数学定义" class="headerlink" title="2.1 数学定义"></a>2.1 数学定义</h1><p>函数$f(\rm \textbf x)$的梯度定义为:</p>
<script type="math/tex; mode=display">\nabla f(\rm \textbf x):=[\frac{\partial f}{\partial x_1} ... ... ... \frac{\partial f}{\partial x_N}]^T \tag{2.4}</script><p>其中$\rm \textbf x \in R^N$，$N \times N$Hessian矩阵$\rm \textbf H$定义为$\nabla \nabla ^T f(\rm \textbf x)$，其元素为：</p>
<script type="math/tex; mode=display">H_{ij}:=[\nabla \nabla ^T f(\rm \textbf x)]_{ij}= \frac{\partial ^2 f(\rm \textbf x)}{\partial x_i \partial x_j}\tag{2.5}</script><p>矩阵$\rm \textbf H$为实对称矩阵，因为$\frac{\partial ^2 f(\rm \textbf x)}{\partial x_i \partial x_j}=\frac{\partial ^2 f(\rm \textbf x)}{\partial x_j \partial x_i}$。Hessian矩阵中包含了$f(\rm \textbf x)$的曲率或者凹凸信息，负梯度方向$-\rm \textbf g=-\nabla f(\rm \textbf x)$则指示了$f(\rm \textbf x)$在$\rm \textbf x$处的最速下降方向。<br>根据Kelley(1999)，$N \times 1$矢量$\rm \textbf x$的欧几里得范数（Euclidean norm)定义为：</p>
<script type="math/tex; mode=display">||\rm \textbf x||_2:=\sqrt{\underset {i=1,...,N}  \Sigma x^2_i} \tag {2.6}</script><p>由欧几里得范数推导得到矩阵范数：</p>
<script type="math/tex; mode=display">||L||_2:=\rm \underset {x≠0} max \frac{||\rm \textbf {Lx}||_2}{||\rm \textbf x||_2}\tag{2.7}</script><p>假设$f(\rm \textbf x)$二阶可微，将$f(\rm \textbf x_0+\Delta \rm \textbf x)$在$\rm \textbf x_0$处展开可得：</p>
<script type="math/tex; mode=display">f(\rm \textbf x_0+\Delta \rm \textbf x)=f(\rm \textbf x_0)+\rm \textbf g^T \Delta \rm \textbf x+\frac{1}{2} \Delta \rm \textbf x^T \nabla \nabla^Tf(\rm \textbf x_0)\Delta \rm \textbf x + o(||\Delta \rm \textbf x||^3) \tag{2.8}</script><p>忽略高阶项后可以得到二次模型近似：</p>
<script type="math/tex; mode=display">\begin{align}
\notag f(\rm \textbf x_0+\Delta \rm \textbf x)&≈f(\rm \textbf x_0)+\rm \textbf g^T \Delta \rm \textbf x+\frac{1}{2} \Delta \rm \textbf x^T \nabla \nabla^Tf(\rm \textbf x_0)\Delta \rm \textbf x \\
\notag &= f(\rm \textbf x_0)+ \rm \textbf g^T \Delta \rm \textbf x +\frac{1}{2} \Delta \rm \textbf x^T \rm \textbf H \Delta \rm \textbf x
\notag \end{align} 
\tag{2.9}</script><p>如果存在局部或全局最小点$\rm \textbf x^{\ast}$，则图2.1中的一维曲线需满足$\partial f(\rm \textbf x^{\ast})/\partial x=0$,$\partial^2 f(\rm \textbf x^{\ast})/\partial x^2&gt;0$<br>多维情况下的最优条件为：</p>
<script type="math/tex; mode=display">\nabla f(\rm \textbf x^{\ast})=0 \space and \space  \Delta \rm \textbf x^T \nabla \nabla^Tf(\rm \textbf x^{\ast})\Delta \rm \textbf x>0\tag {2.10}</script><p>其中，第二个条件定义了Hessian矩阵的正定性。<br>许多地球物理问题使用$\rm \textbf L^T\rm \textbf L$，即反传算子$\rm \textbf L^T$和正传算子$\rm \textbf L$的级联，来近似Hessian矩阵$\rm \textbf H$。如果$\rm \textbf L$为实数，对于实特征矢量$\rm \textbf x_i$，有：</p>
<script type="math/tex; mode=display">\rm \textbf x^T_i[\rm \textbf L^T\rm \textbf L]\rm \textbf x_i = \lambda_i \rm \textbf x^T_i \rm \textbf x_i≥0\tag{2.11}</script><p>这里的不等号是由于$||\rm \textbf {Lx}||_i≥0$。当$\rm \textbf x$不在原点时$\rm \textbf x^T_i \rm \textbf x_i&gt;0$，所以有$\lambda_i≥0$，也因此在时空域的最小二乘偏移和全波形反演的Hessian矩阵至少是半正定的。</p>
<h1 id="2-2-梯度优化，泰勒级数和牛顿方法"><a href="#2-2-梯度优化，泰勒级数和牛顿方法" class="headerlink" title="2.2 梯度优化，泰勒级数和牛顿方法"></a>2.2 梯度优化，泰勒级数和牛顿方法</h1><p>公式2.9可以表示为:</p>
<script type="math/tex; mode=display">f(\rm \textbf x_0+\Delta \rm \textbf x) ≈ f(\rm \textbf x_0)+ \underset {i=1:N} \Sigma \frac{\partial f(\rm \textbf x_0)}{\partial x_i}\Delta x_i +\frac{1}{2} \underset {i=1:N} \Sigma\underset {j=1:N} \Sigma \frac{\partial^2 f(\rm \textbf x_0)}{\partial x_i \partial x_j}\Delta x_i\Delta x_j \tag{2.12}</script><p>对于一个足够小的$\Delta \rm \textbf x$，截断泰勒级数是原函数在$\rm \textbf x_0+\Delta \rm \textbf x$一个较好的近似。当N=2时，，公式2.12是一个椭圆，其最小值在$\rm \textbf x^{\ast}$。如果Hessian矩阵中的交叉项为0（即$\partial ^2f(\rm \textbf x)/\partial x_i \partial x_j=0 \space for \space i !=j$)，椭圆的最大轴和最小轴将和$x_1$、$x_2$平行，否则他们将和图2.2所示一样有一定角度的旋转。<br><img src="/2022/12/19/seismic_inversion_2/Figure2.2.png" alt="Figure2.2"></p>
<p>定义$\Delta \rm \textbf x = \rm \textbf  x - \rm \textbf x_0$，$\partial \Delta x_i/\partial x_k=\delta_{ik}$，将第k个分量的梯度带入得：</p>
<script type="math/tex; mode=display">\begin{align}
\notag \frac{\partial f(\rm \textbf x)}{\partial x_k}&=\frac{\partial f(\rm \textbf x+\Delta \rm \textbf x)}{\partial x_k}\\
\notag & = \frac {\partial f(\rm \textbf x_0)}{\partial x_k}+\underset {j=1:N}\Sigma \frac{\partial^2f(\rm \textbf x_0)}{\partial x_k \partial x_j} \Delta x_j
\notag \end{align}
\tag{2.13}</script><p>如果$\rm \textbf x$在$f(\rm \textbf x)$的最小值点上，那么$\frac{\partial f(\rm \textbf x)}{\partial x_k}=0$，公式2.13可化简为线性系统：</p>
<script type="math/tex; mode=display">g_k=-\Sigma_{j=1}^{N} \frac{\partial ^2 f(\rm \textbf x_0)}{\partial x_k \partial x_j} \Delta x_j \space or \space \rm \textbf g=-\rm \textbf H \Delta \rm \textbf x\tag{2.14}</script><p>其中$g_k=\partial f(\rm \textbf x)/ \partial x_k | \rm \textbf x=\rm \textbf x_0$</p>
<p>求解2.14中$\Delta \rm \textbf x$可得：</p>
<script type="math/tex; mode=display">\Delta \rm \textbf x = - \rm \textbf H^{-1}\rm \textbf g \tag {2.15}</script><p>因此，给定一个试验模型$\rm \textbf x_0$，利用梯度优化算法求解2.14中的$\Delta \rm \textbf x$进而求得$\rm \textbf x^{\ast}=\rm \textbf x_0+\Delta \rm \textbf x$来减小目标函数$f(\rm \textbf x)$。<br>如果方程构成的系统是线性的，那么其构成的Hessian矩阵与$\rm \textbf x$无关，，所以二次函数为如图2.2所示的椭圆。在这种情况下，可以直接使用LU分解来求解$\rm \textbf x^{\ast}$。这种方法被称线性牛顿方法。如果直接求解较为困难，则可以采用迭代方程</p>
<script type="math/tex; mode=display">x^{(k+1)}_i=x^{k}_i-\underset{j}\Sigma\beta^{(k)}_{ij}g^{(k)}_j,  \tag{2.16}</script><p>通过对梯度分量加权，即$\beta^{(k)}_{ij}g^{(k)}_j$来迭代地更新解$x^{(k)}_i$，其中$\beta_{ij}$是权系数。例如，最速下降法中，定义$\beta^{(k)}_{ij}=\delta_{ij}\alpha^{(k)}$，其中$\alpha^{(k)}$为第$k$次迭代的步长。在合适的条件下，迭代梯度方法将使模型收敛到$\rm \textbf x^{\ast}$。在公式2.16两侧同时减去$\rm \textbf x_0$得到等价的更新公式：</p>
<script type="math/tex; mode=display">\Delta x^{(k+1)}_i=\Delta x^{k}_i-\underset{j}\Sigma\beta^{(k)}_{ij}g^{(k)}_j,\tag{2.17}</script><p>其中，公式2.17中更新的是扰动矢量分量$\Delta x_i$而不是实际的解的分量。<br><img src="/2022/12/19/seismic_inversion_2/Figure2.3.png" alt="Figure2.3"><br>如果$f(\rm \textbf x)$为多项式形式而不是二次型，那么他的等值面僵尸非椭圆的，如图2.3所示，Hessian$\rm \textbf H=\rm \textbf H(\rm \textbf x)$依赖于$\rm \textbf x$，这时需要非线性的牛顿迭代法来更新解：</p>
<script type="math/tex; mode=display">\rm \textbf x^{(k+1)}=\rm \textbf x^{(k)}-\alpha[\rm \textbf H^{(k)}]^{-1}\rm \textbf g^{(k)}\tag{2.18}</script><p>这里的$\alpha$与二次目标函数的相同，均为标量步长，非二次型函数的步长需要在每次迭代中重新确定。如果利用$\delta_{ij}/H^{(k)}_{ii}$来近似$[\rm \textbf H^{(k)}]^{-1}_{ij}$，那么公式2.18即为预处理的最速下降法。对方程所构建系统进行预处理的目的是寻找一个预处理算子$\rm \textbf P$来减小$\rm \textbf {HP}$或$\rm \textbf {PH}$预处理系统矩阵的数量，其中预处理算子$\rm \textbf P$近似Hessian矩阵$\rm \textbf H$的逆。</p>
<p>另一种用矢量近似$[\rm \textbf H^{(k)}]^{-1} \rm \textbf g^{(k)}$的方法是求取前一次更新方向的共轭，即共轭方向方法，其中共轭梯度（conjugate-gradient，CG）法是一种特例。共轭梯度法或最速下降法的优势是不需要求取Hessian矩阵的逆、不需要存储大量的矩阵。但是，对于有许多局部极小值点的目标函数而言，梯度优化方法不能保证收敛到全局最小。</p>
<h1 id="2-3-梯度和Hessian的几何解释"><a href="#2-3-梯度和Hessian的几何解释" class="headerlink" title="2.3 梯度和Hessian的几何解释"></a>2.3 梯度和Hessian的几何解释</h1><p>下面通过Rosenbrock函数来对梯度和Hessian作几何上的解释，Rosenbrock方程如下：</p>
<script type="math/tex; mode=display">f(\rm \textbf x)=100(x_2-x_1)^2+(1-x_1)^2,\tag{2.19}</script><p>其为一个平滑但是强非线性的函数，如图2.3所示。其梯度矢量为</p>
<script type="math/tex; mode=display">
\begin{align}
\notag \nabla f(\rm \textbf x)&=\rm \textbf g\\
\notag &=[\frac{\partial f}{\partial x_1} \frac{\partial f}{\partial x_2}]^T\\
\notag & =[-400x_1(x_2-x_1^2)-2(1-x_1)^2\space, \space200(x_2-x_1^2)]^T
\end{align}
\tag{2.20}</script><p>为了更好的解释梯度物理意义，我们定义多维空间中一条线上的点为：</p>
<script type="math/tex; mode=display">\rm \textbf x(\alpha)=\rm \textbf x' +\alpha \hat {\rm \textbf s}</script><p>其中$\hat {\rm \textbf s}$为平行于特定线的单位矢量，$\alpha$为控制矢量$\rm \textbf x$距离起始点$\rm \textbf x(\alpha =0)=\rm \textbf x’$的标量参数，定义沿公式2.1中线$\hat {\rm \textbf s}$的方向导数为$df/ d \alpha$:</p>
<script type="math/tex; mode=display">
\begin{align}
\frac{df(\rm \textbf x)}{d\alpha} \notag& = \Sigma_i \nabla f(\rm \textbf x) \hat {\rm \textbf s} \\
\notag & = \Sigma_i \frac{df(\rm \textbf x)}{dx_i} \frac{dx_i}{d\alpha} \\
\notag & = \hat {\rm \textbf s}^T \nabla f(\rm \textbf x)
\end{align}
\tag{2.22}</script><p>其中$\hat {\rm \textbf s}^T \nabla f(\rm \textbf x)$为梯度沿着线方向的投影。如果$\hat {\rm \textbf s}$平行于等高线切线方向，那么$f(\rm \textbf x)$不会沿着这个方向变化，所以$\hat {\rm \textbf s}^T \nabla f(\rm \textbf x)=0$。这意味着梯度$\rm \textbf g=\nabla f(\rm \textbf x)$垂直于等高切线，或者说其平行于最速下降方向。一维情况下，梯度就是斜率，如果斜率大于零，上升方向为右，否则其向左。<br>$f(\rm \textbf x)$的二阶导数构成了$2\times 2$的Hessian矩阵：</p>
<script type="math/tex; mode=display">
\begin{align}
\rm \textbf H \notag &=[\nabla \nabla^T]f(\rm \textbf x) \\
\notag & =
\begin{bmatrix}
\frac{\partial^2 f}{\partial x_1^2} & \frac{\partial^2 f}{\partial x_1x_2} \\
\frac{\partial^2 f}{\partial x_1x_2} & \frac{\partial^2 f}{\partial x_2^2} \\
\end{bmatrix}\\
\notag & =
\begin{bmatrix}
1200x_1^2-400x_2+2 & -400x_1\\
-400x_1 & 200\\
\end{bmatrix}
\end{align}
\tag{2.23}</script><p>与二次函数的椭圆等值面和常数Hessian矩阵不同的是，2.23说明Hessian矩阵中的曲率值依赖于$\rm \textbf x$，且其多项式阶数大于2。<br>与将$\hat {\rm \textbf s}^T \nabla f(\rm \textbf x)$定义为$f(\rm \textbf x)$沿着线方向$\hat {\rm \textbf s}$的斜率相同，二阶导数、或者说$f(\rm \textbf x)$沿着相同线的曲率为</p>
<script type="math/tex; mode=display">\frac{d^2f}{d\alpha^2}
=\frac{d}{d\alpha}\frac{df}{d\alpha}
=\frac{d}{d\alpha}[(\nabla f)^2]\hat {\rm \textbf s}
=\hat {\rm \textbf s}^T [\nabla \nabla^T f(\rm \textbf x)]\hat {\rm \textbf s}
\tag{2.24}</script><p>因此，$\hat {\rm \textbf s}^T \rm \textbf H \hat {\rm \textbf s}$给出了$f(\rm \textbf x)$沿着特定方向$\hat {\rm \textbf s}$的曲率。</p>
<h2 id="例子2-5-1-一维函数"><a href="#例子2-5-1-一维函数" class="headerlink" title="例子2.5.1 一维函数"></a>例子2.5.1 一维函数</h2><p>对于一元函数，公式2.14变为：</p>
<script type="math/tex; mode=display">\frac{\partial f(x_0)}{\partial x}
=-\frac{\partial^2 f(x_0)}{\partial x^2} \Delta x,
\tag{2.26}</script><p>可得$\Delta x$为：</p>
<script type="math/tex; mode=display">\Delta x=
- \frac{\partial f(x_0)}{\partial x}
/ \frac{\partial^2 f(x_0)}{\partial x^2} ,
\tag{2.26}</script><p>带入公式2.18可得一元非线性函数的牛顿迭代公式为：</p>
<script type="math/tex; mode=display">x^{(k+1)}=x^{(k)}
-\alpha 
\frac{\partial f(x_k)}{\partial x}
/ \frac{\partial^2 f(x_k)}{\partial x^2}.
\tag{2.28}</script><p>一般情况下，牛顿法的收敛速度取决于topography（由方程的曲率和斜率决定）和起始点据全局最小值的距离。<br>下面的python代码例子展示如何利用牛顿法求解一元非二次方程$f(x)=ax^4+x^2-2x$的最小值问题，迭代过程中求得的$x^k$及原函数如图2.5所示，每次迭代求得的最小值与实际最小值的残差方如图2.6所示。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">1D Newton method to find zeros of a quartic function</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">a = <span class="number">7</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">x, a=a</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :param x: 自变量x</span></span><br><span class="line"><span class="string">    :param a: 常数a</span></span><br><span class="line"><span class="string">    :return: 返回一元四次函数在x处的值</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> a*x**<span class="number">4</span>+x**<span class="number">2</span>-<span class="number">2</span>*x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">x0 = -<span class="number">0.5</span>  <span class="comment"># 起始点</span></span><br><span class="line">iterations = <span class="number">10</span>  <span class="comment"># 迭代次数</span></span><br><span class="line">xx = np.zeros(iterations)  <span class="comment"># 存储每次的x</span></span><br><span class="line">residual = np.zeros(iterations)</span><br><span class="line">xx[<span class="number">0</span>] = x0</span><br><span class="line">residual[<span class="number">0</span>] = <span class="built_in">abs</span>(f(np.arange(-<span class="number">2</span>, <span class="number">2</span>, <span class="number">0.1</span>)).<span class="built_in">min</span>()-f(x0))</span><br><span class="line"><span class="keyword">for</span> it <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, iterations):</span><br><span class="line">    x0 = xx[it-<span class="number">1</span>]</span><br><span class="line">    f1prime = a * <span class="number">4</span> * x0**<span class="number">3</span> + <span class="number">2</span> * x0 - <span class="number">2</span>  <span class="comment"># f(x)的一阶导数</span></span><br><span class="line">    f2prime = a * <span class="number">12</span> * x0**<span class="number">2</span> + <span class="number">2</span>  <span class="comment"># f(x)的二阶导数</span></span><br><span class="line">    xx[it] = xx[it-<span class="number">1</span>]-f1prime/f2prime  <span class="comment"># Newton formula</span></span><br><span class="line">    residual[it] = <span class="built_in">abs</span>(f(np.arange(-<span class="number">2</span>, <span class="number">2</span>, <span class="number">0.1</span>)).<span class="built_in">min</span>()-f(xx[it]))**<span class="number">2</span> <span class="comment"># 计算与实际最小值的残差方</span></span><br><span class="line"></span><br><span class="line">plt.plot(np.arange(-<span class="number">2</span>, <span class="number">2</span>, <span class="number">0.1</span>), f(np.arange(-<span class="number">2</span>, <span class="number">2</span>, <span class="number">0.1</span>)))</span><br><span class="line"><span class="keyword">for</span> idx, _xx <span class="keyword">in</span> <span class="built_in">enumerate</span>(xx.ravel()):</span><br><span class="line">    <span class="comment">#plt.scatter(_xx, f(_xx))</span></span><br><span class="line">    plt.annotate(<span class="string">f&quot;iter:<span class="subst">&#123;idx+<span class="number">1</span>&#125;</span>&quot;</span>, xy=(_xx, f(_xx)), xytext=(_xx+<span class="number">0.1</span>, f(_xx)+<span class="number">0.1</span>))</span><br><span class="line">plt.title(<span class="string">&quot;Quartic Function y=ax^4+x^2-2x&quot;</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line">plt.plot(residual)</span><br><span class="line">plt.title(<span class="string">&quot;Residual&quot;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><br><img src="/2022/12/19/seismic_inversion_2/Figure2.5.png" alt="Figure2.5"><br><img src="/2022/12/19/seismic_inversion_2/Figure2.6.png" alt="Figure2.6"></p>
<h2 id="2-5-2-2维函数"><a href="#2-5-2-2维函数" class="headerlink" title="2.5.2 2维函数"></a>2.5.2 2维函数</h2><p>下面展示的是利用牛顿法求二维函数$f(x_1, x_2)=100(x_2-x_1^2)^2+(1-x_1)^2$的最小值的过程，其等值面及每次迭代求得的自变量值如图2.7所示。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Iterative Newton method for finding minimizer</span></span><br><span class="line"><span class="comment"># of Rosenbrock function</span></span><br><span class="line"><span class="comment"># f=100.*(x2-x1.^2).^2+(1-x1).^2</span></span><br><span class="line"><span class="comment"># Minimizer point=(1,1)</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> mpl_toolkits.mplot3d <span class="keyword">import</span> Axes3D</span><br><span class="line"></span><br><span class="line">x1_0 = <span class="number">.6</span>  <span class="comment"># 第一个变量的起始坐标</span></span><br><span class="line">x2_0 = <span class="number">.4</span>  <span class="comment"># 第二个变量的起始坐标</span></span><br><span class="line">x0 = [x1_0, x2_0]  <span class="comment"># 起始x矢量坐标 x0=[x1, x2, ..., xn]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">x1, x2</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="number">100.</span>*(x2-x1**<span class="number">2</span>)**<span class="number">2</span>+(<span class="number">1</span>-x1)**<span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">iterations = <span class="number">10</span>  <span class="comment"># 迭代次数</span></span><br><span class="line">xx = np.zeros((iterations, <span class="built_in">len</span>(x0)), np.float32)</span><br><span class="line">xx[<span class="number">0</span>, :] = x0  <span class="comment"># 将第0次迭代结果设置为起始点x0</span></span><br><span class="line"><span class="comment"># 迭代</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, iterations):</span><br><span class="line">    x1, x2 = xx[i-<span class="number">1</span>,:]</span><br><span class="line">    <span class="built_in">print</span>(x1, x2, f(x1, x2))</span><br><span class="line">    <span class="comment"># 梯度 2x1矩阵</span></span><br><span class="line">    g = np.array([-<span class="number">400</span>*x1*(x2-x1**<span class="number">2</span>)-<span class="number">2</span>*(<span class="number">1</span>-x1), <span class="number">200</span>*(x2-x1**<span class="number">2</span>)])</span><br><span class="line">    <span class="comment"># Hessian矩阵 2x2矩阵</span></span><br><span class="line">    H = np.array([[<span class="number">1200</span>*x1**<span class="number">2</span>-<span class="number">400</span>*x2+<span class="number">2</span>, -<span class="number">400</span>*x1],</span><br><span class="line">                  [-<span class="number">400</span>*x1, <span class="number">200</span>]])</span><br><span class="line">    <span class="comment"># Non-linear Newton formula</span></span><br><span class="line">    <span class="comment"># Update iterative solution</span></span><br><span class="line">    xx[i] = xx[i-<span class="number">1</span>] - np.linalg.inv(H)@g</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示结果</span></span><br><span class="line">x = np.arange(<span class="number">0.2</span>, <span class="number">1.25</span>, <span class="number">0.05</span>)</span><br><span class="line">y = np.arange(<span class="number">0.2</span>, <span class="number">1.25</span>, <span class="number">0.05</span>)</span><br><span class="line">X, Y = np.meshgrid(x, y)</span><br><span class="line">Z = f(X, Y)</span><br><span class="line"><span class="comment">#fig = plt.figure()</span></span><br><span class="line"><span class="comment">#ax = fig.add_axes(Axes3D(fig))</span></span><br><span class="line"><span class="comment">#ax.plot_surface(X, Y, Z, rstride=1, cstride=1, cmap=&#x27;rainbow&#x27;)</span></span><br><span class="line">fig, ax = plt.subplots(<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"><span class="comment"># 绘制函数等值面</span></span><br><span class="line">C = ax.contour(X, Y, Z, <span class="number">20</span>)</span><br><span class="line">ax.clabel(C, inline=<span class="literal">True</span>, fontsize=<span class="number">12</span>)</span><br><span class="line"><span class="comment"># 获取迭代数据</span></span><br><span class="line">x, y = xx[:, <span class="number">0</span>], xx[:, <span class="number">1</span>]</span><br><span class="line">z = f(x, y)</span><br><span class="line">ax.scatter(x, y, z, marker=<span class="string">&quot;*&quot;</span>, c=<span class="string">&quot;black&quot;</span>, linewidths=<span class="number">5</span>)</span><br><span class="line"><span class="comment"># 绘制</span></span><br><span class="line"><span class="keyword">for</span> idx <span class="keyword">in</span> <span class="built_in">range</span>(iterations-<span class="number">1</span>):</span><br><span class="line">    ax.arrow(x[idx], y[idx],</span><br><span class="line">             dx=x[idx+<span class="number">1</span>]-x[idx],</span><br><span class="line">             dy=y[idx+<span class="number">1</span>]-y[idx], head_width=<span class="number">0.02</span>)</span><br><span class="line"><span class="keyword">for</span> idx, _xx, _yy <span class="keyword">in</span> <span class="built_in">zip</span>(<span class="built_in">range</span>(<span class="number">10</span>), x.ravel(), y.ravel()):</span><br><span class="line">    ax.annotate(<span class="string">f&quot;iter:<span class="subst">&#123;idx+<span class="number">1</span>&#125;</span>&quot;</span>, xy=(_xx, _yy), xytext=(_xx+<span class="number">0.001</span>, _yy+<span class="number">0.001</span>))</span><br><span class="line">ax.set_xlabel(<span class="string">&quot;x&quot;</span>)</span><br><span class="line">ax.set_xlabel(<span class="string">&quot;y&quot;</span>)</span><br><span class="line">ax.set_title(<span class="string">&quot;Rosenbrock function&quot;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><br><img src="/2022/12/19/seismic_inversion_2/Figure2.7.png" alt="Figure2.7"></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Seismic Inversion</category>
      </categories>
      <tags>
        <tag>反问题 2</tag>
      </tags>
  </entry>
  <entry>
    <title>第一章 前言</title>
    <url>/2022/12/18/seismic_inversion_1.2/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="反问题"><a href="#反问题" class="headerlink" title="反问题"></a>反问题</h1><p>在野外地震勘探中，我们采集地震数据<strong>d</strong>的过程实际上是一个正演过程，即：</p>
<script type="math/tex; mode=display">{\rm \textbf d}={\rm \textbf {Lm}}</script><p>其中，$\rm \textbf L$为隐式地依赖模型$\rm \textbf m$的非线性正演算子，其能够通过模型$\rm \textbf m$预测数据$\rm \textbf d$。如果原始的正演算子是非线性的，那么它通常可以通过背景模型来线性化。此时，我们可以将地球物理反问题定义为利用记录的数据矢量$\rm \textbf d$反演模型矢量$\rm \textbf m$。</p>
<p>据Hadamard(1902)，适定数学模型，例如线性化后的${\rm \textbf d}={\rm \textbf {Lm}}$，具有以下特点：</p>
<ol>
<li>存在解。对于地球物理数据而言，噪声较多引起方程不相同或超定会导致解不存在。一个解决办法是寻找能够使得数据误差和惩罚项的加权和最小的解。</li>
<li>解是唯一的。常规的地球物理勘探中，检波器和震源只布设在有限区域内，这样会导致$\rm \textbf L$存在非空零空间，进而使得$\rm \textbf L^T \rm \textbf T$有零特征值。我们通常使用正则化来缓解这一问题。</li>
<li>解持续地依赖数据，否则解将会不稳定。例如，当数据中噪声水平产生微小变化时，肯恩贵引起模型的不连续变化（当病态矩阵$\rm \textbf L$存在许多接近于零的特征值时，会使得许多模型都能拟合相同的数据）。</li>
</ol>
<p>我们通常会改写反问题以使我们能够找到一个最优模型，这个最优模型能够使数据误差和惩罚方程的加权和最小。</p>
<h1 id="旅行时成像-Traveltime-tomography"><a href="#旅行时成像-Traveltime-tomography" class="headerlink" title="旅行时成像 Traveltime tomography"></a>旅行时成像 Traveltime tomography</h1><p>旅行时成像是通过拾取的特定同相轴的旅行时来估计地下速度分布。旅行时层析需要六个步骤，这六个步骤对于大多数其他地球物理反演问题也是是适用的。</p>
<ol>
<li><strong>模型</strong>$\rm \textbf m$<strong>的离散</strong>。地球慢度模型被离散化为一系列未知慢度的网格，每一个网格点上都有一个未知的慢度值。假设网格非常细所以在第$j$个网格中慢度$s_j$为常数。$N$个未知慢度构成了$N \times1$的模型矢量$\rm \textbf m$。</li>
<li><strong>数据</strong>$\rm \textbf d$<strong>的离散</strong>。对于初至旅行时成像，我们首先要拾取每一道的初至并记为第$i_{th}$射线的时间$t_i$。$M$道数据能够形成$M\times1$的数据矢量$\rm \textbf d$。</li>
<li><strong>模型算子</strong>$\rm \textbf L$<strong>的离散</strong>。通过给定一个初始模型和基于正演算子$\rm \textbf L$生成的预测数据来解决反问题。旅行时成像是基于高频近似假设的，因此第$i_{th}$射线的旅行时是所有单元格中旅行时$d_i$的和。<script type="math/tex; mode=display">\underset{j} \Sigma l_{ij}m_j=d_i \rm \space or  \space \rm \textbf {Lm}=\rm \textbf d \tag{1.4}</script>其中，$l_{ij}$是第$i$条射线在第$j$个单元格中的射线路径段长度，$m_j$是第$j$个单元格中的常慢度$s_j$。这里，$\rm \textbf L$是$M\times N$的矩阵。</li>
<li><strong>线性化</strong>。方程$1.4$是非线性的，因为射线路径段长度$l_{ij}$取决于速度模型。这并不奇怪，因为根据$Snell$定律，较大的速度梯度变化将会引起射线路径的较大变化。所以$L$隐式地依赖模型$\rm \textbf m$，所以除非我们的初始慢度模型非常接近实际模型，否则将无法反演出好的结果。解决办法是我们从一个接近于真实模型的模型$m^{(0)}=m_o$出发，对模型与数据之间的关系进行线性化。然后利用数据反演出一个更准确的模型$m^{(1)}$，将其作为新的初始模型，反复迭代直到收敛。<br>定义第$j$个模型参数为$m_j$，通过将在$\rm \textbf m$下观测到的数据$d_i(\rm \textbf m)$在初始模型$\rm \textbf m_o$处泰勒一阶展开来将其线性化：<script type="math/tex; mode=display">d_i(\rm \textbf m) \approx d_i (\rm \textbf m_o) + \underset {j} \Sigma [ \frac { \partial d_i (\rm \textbf m)} {\partial m_j}]_{\rm \textbf m_o} \delta m_j, \tag{1.5}</script>其中，$\rm \textbf m=\rm \textbf m_o+\delta \rm \textbf m$。所以有<script type="math/tex; mode=display">\delta d_i(\rm \textbf m)= \underset {j} \Sigma [\frac{\partial d_i(\rm \textbf m)} {\partial m_j}] {\rm \textbf m_o} \delta m_j, \tag{1.6}</script>或者写成矩阵矢量形式<script type="math/tex; mode=display">\delta \rm \textbf d(\rm \textbf m)=\rm \textbf L(\delta \rm \textbf m),\tag{1.7}</script>这里，数据残差$\delta d_i=[d_i(\rm \textbf m)-d_i(\rm \textbf m_o)]$为观测数据第$i$个分量$\rm \textbf d_i(\rm \textbf m)$与预测数据第$i$个分量$\rm \textbf d_i(\rm \textbf m_o)$的差，模型扰动$\delta \rm \textbf m=\rm \textbf m-\rm \textbf m_o$为实际模型$\rm \textbf m$与猜测模型$\rm \textbf m_o$的误差。矩阵$\rm \textbf L$为雅可比矩阵，其元素为$l_{ij} = \frac{\partial d_i (\rm \textbf m_o) } {\partial m_j}$，即$Fr\acute echet$导数，表示第$i$个数据相对于模型扰动在第$j$个单元格处的敏感核。<br>对于旅行时成像和较小的单元格，$Fr\acute echet$导数可以表示为射线段长度$l_{ij}$在第$j$个单元格第$i$条射线，公式$(1.6)$变为<script type="math/tex; mode=display">\delta t_i=\Sigma_j l_{ij}\delta s_j \tag {1.8}</script></li>
<li><strong>正则化解</strong>。记录数据含有的噪声会导致一组不一致的(inconsistent)（当我们使用的模拟算子无法模拟数据所需要的所有的物理信息时，也会出现不一致问题）超定方程。此外，由于许多模型都可以满足相同的数据，所以解可能是不稳定的。<br>为了一定程度上解决这种问题，我们通常寻找能够使得目标函数$\epsilon$最小的模型，目标函数由一个惩罚项和数据残差的$p$范数的$p$次方构成：<script type="math/tex; mode=display">\epsilon=\frac{1}{p} ||\rm \textbf L\delta \rm \textbf m-\delta \rm \textbf d||^p_p+ \eta^2g(\rm \textbf m), \tag {1.9}</script>其中$\eta^2$为一个非常小的正数，$g(\rm \textbf m)$是惩罚因子项，当估计模型接近实际模型的先验估计时其会变得很小。$p$是正整数，残差矢量$\rm \textbf L \delta \rm \textbf m-\delta \rm \textbf d$是观测数据和预测数据之差。当$p=2$时，残差矢量的平方长度即为误差函数。<br>有时惩罚项会被表示为$g(\rm \textbf m)=\frac{1}{p} ||m-m^{‘}||^p_p$（模型残差），其中$m^{‘}$为先验模型。通常设置$p=2$，即平方数据残差和约束模型惩罚之和$||\rm \textbf L \delta \rm \textbf m -\delta \rm \textbf d ||^2+\eta ^2||\delta \rm \textbf m||^2$作为目标函数。这种情况下，正则化阻尼最小二乘解为:<script type="math/tex; mode=display">\delta \rm \textbf m=[\rm \textbf L^{\rm \textbf T}\rm \textbf T + \eta^2\rm \textbf I]^{-1}\rm \textbf L ^{\rm \textbf T}\delta \rm \textbf d, \tag {1.10}</script>其中$I$为单位矩阵，当元素均为复数时转置算子表示复共轭。对于复数，我们使用伴随符号$\dagger$代替转置符号。</li>
<li><strong>迭代正则化解</strong>。数据与模型之间的关系通常是非线性的，所以公式$1.10$的解常由迭代的形式来得到:<script type="math/tex; mode=display">\rm \textbf m^{(k+1)}=\rm \textbf m^{(k)}-\alpha [\rm \textbf L^{\rm \textbf T}\rm \textbf T + \eta^2\rm \textbf I]^{-1}\rm \textbf L ^{\rm \textbf T}\delta \rm \textbf d^{(k)},\tag {1.11}</script>其中，$\alpha$为步长，$\rm \textbf m^{(k)}$（$\delta \rm \textbf d^{(k)}$）表示第$k$次迭代的模型（数据残差）。与矩阵$\rm \textbf L$相关的射线是由第$k$次的速度模型计算得到的，不断迭代得到后续的速度模型知道数据残差到我们能够接受的水平。矩阵$[\rm \textbf L^T\rm \textbf L]$的求取、存储和反演成本巨大，因此我们通常使用其主对角元素$[\rm \textbf L^T\rm \textbf L]_{ij} ≈[\rm \textbf L^T\rm \textbf L]_{ii}\delta _{ij}$来获得预处理后的最速下降梯度解。<script type="math/tex; mode=display">\delta m_i^{(k+1)}=\delta m_i^{(k)}-\frac{\alpha [\rm \textbf L ^{\rm \textbf T}\delta \rm \textbf d^{(k)}]} {[\rm \textbf L^T \rm \textbf L]_{ii}+\eta^2},\tag {1.12}</script>非线性地震反演的主要问题是目标函数常常包含许多局部小值；所以，迭代解通常会陷入局部极小并且永远无法达到全局最优，或者无法反演到真实模型。为了避免这一问题，我们通常在前面的迭代中只反演重要的特征（骨骼化数据，Luo and Schuster，1991a；1991b），即反演长波长信息，后续的反演中慢慢添加高阶信息。<br>常见的骨骼化的方法包括multi-scale反演，early-arrivals反演，near-offset反演等。在后续的反演中逐渐添加远偏移距、长记录、以及更复杂的物理信息。</li>
</ol>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Seismic Inversion</category>
      </categories>
      <tags>
        <tag>反问题 1.2</tag>
      </tags>
  </entry>
  <entry>
    <title>styleGAN源码解读之network.py(一)</title>
    <url>/2020/07/11/styleGAN-network1/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="styleGAN—-network-py"><a href="#styleGAN—-network-py" class="headerlink" title="styleGAN—-network.py"></a>styleGAN—-network.py</h1><h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><p>源码文件位于<code>dnnlib/tflib</code>中过长，将近<strong>600</strong>行，这里只放出<strong>Network</strong>类中部分函数，当存在函数调用关系时再给出相应的源码及其解读。(在代码的复制粘贴过程中源代码格式遭到破坏(排版出现问题)，请勿直接复制以下代码，如有需要请下载<a href="https://github.com/NVlabs/stylegan">源代码<Github项目链接></Github项目链接></a>。另外，文中对run方法的测试均是通过调用pretrained.py后得到的结果,在运行不同配置train.py时得到的结果可能会略有差异，一般体现在minibatch大小上。)<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">﻿<span class="comment"># Copyright (c) 2019, NVIDIA CORPORATION. All rights reserved.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># This work is licensed under the Creative Commons Attribution-NonCommercial</span></span><br><span class="line"><span class="comment"># 4.0 International License. To view a copy of this license, visit</span></span><br><span class="line"><span class="comment"># http://creativecommons.org/licenses/by-nc/4.0/ or send a letter to</span></span><br><span class="line"><span class="comment"># Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Network</span>:</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self,</span></span><br><span class="line"><span class="params">        *in_arrays: <span class="type">Tuple</span>[<span class="type">Union</span>[np.ndarray, <span class="literal">None</span>], ...],</span></span><br><span class="line"><span class="params">        input_transform: <span class="built_in">dict</span> = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">        output_transform: <span class="built_in">dict</span> = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">        return_as_list: <span class="built_in">bool</span> = <span class="literal">False</span>,</span></span><br><span class="line"><span class="params">        print_progress: <span class="built_in">bool</span> = <span class="literal">False</span>,</span></span><br><span class="line"><span class="params">        minibatch_size: <span class="built_in">int</span> = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">        num_gpus: <span class="built_in">int</span> = <span class="number">1</span>,</span></span><br><span class="line"><span class="params">        assume_frozen: <span class="built_in">bool</span> = <span class="literal">False</span>,</span></span><br><span class="line"><span class="params">        **dynamic_kwargs</span>) -&gt; <span class="type">Union</span>[np.ndarray, <span class="type">Tuple</span>[np.ndarray, ...], <span class="type">List</span>[np.ndarray]]:</span><br><span class="line"></span><br><span class="line">   <span class="keyword">assert</span> <span class="built_in">len</span>(in_arrays) == self.num_inputs</span><br><span class="line">   <span class="keyword">assert</span> <span class="keyword">not</span> <span class="built_in">all</span>(arr <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">for</span> arr <span class="keyword">in</span> in_arrays)</span><br><span class="line">   <span class="keyword">assert</span> input_transform <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> util.is_top_level_function(input_transform[<span class="string">&quot;func&quot;</span>])</span><br><span class="line">   <span class="keyword">assert</span> output_transform <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> util.is_top_level_function(output_transform[<span class="string">&quot;func&quot;</span>])</span><br><span class="line">   output_transform, dynamic_kwargs = _handle_legacy_output_transforms(output_transform, dynamic_kwargs)</span><br><span class="line">   num_items = in_arrays[<span class="number">0</span>].shape[<span class="number">0</span>]</span><br><span class="line">   <span class="keyword">if</span> minibatch_size <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">       minibatch_size = num_items</span><br><span class="line"></span><br><span class="line">   <span class="comment"># Construct unique hash key from all arguments that affect the TensorFlow graph.</span></span><br><span class="line">   key = <span class="built_in">dict</span>(input_transform=input_transform, output_transform=output_transform, num_gpus=num_gpus, assume_frozen=assume_frozen, dynamic_kwargs=dynamic_kwargs)</span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">unwind_key</span>(<span class="params">obj</span>):</span><br><span class="line">       <span class="keyword">if</span> <span class="built_in">isinstance</span>(obj, <span class="built_in">dict</span>):</span><br><span class="line">           <span class="keyword">return</span> [(key, unwind_key(value)) <span class="keyword">for</span> key, value <span class="keyword">in</span> <span class="built_in">sorted</span>(obj.items())]</span><br><span class="line">       <span class="keyword">if</span> <span class="built_in">callable</span>(obj):</span><br><span class="line">           <span class="keyword">return</span> util.get_top_level_function_name(obj)</span><br><span class="line">       <span class="keyword">return</span> obj</span><br><span class="line">   key = <span class="built_in">repr</span>(unwind_key(key))</span><br><span class="line"></span><br><span class="line">   <span class="comment"># Build graph.</span></span><br><span class="line">   <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> self._run_cache:</span><br><span class="line">       <span class="keyword">with</span> tfutil.absolute_name_scope(self.scope + <span class="string">&quot;/_Run&quot;</span>), tf.control_dependencies(<span class="literal">None</span>):</span><br><span class="line">           <span class="keyword">with</span> tf.device(<span class="string">&quot;/cpu:0&quot;</span>):</span><br><span class="line">               in_expr = [tf.placeholder(tf.float32, name=name) <span class="keyword">for</span> name <span class="keyword">in</span> self.input_names]</span><br><span class="line">               in_split = <span class="built_in">list</span>(<span class="built_in">zip</span>(*[tf.split(x, num_gpus) <span class="keyword">for</span> x <span class="keyword">in</span> in_expr]))</span><br><span class="line"></span><br><span class="line">           out_split = []</span><br><span class="line">           <span class="keyword">for</span> gpu <span class="keyword">in</span> <span class="built_in">range</span>(num_gpus):</span><br><span class="line">               <span class="keyword">with</span> tf.device(<span class="string">&quot;/gpu:%d&quot;</span> % gpu):</span><br><span class="line">                   net_gpu = self.clone() <span class="keyword">if</span> assume_frozen <span class="keyword">else</span> self</span><br><span class="line">                   in_gpu = in_split[gpu]</span><br><span class="line"></span><br><span class="line">                   <span class="keyword">if</span> input_transform <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                       in_kwargs = <span class="built_in">dict</span>(input_transform)</span><br><span class="line">                       in_gpu = in_kwargs.pop(<span class="string">&quot;func&quot;</span>)(*in_gpu, **in_kwargs)</span><br><span class="line">                       in_gpu = [in_gpu] <span class="keyword">if</span> tfutil.is_tf_expression(in_gpu) <span class="keyword">else</span> <span class="built_in">list</span>(in_gpu)</span><br><span class="line"></span><br><span class="line">                   <span class="keyword">assert</span> <span class="built_in">len</span>(in_gpu) == self.num_inputs</span><br><span class="line">                   out_gpu = net_gpu.get_output_for(*in_gpu, return_as_list=<span class="literal">True</span>, **dynamic_kwargs)</span><br><span class="line"></span><br><span class="line">                   <span class="keyword">if</span> output_transform <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                       out_kwargs = <span class="built_in">dict</span>(output_transform)</span><br><span class="line">                       out_gpu = out_kwargs.pop(<span class="string">&quot;func&quot;</span>)(*out_gpu, **out_kwargs)</span><br><span class="line">                       out_gpu = [out_gpu] <span class="keyword">if</span> tfutil.is_tf_expression(out_gpu) <span class="keyword">else</span> <span class="built_in">list</span>(out_gpu)</span><br><span class="line"></span><br><span class="line">                   <span class="keyword">assert</span> <span class="built_in">len</span>(out_gpu) == self.num_outputs</span><br><span class="line">                   out_split.append(out_gpu)</span><br><span class="line"></span><br><span class="line">           <span class="keyword">with</span> tf.device(<span class="string">&quot;/cpu:0&quot;</span>):</span><br><span class="line">               out_expr = [tf.concat(outputs, axis=<span class="number">0</span>) <span class="keyword">for</span> outputs <span class="keyword">in</span> <span class="built_in">zip</span>(*out_split)]</span><br><span class="line">               self._run_cache[key] = in_expr, out_expr</span><br><span class="line"></span><br><span class="line">   <span class="comment"># Run minibatches.</span></span><br><span class="line">   略</span><br><span class="line">   <span class="comment"># Done.</span></span><br><span class="line">   略</span><br><span class="line">   <span class="keyword">return</span> out_arrays</span><br></pre></td></tr></table></figure></p>
<h1 id="代码微调"><a href="#代码微调" class="headerlink" title="代码微调"></a>代码微调</h1><p>如果你的机器环境为单节点单卡，请把以上函数中注释<code>#Build graph</code>以下的所有 <code>with tf.device()</code>设置为你的<strong>GPU</strong>，例如<code>with tf.device(&quot;/gpu:0&quot;)</code>(若只有一张显卡，其对应的设备号为<strong>0</strong>)，以下代码可以查看当前环境下可以使用的<strong>CPU/GPU</strong>设备号：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> tensorflow.python.client <span class="keyword">import</span> device_lib</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(device_lib.list_local_devices())</span><br></pre></td></tr></table></figure></p>
<h1 id="代码逐行分析"><a href="#代码逐行分析" class="headerlink" title="代码逐行分析"></a>代码逐行分析</h1><h2 id="assert"><a href="#assert" class="headerlink" title="assert"></a>assert</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assert</span> <span class="built_in">len</span>(in_arrays) == self.num_inputs</span><br><span class="line"><span class="keyword">assert</span> <span class="keyword">not</span> <span class="built_in">all</span>(arr <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">for</span> arr <span class="keyword">in</span> in_arrays)</span><br><span class="line"><span class="keyword">assert</span> input_transform <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> util.is_top_level_function(input_transform[<span class="string">&quot;func&quot;</span>])</span><br><span class="line"><span class="keyword">assert</span> output_transform <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> util.is_top_level_function(output_transform[<span class="string">&quot;func&quot;</span>])</span><br></pre></td></tr></table></figure>
<p>我们首先看一下<code>assert</code>以及<code>all</code>，<code>not all</code>的用法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># exampe1--assert</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">assert</span> <span class="number">0</span>,<span class="string">&#x27;请检查输入&#x27;</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">AssertionError: 请检查输入</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">assert</span> <span class="number">1</span>,<span class="string">&#x27;pass&#x27;</span> <span class="comment"># 无输出</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">assert</span> <span class="literal">True</span> <span class="keyword">or</span> <span class="literal">False</span> <span class="comment"># 无输出</span></span><br><span class="line"><span class="comment"># example2--all, not all</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Signature: all(iterable, /)</span></span><br><span class="line"><span class="string">Docstring:</span></span><br><span class="line"><span class="string">若可迭代变量iterable中所有的值均为True，则all(iterable)返回True。</span></span><br><span class="line"><span class="string">若iterable为空，也返回True。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">all</span>([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">all</span>([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">not</span> <span class="built_in">all</span>([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>这里，第一行的<code>assert len(in_arrays) == self.num_inputs</code>首先判断输入是否与期望输入长度相等，<strong>in_arrays</strong>为<code>tuple</code>，<code>len(in_arrays)=self.num_inputs=2</code>，<strong>in_arrays[0]</strong> 是一个<strong>size</strong>为<code>(1,512)</code>的<code>np.array</code>，<strong>n_array[1]</strong> 为<strong>Nonetype</strong>。<br>第二行的<code>assert not all(arr is None for arr in in_arrays)</code>将对元组<strong>in_arrays</strong>中的元素进行判断，若所有元素均为<strong>Nonetype</strong>则抛出<code>AssertionError</code>。<br>第三和第四行分别对字典<strong>input_transform</strong>以及<strong>output_transform</strong>进行判断，若其为空或者并没有加载到内存中，则抛出<code>AssertionError</code>。</p>
<h2 id="is-top-level-function"><a href="#is-top-level-function" class="headerlink" title="is_top_level_function"></a>is_top_level_function</h2><p><strong>or</strong>之后的函数原型为：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">is_top_level_function</span>(<span class="params">obj: <span class="type">Any</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">callable</span>(obj) <span class="keyword">and</span> obj.__name__ <span class="keyword">in</span> sys.modules[obj.__module__].__dict__</span><br></pre></td></tr></table></figure><br><code>is_top_level_function</code>用来判断obj是否为顶层函数，即是否是由<strong>def</strong>所定义，然后确认该函数是否已经读取到内存中。<code>sys.modules</code>是一个字典，加载到内存的模块将会以字典的形式存储在其中(第一次导入时自动记录所导入的模块为字典，第二导入则直接从字典中取出相应的键值)。(callable的应用可以查看<a href="https://www.runoob.com/python/python-func-callable.html">链接</a>， 它用于检查一个对象是否是可调用的)<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">Father</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="string">&quot;sdfsfdfs&quot;</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line"><span class="meta">... </span>        self.name=name</span><br><span class="line"><span class="meta">... </span>        <span class="built_in">print</span> ( <span class="string">&quot;name: %s&quot;</span> %( self.name) )</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">def</span> <span class="title function_">getName</span>(<span class="params">self</span>):</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> <span class="string">&#x27;Father &#x27;</span> + self.name</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.modules[Father.__module__].__dict__</span><br><span class="line">&#123;<span class="string">&#x27;__name__&#x27;</span>: <span class="string">&#x27;__main__&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;__doc__&#x27;</span>: <span class="literal">None</span>,</span><br><span class="line"> <span class="string">&#x27;__package__&#x27;</span>: <span class="literal">None</span>,</span><br><span class="line"> <span class="string">&#x27;__loader__&#x27;</span>: &lt;<span class="keyword">class</span> <span class="string">&#x27;_frozen_importlib.BuiltinImporter&#x27;</span>&gt;, </span><br><span class="line"> <span class="string">&#x27;__spec__&#x27;</span>: <span class="literal">None</span>, <span class="string">&#x27;__annotations__&#x27;</span>: &#123;&#125;,</span><br><span class="line"> <span class="string">&#x27;__builtins__&#x27;</span>: &lt;module <span class="string">&#x27;builtins&#x27;</span> (built-<span class="keyword">in</span>)&gt;,</span><br><span class="line"> <span class="string">&#x27;sys&#x27;</span>: &lt;module <span class="string">&#x27;sys&#x27;</span> (built-<span class="keyword">in</span>)&gt;, </span><br><span class="line"> <span class="string">&#x27;Father&#x27;</span>: &lt;<span class="keyword">class</span> <span class="string">&#x27;__main__.Father&#x27;</span>&gt;&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="handle-legacy-output-transforms"><a href="#handle-legacy-output-transforms" class="headerlink" title="_handle_legacy_output_transforms"></a>_handle_legacy_output_transforms</h2><p>**dynamic_kwargs 所接收的动态参数将会被存储为字典，所以<strong>output_transform</strong> 和<strong>dynamic_kwargs</strong>是两个字典，在运行pretrained.py时，二者的<strong>key</strong>和<strong>value</strong>分别为：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(output_transform)</span><br><span class="line">&#123;<span class="string">&#x27;func&#x27;</span>: &lt;function convert_images_to_uint8 at <span class="number">0x7f7dd9468378</span>&gt;, <span class="string">&#x27;nchw_to_nhwc&#x27;</span>: <span class="literal">True</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(dynamic_kwargs)</span><br><span class="line">&#123;<span class="string">&#x27;truncation_psi&#x27;</span>: <span class="number">0.7</span>, <span class="string">&#x27;randomize_noise&#x27;</span>: <span class="literal">True</span>&#125;</span><br></pre></td></tr></table></figure><br>即分别为在<strong>Gs.run</strong>中输入的<code>(truncation_psi=0.7, randomize_noise=True, output_transform=fmt)</code></p>
<h2 id="args-和-kwargs"><a href="#args-和-kwargs" class="headerlink" title="*args 和 **kwargs"></a>*args 和 **kwargs</h2><p>*args 和 **kwargs常用于获取函数的额外参数，通过以下的小例子我们可以清楚看出二者的区别：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">args_and_kwargs</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">type</span>(args))</span><br><span class="line">    <span class="built_in">print</span>(args)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">type</span>(kwargs))</span><br><span class="line">    <span class="built_in">print</span>(kwargs)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>args_and_kwargs(<span class="number">6</span>, <span class="number">8</span>, <span class="string">&#x27;im args&#x27;</span>, num1 = <span class="number">6</span>, num2 = <span class="number">8</span>, strnum = <span class="string">&#x27;im kwargs&#x27;</span>)</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;tuple&#x27;</span>&gt;</span><br><span class="line">(<span class="number">6</span>, <span class="number">8</span>, <span class="string">&#x27;im args&#x27;</span>)</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;dict&#x27;</span>&gt;</span><br><span class="line">&#123;<span class="string">&#x27;num1&#x27;</span>: <span class="number">6</span>, <span class="string">&#x27;num2&#x27;</span>: <span class="number">8</span>, <span class="string">&#x27;strnum&#x27;</span>: <span class="string">&#x27;im kwargs&#x27;</span>&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="handle-legacy-output-transforms-1"><a href="#handle-legacy-output-transforms-1" class="headerlink" title="_handle_legacy_output_transforms"></a>_handle_legacy_output_transforms</h2><p>该函数对<strong>output_transform</strong>, <strong>dynamic_kwargs</strong>两字典中的值进行判断，这里我们只看运行<strong>pretrained.py</strong>时该函数的内部调用情况：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">_print_legacy_warning = <span class="literal">True</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_handle_legacy_output_transforms</span>(<span class="params">output_transform, dynamic_kwargs</span>):</span><br><span class="line">    <span class="keyword">global</span> _print_legacy_warning</span><br><span class="line">    legacy_kwargs = [<span class="string">&quot;out_mul&quot;</span>, <span class="string">&quot;out_add&quot;</span>, <span class="string">&quot;out_shrink&quot;</span>, <span class="string">&quot;out_dtype&quot;</span>]</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">any</span>(kwarg <span class="keyword">in</span> dynamic_kwargs <span class="keyword">for</span> kwarg <span class="keyword">in</span> legacy_kwargs):</span><br><span class="line">        <span class="keyword">return</span> output_transform, dynamic_kwargs</span><br></pre></td></tr></table></figure><br>首先，<code>any</code>的用法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Signature: any(iterable, /)</span></span><br><span class="line"><span class="string">Docstring:</span></span><br><span class="line"><span class="string">若可迭代变量iterable中的任一元素为True，则返回True。</span></span><br><span class="line"><span class="string">若iterable为空，则返回False</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>test = [<span class="literal">True</span>, <span class="literal">False</span>, <span class="literal">False</span>, <span class="literal">False</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">any</span>(test)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">not</span> <span class="built_in">any</span>(test)</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p>所以当 <strong>dynamic_kwargs</strong>与<strong>legacy_kwargs</strong>交集为空时，则原样返回。在刚开始看到类似<strong>kwarg in dynamic_kwargs for kwarg in legacy_kwargs</strong>的代码时可能会感到困惑，我们举一个简单的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = [<span class="number">3</span>, <span class="number">4</span> ,<span class="number">5</span> ,<span class="number">6</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = [a <span class="keyword">in</span> b <span class="keyword">for</span> a <span class="keyword">in</span> c]</span><br><span class="line">[<span class="literal">True</span>, <span class="literal">True</span>, <span class="literal">False</span>, <span class="literal">False</span>]</span><br><span class="line"><span class="comment"># d等价于下列算法中的k</span></span><br><span class="line">k=[]</span><br><span class="line"><span class="keyword">for</span> a <span class="keyword">in</span> c:</span><br><span class="line">    <span class="keyword">if</span> a <span class="keyword">in</span> b:</span><br><span class="line">        k.append(<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">	k.append(<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>
<p>接下来的<code>num_items = in_arrays[0].shape[0]</code>是对获取输入<strong>latent</strong>矢量的个数(每个长度为<strong>512</strong>)。</p>
<h2 id="key"><a href="#key" class="headerlink" title="key"></a>key</h2><p>将<strong>input_transform</strong>、<strong>output_transform</strong>、<strong>num_gpus</strong>、<strong>assume_frozen</strong>、<strong>dynamic_kwargs</strong>包装为字典，其中第一、二、五位的键值为字典，即字典中的字典。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">unwind_key</span>(<span class="params">obj</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(obj, <span class="built_in">dict</span>):</span><br><span class="line">        <span class="keyword">return</span> [(key, unwind_key(value)) <span class="keyword">for</span> key, value <span class="keyword">in</span> <span class="built_in">sorted</span>(obj.items())]</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">callable</span>(obj):</span><br><span class="line">        <span class="keyword">return</span> util.get_top_level_function_name(obj)</span><br><span class="line">    <span class="keyword">return</span> obj</span><br></pre></td></tr></table></figure>
<p>接着，作者定了<code>unwind_key</code>用于“解压”字典或者函数<strong>module</strong>，这里我们先介绍第一种情况，即<strong>obj</strong>为字典：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">test = &#123;<span class="string">&#x27;k1&#x27;</span>: <span class="number">11</span>,<span class="string">&#x27;k2&#x27;</span>: <span class="number">22</span>,</span><br><span class="line">       <span class="string">&#x27;k3&#x27;</span>: &#123;<span class="string">&#x27;k1ink3&#x27;</span>: <span class="string">&#x27;value13&#x27;</span>,<span class="string">&#x27;k2ink3&#x27;</span>: <span class="string">&#x27;value23&#x27;</span>,&#125;&#125;</span><br><span class="line"><span class="comment"># 这里我们定义一个test字典，其中k1、k2和k3位于一级字典中，k1ink3和k2ink3位于k3的二级字典中</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(test)</span><br><span class="line">&#123;<span class="string">&#x27;k1&#x27;</span>: <span class="number">11</span>, <span class="string">&#x27;k2&#x27;</span>: <span class="number">22</span>, <span class="string">&#x27;k3&#x27;</span>: &#123;<span class="string">&#x27;k1ink3&#x27;</span>: <span class="string">&#x27;value13&#x27;</span>, <span class="string">&#x27;k2ink3&#x27;</span>: <span class="string">&#x27;value23&#x27;</span>&#125;&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(unwind_key(test))</span><br><span class="line">[(<span class="string">&#x27;k1&#x27;</span>, <span class="number">11</span>), (<span class="string">&#x27;k2&#x27;</span>, <span class="number">22</span>), (<span class="string">&#x27;k3&#x27;</span>, [(<span class="string">&#x27;k1ink3&#x27;</span>, <span class="string">&#x27;value13&#x27;</span>), (<span class="string">&#x27;k2ink3&#x27;</span>, <span class="string">&#x27;value23&#x27;</span>)])]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">repr</span>(unwind_key(test))</span><br><span class="line">[(<span class="string">&#x27;k1&#x27;</span>, <span class="number">11</span>), (<span class="string">&#x27;k2&#x27;</span>, <span class="number">22</span>), (<span class="string">&#x27;k3&#x27;</span>, [(<span class="string">&#x27;k1ink3&#x27;</span>, <span class="string">&#x27;value13&#x27;</span>), (<span class="string">&#x27;k2ink3&#x27;</span>, <span class="string">&#x27;value23&#x27;</span>)])]</span><br></pre></td></tr></table></figure><br><code>unwind_key(test)</code>会把字典<strong>test</strong>转换为<code>list</code>，而<code>repr(unwind_key(test))</code>则将<code>unwind_key(test)</code>转换成了<code>str</code>。</p>
<h2 id="tfutil-absolute-name-scope"><a href="#tfutil-absolute-name-scope" class="headerlink" title="tfutil.absolute_name_scope"></a>tfutil.absolute_name_scope</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ？</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">absolute_name_scope</span>(<span class="params">scope: <span class="built_in">str</span></span>) -&gt; tf.name_scope:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;强制进入特定scope.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> tf.name_scope(scope + <span class="string">&quot;/&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>tfutil.absolute_name_scope(self.scope + “/_Run”)创建了一个参数命名空间，在这个语境下，所有的参数名将变为<code>“%s/_Run/variable_name”%(self.scope)</code>的形式，即变为了<code>Gs/_Run/xxx/xxx</code>的形式。</p>
<p>注：在<strong>tfutil.py</strong>的<code>_sanitize_tf_config</code>函数中添加<code>cfg[&quot;log_device_placement&quot;]             = True</code>即可输出所有变量的位置(<strong>CPU/GPU</strong>)。</p>
<h2 id="tf-control-dependencies-control-inputs"><a href="#tf-control-dependencies-control-inputs" class="headerlink" title="tf.control_dependencies(control_inputs)"></a>tf.control_dependencies(control_inputs)</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>tf.control_dependencies(control_inputs)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Signature: tf.control_dependencies(control_inputs)</span></span><br><span class="line"><span class="string">Docstring:</span></span><br><span class="line"><span class="string">Wrapper for `Graph.control_dependencies()` using the default graph.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">See `tf.Graph.control_dependencies`</span></span><br><span class="line"><span class="string">for more details.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">当动态图机制启用时，会自动调用list`control_inputs`中的可执行对象。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Args:</span></span><br><span class="line"><span class="string">  control_inputs: op或者Tensor的列表，context中的内容会在control_inputs执行完成后才执行。也可以为‘None’来清空控制依赖</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Returns:</span></span><br><span class="line"><span class="string"> 返回一个上下文管理器。</span></span><br><span class="line"><span class="string"> &quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="in-expr-和-in-split"><a href="#in-expr-和-in-split" class="headerlink" title="in_expr 和 in_split"></a>in_expr 和 in_split</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> tf.device(<span class="string">&quot;/gpu:0&quot;</span>):</span><br><span class="line">    in_expr = [tf.placeholder(tf.float32, name=name) <span class="keyword">for</span> name <span class="keyword">in</span> self.input_names]</span><br><span class="line">    in_split = <span class="built_in">list</span>(<span class="built_in">zip</span>(*[tf.split(x, num_gpus) <span class="keyword">for</span> x <span class="keyword">in</span> in_expr]))</span><br></pre></td></tr></table></figure>
<p>这里我做了修改，把所有变量操作都放到<strong>GPU</strong>上运行。<br><code>in_expr</code>是一个长度为<strong>len(input_names)</strong> 的列表，其中的每一个变量都是类型为<code>tf.float32</code>，名称为<strong>self.input_names[i]</strong> 的<code>tf.Tensor</code>。<br><code>in_split</code>是将<code>in_expr</code>沿<strong>minibatch</strong>方向划分为<strong>num_gpus</strong>个<code>tf.Tensor</code></p>
<h2 id="多GPU环境的graph构建"><a href="#多GPU环境的graph构建" class="headerlink" title="多GPU环境的graph构建"></a>多GPU环境的graph构建</h2><p><code>for gpu in range(num_gpus): with tf.device(&quot;/gpu:%d&quot; % gpu):</code>即在每个GPU上执行该上下文，若只用了单卡，<code>for</code>循环不起作用且在<code>&quot;/gpu:0&quot;</code>上执行。net_gpu = <code>self.clone() if assume_frozen else self</code>，当<strong>assume_frozen</strong>为<code>False</code>时将返回实例本身（默认），当其为<code>True</code>时会调用<code>self.clone()</code>,我们做一个简单的测试：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 这里我们以源代码为模板，构造以下函数</span></span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.cpu_count = multiprocessing.cpu_count()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;本机共有%d个CPU。&quot;</span>%(self.cpu_count))</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">clone</span>(<span class="params">self, name: <span class="built_in">str</span> = <span class="literal">None</span></span>):</span><br><span class="line">        new = <span class="built_in">object</span>.__new__(User)</span><br><span class="line">        <span class="keyword">return</span> new</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self,</span>):</span><br><span class="line">        <span class="keyword">for</span> cpu <span class="keyword">in</span> <span class="built_in">range</span>(self.cpu_count):</span><br><span class="line">            <span class="keyword">with</span> tf.device(<span class="string">&quot;/cpu:%d&quot;</span>%cpu):</span><br><span class="line">                net_gpu = self.clone() <span class="keyword">if</span> <span class="literal">True</span> <span class="keyword">else</span> self</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;/cpu:%d/%s&#x27;</span>%(cpu,<span class="built_in">str</span>(net_gpu)))</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>test = User(<span class="string">&quot;Test&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>test.run()</span><br><span class="line">本机共有<span class="number">12</span>个CPU。</span><br><span class="line">/cpu:<span class="number">0</span>/&lt;__main__.User <span class="built_in">object</span> at <span class="number">0x7f4c3ceaf630</span>&gt;</span><br><span class="line">/cpu:<span class="number">1</span>/&lt;__main__.User <span class="built_in">object</span> at <span class="number">0x7f4c3ceaf550</span>&gt;</span><br><span class="line">/cpu:<span class="number">2</span>/&lt;__main__.User <span class="built_in">object</span> at <span class="number">0x7f4c3ceaf710</span>&gt;</span><br><span class="line">/cpu:<span class="number">3</span>/&lt;__main__.User <span class="built_in">object</span> at <span class="number">0x7f4c3ceaf588</span>&gt;</span><br><span class="line">/cpu:<span class="number">4</span>/&lt;__main__.User <span class="built_in">object</span> at <span class="number">0x7f4c3ceaf748</span>&gt;</span><br><span class="line">/cpu:<span class="number">5</span>/&lt;__main__.User <span class="built_in">object</span> at <span class="number">0x7f4c3ceaf7f0</span>&gt;</span><br><span class="line">/cpu:<span class="number">6</span>/&lt;__main__.User <span class="built_in">object</span> at <span class="number">0x7f4c3ceafa90</span>&gt;</span><br><span class="line">/cpu:<span class="number">7</span>/&lt;__main__.User <span class="built_in">object</span> at <span class="number">0x7f4c3ceaf828</span>&gt;</span><br><span class="line">/cpu:<span class="number">8</span>/&lt;__main__.User <span class="built_in">object</span> at <span class="number">0x7f4c3ceaf7b8</span>&gt;</span><br><span class="line">/cpu:<span class="number">9</span>/&lt;__main__.User <span class="built_in">object</span> at <span class="number">0x7f4c3ceaf780</span>&gt;</span><br><span class="line">/cpu:<span class="number">10</span>/&lt;__main__.User <span class="built_in">object</span> at <span class="number">0x7f4c3ce82278</span>&gt;</span><br><span class="line">/cpu:<span class="number">11</span>/&lt;__main__.User <span class="built_in">object</span> at <span class="number">0x7f4c3ce825f8</span>&gt;</span><br></pre></td></tr></table></figure>
<p><code>in_gpu = in_split[gpu]</code>是从分割后的元组<code>in_split</code>中按照设备号来访问其中的<code>tf.Tensor</code>，也就是将整个<strong>miniBatch</strong>均匀分配到各个<strong>GPU</strong>上。<code>if input_transform is not None:</code>判断是否需要对输入做变换，<code>in_kwargs = dict(input_transform)</code>将<code>input_transform</code>存放到字典<code>in_kwargs</code>中，实质上<code>input_transform</code>也为字典，这里可能是为了避免后续的<code>pop</code>操作将<code>input_transform</code>中的值删除。对输入做完预处理之后，若<code>in_gpu</code>为<code>tf.Tensor</code>、<code>tf.Variable</code>或者<code>tf.Operation</code>中的某一个，则返回<code>[in_gpu]</code>，否则返回<code>list(in_gpu)</code>。</p>
<p><code>net_gpu.get_output_for</code>的返回值<strong>out_gpu</strong>为<code>&lt;tf.Tensor &#39;Gs/_Run/Gs/images_out:0&#39; shape=(?, 3, 1024, 1024) dtype=float32&gt;</code>，由于篇幅原因我们将这一函数单独放在另一篇文章中讲解。</p>
<p>接下来的<code>output_transform</code>板块与上文中提到的<code>input_transform</code>所执行的操作比较相似，其是对输出<strong>out_gpu</strong>做了后续的处理，在运行<strong>pretrained.py</strong>时，<code>run</code>函数并没有执行<code>if input_transform</code>后面的代码，因为输入中并没有给出任何关于对输入信息进行转换的关键词或列表，但是需要将输出转换为<strong>unit8</strong>，即<code>output_transform = &#123;&#39;func&#39;: &lt;function convert_images_to_uint8 at 0x7f9f38697378&gt;,&#39;nchw_to_nhwc&#39;:True&#125;</code>代码如下：<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">convert_images_to_uint8</span>(<span class="params">images, drange=[-<span class="number">1</span>,<span class="number">1</span>], nchw_to_nhwc=<span class="literal">False</span>, shrink=<span class="number">1</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;根据输入的动态范围drange，将一个minibatch的图像从float32类型转换为unit8。可以作为Network.run()中的输出转换使用</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    images = tf.cast(images, tf.float32)</span><br><span class="line">    <span class="keyword">if</span> shrink &gt; <span class="number">1</span>:</span><br><span class="line">        ksize = [<span class="number">1</span>, <span class="number">1</span>, shrink, shrink]</span><br><span class="line">        images = tf.nn.avg_pool(images,ksize=ksize,strides=ksize,padding=<span class="string">&quot;VALID&quot;</span>,data_format=<span class="string">&quot;NWHC&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> nchw_to_nhwc:</span><br><span class="line">        images = tf.transpose(images, [<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>])</span><br><span class="line">    scale = <span class="number">255</span> / (drange[<span class="number">1</span>] - drange[<span class="number">0</span>])</span><br><span class="line">    images = images * scale + (<span class="number">0.5</span> - drange[<span class="number">0</span>] * scale)</span><br><span class="line">    <span class="keyword">return</span> tf.saturate_cast(images, tf.uint8)</span><br></pre></td></tr></table></figure><br>我们来看一下上面代码块中出现的几个常用函数，首先看一下<code>tf.cast</code>以及<code>tf.saturate_cast</code>的区别：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Signature: tf.saturate_cast(value, dtype, name=None)</span></span><br><span class="line"><span class="string">Docstring:</span></span><br><span class="line"><span class="string">将value安全地转换为dtype类型，不进行任何缩放。当转换可能会出现泄露(overflow或 underflow)问题时,会首先将数据clamp到合适范围之内。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment">#例如,我们要把一个float32转换为uint8类型：</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = tf.constant([-<span class="number">1</span>, <span class="number">256</span>], dtype=tf.float32)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x1 = tf.saturate_cast(x, tf.uint8)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x2 = tf.cast(x, tf.uint8)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">        dx1, dx2 = sess.run([x1, x2])</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;tf.saturate_cast:&#x27;</span>,dx1)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;tf.cast:&#x27;</span>,dx2)</span><br><span class="line">tf.saturate_cast: [<span class="number">0</span> <span class="number">255</span>]</span><br><span class="line">tf.cast: [<span class="number">0</span> <span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<p>然后，<code>out_split.append(out_gpu)</code>将每个<strong>GPU</strong>得到的结果<code>out_gpu</code>添加到表<code>out_split</code>中，由<code>tf.concat(outputs, axis=0)</code>将所有结果沿<strong>minibatch</strong>方向连接，最后转化为<code>list</code>赋值给<code>out_expr</code>。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>GAN</category>
      </categories>
      <tags>
        <tag>styleGAN</tag>
      </tags>
  </entry>
  <entry>
    <title>styleGAN源码解读之network.py(二)</title>
    <url>/2020/07/12/styleGAN-network2/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="styleGAN—network-py"><a href="#styleGAN—network-py" class="headerlink" title="styleGAN—network.py"></a>styleGAN—network.py</h1><h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><p>以下为network.py中Network类run方法的最后一部分。<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Network</span>:</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self,</span></span><br><span class="line"><span class="params">        *in_arrays: <span class="type">Tuple</span>[<span class="type">Union</span>[np.ndarray, <span class="literal">None</span>], ...],</span></span><br><span class="line"><span class="params">        input_transform: <span class="built_in">dict</span> = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">        output_transform: <span class="built_in">dict</span> = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">        return_as_list: <span class="built_in">bool</span> = <span class="literal">False</span>,</span></span><br><span class="line"><span class="params">        print_progress: <span class="built_in">bool</span> = <span class="literal">False</span>,</span></span><br><span class="line"><span class="params">        minibatch_size: <span class="built_in">int</span> = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">        num_gpus: <span class="built_in">int</span> = <span class="number">1</span>,</span></span><br><span class="line"><span class="params">        assume_frozen: <span class="built_in">bool</span> = <span class="literal">False</span>,</span></span><br><span class="line"><span class="params">        **dynamic_kwargs</span>) -&gt; <span class="type">Union</span>[np.ndarray, <span class="type">Tuple</span>[np.ndarray, ...], <span class="type">List</span>[np.ndarray]]:</span><br><span class="line"></span><br><span class="line">   <span class="keyword">assert</span> <span class="built_in">len</span>(in_arrays) == self.num_inputs</span><br><span class="line">   <span class="keyword">assert</span> <span class="keyword">not</span> <span class="built_in">all</span>(arr <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">for</span> arr <span class="keyword">in</span> in_arrays)</span><br><span class="line">   <span class="keyword">assert</span> input_transform <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> util.is_top_level_function(input_transform[<span class="string">&quot;func&quot;</span>])</span><br><span class="line">   <span class="keyword">assert</span> output_transform <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> util.is_top_level_function(output_transform[<span class="string">&quot;func&quot;</span>])</span><br><span class="line">   output_transform, dynamic_kwargs = _handle_legacy_output_transforms(output_transform, dynamic_kwargs)</span><br><span class="line">   num_items = in_arrays[<span class="number">0</span>].shape[<span class="number">0</span>]</span><br><span class="line">   <span class="keyword">if</span> minibatch_size <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">       minibatch_size = num_items</span><br><span class="line"></span><br><span class="line">   <span class="comment"># Construct unique hash key from all arguments that affect the TensorFlow graph.</span></span><br><span class="line">   略</span><br><span class="line">   <span class="comment"># Build graph.</span></span><br><span class="line">   略</span><br><span class="line">   <span class="comment"># Run minibatches.</span></span><br><span class="line">   in_expr, out_expr = self._run_cache[key]</span><br><span class="line">   out_arrays = [np.empty([num_items] + tfutil.shape_to_list(expr.shape)[<span class="number">1</span>:], expr.dtype.name) <span class="keyword">for</span> expr <span class="keyword">in</span> out_expr]</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> mb_begin <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, num_items, minibatch_size):</span><br><span class="line">       <span class="keyword">if</span> print_progress:</span><br><span class="line">           <span class="built_in">print</span>(<span class="string">&quot;\r%d / %d&quot;</span> % (mb_begin, num_items), end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">       mb_end = <span class="built_in">min</span>(mb_begin + minibatch_size, num_items)</span><br><span class="line">       mb_num = mb_end - mb_begin</span><br><span class="line">       mb_in = [src[mb_begin : mb_end] <span class="keyword">if</span> src <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">else</span> np.zeros([mb_num] + shape[<span class="number">1</span>:]) <span class="keyword">for</span> src, shape <span class="keyword">in</span> <span class="built_in">zip</span>(in_arrays, self.input_shapes)]</span><br><span class="line">       mb_out = tf.get_default_session().run(out_expr, <span class="built_in">dict</span>(<span class="built_in">zip</span>(in_expr, mb_in)))</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> dst, src <span class="keyword">in</span> <span class="built_in">zip</span>(out_arrays, mb_out):</span><br><span class="line">           dst[mb_begin: mb_end] = src</span><br><span class="line"></span><br><span class="line">   <span class="comment"># Done.</span></span><br><span class="line">   <span class="keyword">if</span> print_progress:</span><br><span class="line">       <span class="built_in">print</span>(<span class="string">&quot;\r%d / %d&quot;</span> % (num_items, num_items))</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> <span class="keyword">not</span> return_as_list:</span><br><span class="line">       out_arrays = out_arrays[<span class="number">0</span>] <span class="keyword">if</span> <span class="built_in">len</span>(out_arrays) == <span class="number">1</span> <span class="keyword">else</span> <span class="built_in">tuple</span>(out_arrays)</span><br><span class="line">   <span class="keyword">return</span> out_arrays</span><br><span class="line"><span class="comment">##依赖函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">shape_to_list</span>(<span class="params">shape: Iterable[tf.Dimension]</span>) -&gt; <span class="type">List</span>[<span class="type">Union</span>[<span class="built_in">int</span>, <span class="literal">None</span>]]: <span class="comment">#位于dnnlib/tflib</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;将TFshape转换为列表.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> [dim.value <span class="keyword">for</span> dim <span class="keyword">in</span> shape]</span><br></pre></td></tr></table></figure></p>
<h2 id="Run-minibatches"><a href="#Run-minibatches" class="headerlink" title="Run minibatches"></a>Run minibatches</h2><p><code>in_expr, out_expr</code>是两个<strong>list</strong>，由于<code>out_arrays</code>是以<code>out_expr</code>为模板创建的，所以它的<strong>shape</strong>为<code>[1, 1024, 1024, 3]</code>：<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 运行pretrained.py时得到以下结果</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(in_expr)</span><br><span class="line">[&lt;tf.Tensor <span class="string">&#x27;Gs/_Run/latents_in:0&#x27;</span> shape=&lt;unknown&gt; dtype=float32&gt;, &lt;tf.Tensor <span class="string">&#x27;Gs/_Run/labels_in:0&#x27;</span> shape=&lt;unknown&gt; dtype=float32&gt;]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(out_expr)</span><br><span class="line">[&lt;tf.Tensor <span class="string">&#x27;Gs/_Run/concat:0&#x27;</span> shape=(?, <span class="number">1024</span>, <span class="number">1024</span>, <span class="number">3</span>) dtype=uint8&gt;]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(tfutil.shape_to_list(expr.shape)[<span class="number">1</span>:])</span><br><span class="line">[<span class="number">1024</span>, <span class="number">1024</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(num_items)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>([num_items] + tfutil.shape_to_list(expr.shape)[<span class="number">1</span>:])</span><br><span class="line">[<span class="number">1</span>, <span class="number">1024</span>, <span class="number">1024</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure><br>对<code>Graph</code>中数据流以及作者所定义的<code>scope</code>感兴趣的可以进行以下操作(生成的<code>graph</code>非常清晰，可读性很强，值得学习。)<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">输出默认Grpah中op以及变量、Tensor等的名字(一般由name_scope或者variable_scope定义)到txt文件；输出Graph到Tensorboard，在终端</span></span><br><span class="line"><span class="string">中使用“tensorboard --logdir ./logpath”打开。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;./graph_names.txt&#x27;</span>,<span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    sep=<span class="string">&#x27;\n&#x27;</span></span><br><span class="line">    test_names = [n.name <span class="keyword">for</span> n <span class="keyword">in</span> tf.get_default_graph().as_graph_def().node]</span><br><span class="line">    f.write(sep.join(test_names))</span><br><span class="line">    summary_writer = tf.summary.FileWriter(<span class="string">&quot;log&quot;</span>,tf.get_default_graph())</span><br></pre></td></tr></table></figure><br>接下来的<code>for</code>循环中，<strong>minibatch</strong>为<code>run</code>接收的一个参数，若其为<code>None</code>，则<br><code>minibatch_size = num_items</code>，而<code>num_items = in_arrays[0].shape[0]</code>，所以当<strong>minibatch</strong>为<code>None</code>时。<code>pretrained.py</code>执行过程中，这一<code>for</code>循环只执行一次，并且<code>mb_end</code>和<code>mb_num</code>均为<strong>1</strong>，所以<code>mb_in</code>是一个包含<code>(1,512)</code>和<code>(1,0)</code>两个<code>np.darray</code>的<code>list</code>，实质上<code>mb_in[0]==in_arrays[0]</code>(可用代码<code>(a==b).all()</code>判断两个数组是否完全相同)。<br><code>mb_out = tf.get_default_session().run()</code>为真正的预测过程，<code>mb_out</code>即为预测结果。接着，将<code>src(mb_out)</code>中的数据复制到<code>dst</code>中。</p>
<p>最后判断是否需要将输出以<code>list</code>的形式返回。至此，<code>run</code>函数成功返回，实质上整个run中最关键的一句是<code>tf.get_default_session().run()</code>，它获取了默认会话的<code>op</code>和数据流，并将<code>in_expr</code>和<code>mb_in</code><strong>feed</strong>给网络。</p>
<p>注：<code>tf.Tensor</code>的尺寸可以通过<code>for dim in tf.Tensor.shape: print(dim.value)</code>来获取，<code>batches</code>的<code>？</code>实际上为<code>None</code>。</p>
<h1 id="get-output-for"><a href="#get-output-for" class="headerlink" title="get_output_for"></a>get_output_for</h1><p><code>get_output_for</code>为类<code>Network</code>中的另一个方法<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_output_for</span>(<span class="params">self, *in_expr: TfExpression, return_as_list: <span class="built_in">bool</span> = <span class="literal">False</span>, **dynamic_kwargs</span>) -&gt; <span class="type">Union</span>[TfExpression, <span class="type">List</span>[TfExpression]]:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Construct TensorFlow expression(s) for the output(s) of this network, given the input expression(s).&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">len</span>(in_expr) == self.num_inputs</span><br><span class="line">    <span class="keyword">assert</span> <span class="keyword">not</span> <span class="built_in">all</span>(expr <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">for</span> expr <span class="keyword">in</span> in_expr)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Finalize build func kwargs.</span></span><br><span class="line">    build_kwargs = <span class="built_in">dict</span>(self.static_kwargs)</span><br><span class="line">    build_kwargs.update(dynamic_kwargs)</span><br><span class="line">    build_kwargs[<span class="string">&quot;is_template_graph&quot;</span>] = <span class="literal">False</span></span><br><span class="line">    build_kwargs[<span class="string">&quot;components&quot;</span>] = self.components</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Build TensorFlow graph to evaluate the network.</span></span><br><span class="line">    <span class="keyword">with</span> tfutil.absolute_variable_scope(self.scope, reuse=<span class="literal">True</span>), tf.name_scope(self.name):</span><br><span class="line">        <span class="keyword">assert</span> tf.get_variable_scope().name == self.scope</span><br><span class="line">        valid_inputs = [expr <span class="keyword">for</span> expr <span class="keyword">in</span> in_expr <span class="keyword">if</span> expr <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>]</span><br><span class="line">        final_inputs = []</span><br><span class="line">        <span class="keyword">for</span> expr, name, shape <span class="keyword">in</span> <span class="built_in">zip</span>(in_expr, self.input_names, self.input_shapes):</span><br><span class="line">            <span class="keyword">if</span> expr <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                expr = tf.identity(expr, name=name)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                expr = tf.zeros([tf.shape(valid_inputs[<span class="number">0</span>])[<span class="number">0</span>]] + shape[<span class="number">1</span>:], name=name)</span><br><span class="line">            final_inputs.append(expr)</span><br><span class="line">        out_expr = self._build_func(*final_inputs, **build_kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Propagate input shapes back to the user-specified expressions.</span></span><br><span class="line">    <span class="keyword">for</span> expr, final <span class="keyword">in</span> <span class="built_in">zip</span>(in_expr, final_inputs):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(expr, tf.Tensor):</span><br><span class="line">            expr.set_shape(final.shape)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Express outputs in the desired format.</span></span><br><span class="line">    <span class="keyword">assert</span> tfutil.is_tf_expression(out_expr) <span class="keyword">or</span> <span class="built_in">isinstance</span>(out_expr, <span class="built_in">tuple</span>)</span><br><span class="line">    <span class="keyword">if</span> return_as_list:</span><br><span class="line">        out_expr = [out_expr] <span class="keyword">if</span> tfutil.is_tf_expression(out_expr) <span class="keyword">else</span> <span class="built_in">list</span>(out_expr)</span><br><span class="line">    <span class="keyword">return</span> out_expr</span><br><span class="line"><span class="comment">## 以上函数涉及到的其它模块</span></span><br><span class="line">TfExpression = <span class="type">Union</span>[tf.Tensor, tf.Variable, tf.Operation]</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">is_tf_expression</span>(<span class="params">x: <span class="type">Any</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">isinstance</span>(x, (tf.Tensor, tf.Variable, tf.Operation))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">absolute_variable_scope</span>(<span class="params">scope: <span class="built_in">str</span>, **kwargs</span>) -&gt; tf.variable_scope:</span><br><span class="line">    <span class="keyword">return</span> tf.variable_scope(tf.VariableScope(name=scope, **kwargs), auxiliary_name_scope=<span class="literal">False</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><br><code>TfExpression</code>被定义为有效的<strong>TF</strong>表达，它是一个<code>typing.Union</code>，其中包括了<code>tf.Tensor</code>, <code>tf.Variable</code>, <code>tf.Operation</code>。然后我们看一下字典的<code>update</code>方法：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = &#123;<span class="string">&#x27;1&#x27;</span>: <span class="number">11</span>,<span class="string">&#x27;2&#x27;</span>: <span class="number">22</span>,<span class="string">&#x27;3&#x27;</span>: <span class="number">33</span>,&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = &#123;<span class="string">&#x27;2&#x27;</span>: <span class="number">33</span>,<span class="string">&#x27;4&#x27;</span>: <span class="number">44</span>,<span class="string">&#x27;5&#x27;</span>: <span class="number">55</span>,<span class="string">&#x27;6&#x27;</span>: <span class="number">66</span>,&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.update(b)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(a)</span><br><span class="line">&#123;<span class="string">&#x27;1&#x27;</span>: <span class="number">11</span>, <span class="string">&#x27;2&#x27;</span>: <span class="number">33</span>, <span class="string">&#x27;3&#x27;</span>: <span class="number">33</span>, <span class="string">&#x27;4&#x27;</span>: <span class="number">44</span>, <span class="string">&#x27;5&#x27;</span>: <span class="number">55</span>, <span class="string">&#x27;6&#x27;</span>: <span class="number">66</span>&#125;</span><br><span class="line"><span class="comment"># 将字典b添加到a中，若有重复的key则用前者的value覆盖后者。</span></span><br></pre></td></tr></table></figure>
<p>关于<code>scope</code>的使用可以参考<a href="https://blog.geophyai.com/2020/07/12/tf_name_scope_variable_scope_new/">tensorflow之scope使用</a>，它能够控制变量名称的作用域，并且实现变量的重用，在神经网络比较复杂的情况下应用能够使<code>Tensorboard</code>绘制的<code>graph</code>更清晰，便于我们进行<strong>debug</strong>。</p>
<p>首先， <code>assert</code>语句获取了当前的变量作用域并判断其是否与<code>self.scope</code>相同，然后从<code>in_expr</code>中取出不为<code>None</code>的值<code>expr</code>作为有效输入存储在列表<code>valid_inputs</code>中。接下来改变了变量作用域，这里使用的<code>tf.identity</code>非常重要，它将变量、节点和<code>graph</code>流程计算联系在一起；运行<code>pretrained.py</code>时，第一次调用<code>get_output_for</code>会将<code>G/latents_in</code>和<code>G/labels_in</code>映射到<code>G/G_mapping/latents_in</code>和<code>G/G_mapping/labels_in</code>，即改变了变量的作用域。另外，由于设置了<code>reuse=True</code>，所以<code>valid_inputs</code>会重用<code>in_expr</code>变量。我们通过一个简单的示例来看一下这些操作所产生的效果：</p>
<h1 id="发生了什么"><a href="#发生了什么" class="headerlink" title="发生了什么"></a>发生了什么</h1><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 仿照源码生成相同的scope和变量</span></span><br><span class="line"><span class="keyword">from</span> tensorflow.python.framework.tensor_shape <span class="keyword">import</span> unknown_shape</span><br><span class="line"><span class="keyword">with</span> tf.device(<span class="string">&#x27;/gpu:0&#x27;</span>):</span><br><span class="line">    <span class="keyword">with</span> tf.name_scope(<span class="string">&quot;G&quot;</span>):</span><br><span class="line">        in_expr=[tf.placeholder(<span class="built_in">float</span>, shape = unknown_shape(), name = <span class="string">&quot;latents_in&quot;</span>), </span><br><span class="line">                 tf.placeholder(<span class="built_in">float</span>, shape = unknown_shape(), name = <span class="string">&quot;labels_in&quot;</span>)]<span class="comment">#与源码相同，创建一个包含两个未知shapeTensor的列表</span></span><br><span class="line">        input_shapes=[[<span class="literal">None</span>, <span class="number">512</span>], [<span class="literal">None</span>, <span class="number">0</span>]]</span><br><span class="line">        input_names = [<span class="string">&#x27;latents_in&#x27;</span>, <span class="string">&#x27;labels_in&#x27;</span>]</span><br><span class="line">        scope = <span class="string">&#x27;G_mapping&#x27;</span></span><br><span class="line">        name = <span class="string">&#x27;G_mapping&#x27;</span></span><br><span class="line">        <span class="keyword">with</span> absolute_variable_scope(scope, reuse=<span class="literal">True</span>), tf.name_scope(name):</span><br><span class="line">         <span class="comment"># reuse: 设置变量重用，当多次调用此函数时，若变量已经存在则不占用新的内存，而是将其指向同名变量的内存地址</span></span><br><span class="line">            <span class="keyword">assert</span> tf.get_variable_scope().name == scope</span><br><span class="line">            valid_inputs = [expr <span class="keyword">for</span> expr <span class="keyword">in</span> in_expr <span class="keyword">if</span> expr <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>]</span><br><span class="line">            <span class="keyword">assert</span> <span class="built_in">id</span>(valid_inputs[<span class="number">0</span>]) == <span class="built_in">id</span>(in_expr[<span class="number">0</span>])</span><br><span class="line">            <span class="comment"># python会重用它认为完全相同的两个变量，因此valid_inputs和in_expr</span></span><br><span class="line">            <span class="comment"># 指向了同一内存地址</span></span><br><span class="line">            final_inputs = []</span><br><span class="line">            <span class="keyword">for</span> expr, name, shape <span class="keyword">in</span> <span class="built_in">zip</span>(in_expr, input_names, input_shapes):</span><br><span class="line">                <span class="keyword">if</span> expr <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&#x27;\033[31;47m before:\033[0m&#x27;</span>, name, expr)</span><br><span class="line">                    expr = tf.identity(expr, name=name)</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&#x27;\033[31;47m after:\033[0m&#x27;</span>, name, expr)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    expr = tf.zeros([tf.shape(valid_inputs[<span class="number">0</span>])[<span class="number">0</span>]] + shape[<span class="number">1</span>:], name=name)</span><br><span class="line">                final_inputs.append(expr)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">final_inpus: [&lt;tf.Tensor &#x27;G/G_mapping/latents_in:0&#x27; shape=&lt;unknown&gt; dtype=float32&gt;, </span></span><br><span class="line"><span class="string">&lt;tf.Tensor &#x27;G/G_mapping/labels_in:0&#x27; shape=&lt;unknown&gt; dtype=float32&gt;]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<p><img src="/2020/07/12/styleGAN-network2/flow.png" alt="Tensorboard"></p>
<h1 id="tf-identity"><a href="#tf-identity" class="headerlink" title="tf.identity"></a>tf.identity</h1><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Signature: tf.identity(input, name=None)</span></span><br><span class="line"><span class="string">Docstring:</span></span><br><span class="line"><span class="string">返回与输入具有相同尺寸以及上下文的张量。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Args:</span></span><br><span class="line"><span class="string">  input: Tensor.</span></span><br><span class="line"><span class="string">  name: op的名字.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Returns:</span></span><br><span class="line"><span class="string">  返回与输入具有相同类型的Tensor。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">x = tf.Variable(<span class="number">0.0</span>, name = <span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">plus = tf.assign_add(x, <span class="number">1</span>, name = <span class="string">&#x27;plus&#x27;</span>) <span class="comment"># 对&#x27;x&#x27;加1</span></span><br><span class="line"><span class="keyword">with</span> tf.control_dependencies([plus]):</span><br><span class="line">    y = tf.identity(x, name = <span class="string">&#x27;y&#x27;</span>) <span class="comment"># y的更新将依赖于op plus</span></span><br><span class="line">init = tf.global_variables_initializer()</span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    init.run()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        <span class="built_in">print</span>(sess.run(y), sess.run(x))</span><br><span class="line"><span class="comment"># [OUTPUT]:</span></span><br><span class="line"><span class="number">1.0</span> <span class="number">1.0</span></span><br><span class="line"><span class="number">2.0</span> <span class="number">2.0</span></span><br><span class="line"><span class="number">3.0</span> <span class="number">3.0</span></span><br></pre></td></tr></table></figure>
<p>以上函数中定义了一个作用在<code>x</code>上的<code>op</code>，它能够实现对变量<code>plus</code>和<code>x</code>的自增运算，<code>tf.control_dependencies([plus])</code>语境中的代码会在<code>plus</code>执行之后(即自增运算后)才执行，也就是<code>sess.run(y)</code>的运行会依赖于<code>plus</code>。<br><img src="/2020/07/12/styleGAN-network2/tfidentity.png" alt="Tensorboard"></p>
<h1 id="build-func"><a href="#build-func" class="headerlink" title="_build_func"></a>_build_func</h1><p>这里的<code>_build_func</code>即为<code>G_mapping</code>,<code>G_synthesis</code>或者<code>G_style</code>函数，源码位于<code>training/networks_stylegan.py</code>中，数据流动如下所示：<br><code>set_shape</code>可以改变<code>placeholder</code>的尺寸：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>test = tf.placeholder(<span class="built_in">float</span>, shape = unknown_shape(), name = <span class="string">&quot;Test&quot;</span>)</span><br><span class="line"><span class="comment"># test.get_shape()= &lt;unknown&gt;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>test.set_shape([<span class="number">3</span>, <span class="number">512</span>, <span class="number">512</span>])</span><br><span class="line"><span class="comment"># 这实际上涉及到张量流中动态形状和静态形状的概念，张量在graph图的流动过程中</span></span><br><span class="line"><span class="comment"># 形状是可能发生变化的</span></span><br><span class="line"><span class="comment"># 只有当变量存在至少一个维度不确定(为None或?)时才可以使用set_shape</span></span><br><span class="line"><span class="comment"># test.get_shape()= (3, 512, 512) 修改一次后不可再用set_shape改变形状</span></span><br></pre></td></tr></table></figure>
<p>expr.set_shape(final.shape)即将输入的没有形状(unknown)的张量设置为期望形状<code>[final.shape for final in final_inputs]</code>。</p>
<h1 id="Return"><a href="#Return" class="headerlink" title="Return"></a>Return</h1><p><code>return out_expr</code>返回生成的高分辨率图像。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>GAN</category>
      </categories>
      <tags>
        <tag>styleGAN</tag>
      </tags>
  </entry>
  <entry>
    <title>styleGAN源码解读之pretrained-example.py</title>
    <url>/2020/07/07/styleGAN-pretrained-example/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="styleGAN—-pretrained-example-py"><a href="#styleGAN—-pretrained-example-py" class="headerlink" title="styleGAN—-pretrained-example.py"></a>styleGAN—-pretrained-example.py</h1><p>此代码使用预训练的styleGAN模型<a href="https://pan.baidu.com/s/15eBihbZvLZ42aToLy5iKlQ">karras2019stylegan-ffhq-1024x1024.pkl(百度网盘，密码1q60)</a>生成器生成单张随机人脸图像。(如有需要请下载<a href="https://github.com/NVlabs/stylegan">源代码<Github项目链接></Github项目链接></a>)</p>
<h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> PIL.Image</span><br><span class="line"><span class="keyword">import</span> dnnlib</span><br><span class="line"><span class="keyword">import</span> dnnlib.tflib <span class="keyword">as</span> tflib</span><br><span class="line"><span class="keyword">import</span> config</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># Initialize TensorFlow.</span></span><br><span class="line">    tflib.init_tf()</span><br><span class="line">    <span class="comment"># Load pre-trained network.</span></span><br><span class="line">    url = <span class="string">&#x27;https://drive.google.com/uc?id=1MEGjdvVpUsu1jB4zrXZN7Y4kBBOzizDQ&#x27;</span> <span class="comment"># karras2019stylegan-ffhq-1024x1024.pkl</span></span><br><span class="line">    <span class="keyword">with</span> dnnlib.util.open_url(url, cache_dir=config.cache_dir) <span class="keyword">as</span> f:</span><br><span class="line">        _G, _D, Gs = pickle.load(f)</span><br><span class="line">        <span class="comment"># _G = Instantaneous snapshot of the generator. Mainly useful for resuming a previous training run.</span></span><br><span class="line">        <span class="comment"># _D = Instantaneous snapshot of the discriminator. Mainly useful for resuming a previous training run.</span></span><br><span class="line">        <span class="comment"># Gs = Long-term average of the generator. Yields higher-quality results than the instantaneous snapshot.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Print network details.</span></span><br><span class="line">    <span class="comment">#Gs.print_layers()</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Pick latent vector.</span></span><br><span class="line">    rnd = np.random.RandomState(<span class="number">5</span>)</span><br><span class="line">    latents = rnd.randn(<span class="number">1</span>, Gs.input_shape[<span class="number">1</span>])</span><br><span class="line">    <span class="comment"># Generate image.</span></span><br><span class="line">    fmt = <span class="built_in">dict</span>(func=tflib.convert_images_to_uint8, nchw_to_nhwc=<span class="literal">True</span>)</span><br><span class="line">    images = Gs.run(latents, <span class="literal">None</span>, truncation_psi=<span class="number">0.7</span>, randomize_noise=<span class="literal">True</span>, output_transform=fmt)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Save image.</span></span><br><span class="line">    os.makedirs(config.result_dir, exist_ok=<span class="literal">True</span>)</span><br><span class="line">    png_filename = os.path.join(config.result_dir, <span class="string">&#x27;example.png&#x27;</span>)</span><br><span class="line">    PIL.Image.fromarray(images[<span class="number">0</span>], <span class="string">&#x27;RGB&#x27;</span>).save(png_filename)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<h1 id="微调预训练模型路径后的代码"><a href="#微调预训练模型路径后的代码" class="headerlink" title="微调预训练模型路径后的代码"></a>微调预训练模型路径后的代码</h1><p>由于代码中所使用的预训练模型存储在GoogleDrive上可能无法通过代码下载，因此我们提前下载下来并从本地读取。这里修改代码为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#这段代码运行在styleGAN根目录下的./ipynb/sytle_test.ipynb中</span></span><br><span class="line"><span class="keyword">import</span> os <span class="comment">#module &#x27;os&#x27; from &#x27;/xxx/Anaconda/envs/xxx/lib/python3.6/os.py&#x27;</span></span><br><span class="line"><span class="keyword">import</span> pickle <span class="comment"># module &#x27;pickle&#x27; from &#x27;/xxx/Anaconda/envs/xxx/lib/python3.x/pickle.py&#x27;</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np <span class="comment">#略</span></span><br><span class="line"><span class="keyword">import</span> PIL.Image <span class="comment">#略</span></span><br><span class="line"><span class="keyword">import</span> dnnlib <span class="comment"># ./dnnlib</span></span><br><span class="line"><span class="keyword">import</span> dnnlib.tflib <span class="keyword">as</span> tflib <span class="comment"># module &#x27;dnnlib.tflib&#x27; from &#x27;../dnnlib/tflib/__init__.py&#x27;</span></span><br><span class="line"><span class="keyword">import</span> config <span class="comment"># &lt;module &#x27;config&#x27; from &#x27;../config.py&#x27;&gt;</span></span><br><span class="line"><span class="keyword">import</span> sys <span class="comment"># module &#x27;sys&#x27; (built-in)</span></span><br><span class="line"><span class="comment">#输入print(module_name)可查看其文件位置()</span></span><br><span class="line"><span class="comment">#例如</span></span><br><span class="line"><span class="comment">#print(dnnlib)</span></span><br><span class="line"><span class="comment">#&lt;module &#x27;dnnlib&#x27; from &#x27;../dnnlib/__init__.py&#x27;&gt;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># 初始化Tensorflow.</span></span><br><span class="line">    tflib.init_tf()</span><br><span class="line">    <span class="comment"># 加载pkl文件，重构对象并导入预训练模型</span></span><br><span class="line">    url = <span class="string">r&#x27;/xxx/xxx/xxx/karras2019stylegan-ffhq-1024x1024.pkl&#x27;</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(url, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        _G, _D, Gs = pickle.load(f)</span><br><span class="line">        <span class="comment"># _G = Instantaneous snapshot of the generator. Mainly useful for resuming a previous training run.</span></span><br><span class="line">        <span class="comment"># _D = Instantaneous snapshot of the discriminator. Mainly useful for resuming a previous training run.</span></span><br><span class="line">        <span class="comment"># Gs = Long-term average of the generator. Yields higher-quality results than the instantaneous snapshot.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 打印Gs网络架构，相当于tf中的.summary()，函数原型位于network.py中，是作者自定义的函数。</span></span><br><span class="line">    Gs.print_layers()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 随机生成latent.</span></span><br><span class="line">    rnd = np.random.RandomState(<span class="number">5</span>)</span><br><span class="line">    latents = rnd.randn(<span class="number">1</span>, Gs.input_shape[<span class="number">1</span>])</span><br><span class="line">    <span class="comment"># 生成图像.</span></span><br><span class="line">    fmt = <span class="built_in">dict</span>(func=tflib.convert_images_to_uint8, nchw_to_nhwc=<span class="literal">True</span>)</span><br><span class="line">    images = Gs.run(latents, <span class="literal">None</span>, truncation_psi=<span class="number">0.7</span>, randomize_noise=<span class="literal">True</span>, output_transform=fmt)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 保存图像.</span></span><br><span class="line">    os.makedirs(config.result_dir, exist_ok=<span class="literal">True</span>)</span><br><span class="line">    png_filename = os.path.join(config.result_dir, <span class="string">&#x27;example.png&#x27;</span>)</span><br><span class="line">    PIL.Image.fromarray(images[<span class="number">0</span>], <span class="string">&#x27;RGB&#x27;</span>).save(png_filename)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<h1 id="函数逐行分析"><a href="#函数逐行分析" class="headerlink" title="函数逐行分析"></a>函数逐行分析</h1><h2 id="tflib-init-tf"><a href="#tflib-init-tf" class="headerlink" title="tflib.init_tf()"></a>tflib.init_tf()</h2><p><strong>main</strong>函数中第一句<code>tflib.init_tf()</code>函数用于初始化<strong>tensorflow</strong>，此函数位于<strong>dnnlib/tflib/tfutil.py</strong>中,<code>init_tf()</code>所依赖的其它函数有<code>_sanitize_tf_config</code>和<code>create_session</code>,这两个函数同样位于此文件中。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 本机环境为tenforlow-gpu1.14.0,运行源代码过程中经常提示版本相关的warning</span></span><br><span class="line"><span class="comment"># 所以这里使用tensorflow.compat.v1来运行</span></span><br><span class="line"><span class="keyword">import</span> tensorflow.compat.v1 <span class="keyword">as</span> tf</span><br><span class="line"><span class="comment">#--- 初始化TF</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">init_tf</span>(<span class="params">config_dict: <span class="built_in">dict</span> = <span class="literal">None</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Initialize TensorFlow session using good default settings.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 如果已创建Seccion则退出该函数.</span></span><br><span class="line">    <span class="keyword">if</span> tf.get_default_session() <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment"># 调用_sanitize_tf_config</span></span><br><span class="line">    <span class="comment"># 设置配置字典和随机种子.</span></span><br><span class="line">    cfg = _sanitize_tf_config(config_dict)</span><br><span class="line">    np_random_seed = cfg[<span class="string">&quot;rnd.np_random_seed&quot;</span>]</span><br><span class="line">    <span class="keyword">if</span> np_random_seed <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        np.random.seed(np_random_seed)</span><br><span class="line">    tf_random_seed = cfg[<span class="string">&quot;rnd.tf_random_seed&quot;</span>]</span><br><span class="line">    <span class="keyword">if</span> tf_random_seed == <span class="string">&quot;auto&quot;</span>:</span><br><span class="line">        tf_random_seed = np.random.randint(<span class="number">1</span> &lt;&lt; <span class="number">31</span>)</span><br><span class="line">    <span class="keyword">if</span> tf_random_seed <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        tf.set_random_seed(tf_random_seed)</span><br><span class="line">	</span><br><span class="line">    <span class="comment"># 设置TF环境变量.</span></span><br><span class="line">    <span class="keyword">for</span> key, value <span class="keyword">in</span> <span class="built_in">list</span>(cfg.items()):</span><br><span class="line">        fields = key.split(<span class="string">&quot;.&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> fields[<span class="number">0</span>] == <span class="string">&quot;env&quot;</span>:</span><br><span class="line">            <span class="keyword">assert</span> <span class="built_in">len</span>(fields) == <span class="number">2</span></span><br><span class="line">            os.environ[fields[<span class="number">1</span>]] = <span class="built_in">str</span>(value)</span><br><span class="line">            </span><br><span class="line">	<span class="comment"># 调用create_session</span></span><br><span class="line">    <span class="comment"># 创建TF会话.</span></span><br><span class="line">    create_session(cfg, force_as_default=<span class="literal">True</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment">#--- 设置配置信息</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_sanitize_tf_config</span>(<span class="params">config_dict: <span class="built_in">dict</span> = <span class="literal">None</span></span>) -&gt; <span class="built_in">dict</span>:</span><br><span class="line">    <span class="comment"># Defaults.</span></span><br><span class="line">    cfg = <span class="built_in">dict</span>()</span><br><span class="line">    cfg[<span class="string">&quot;rnd.np_random_seed&quot;</span>]               = <span class="literal">None</span>      <span class="comment"># Random seed for NumPy. None = keep as is.</span></span><br><span class="line">    cfg[<span class="string">&quot;rnd.tf_random_seed&quot;</span>]               = <span class="string">&quot;auto&quot;</span>    <span class="comment"># Random seed for TensorFlow. &#x27;auto&#x27; = derive from NumPy random state. None = keep as is.</span></span><br><span class="line">    cfg[<span class="string">&quot;env.TF_CPP_MIN_LOG_LEVEL&quot;</span>]         = <span class="string">&quot;1&quot;</span>       <span class="comment"># 0 = Print all available debug info from TensorFlow. 1 = Print warnings and errors, but disable debug info.</span></span><br><span class="line">    cfg[<span class="string">&quot;graph_options.place_pruned_graph&quot;</span>] = <span class="literal">True</span>      <span class="comment"># False = Check that all ops are available on the designated device. True = Skip the check for ops that are not used.</span></span><br><span class="line">    cfg[<span class="string">&quot;gpu_options.allow_growth&quot;</span>]         = <span class="literal">True</span>      <span class="comment"># False = Allocate all GPU memory at the beginning. True = Allocate only as much GPU memory as needed.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># User overrides.</span></span><br><span class="line">    <span class="keyword">if</span> config_dict <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        cfg.update(config_dict)</span><br><span class="line">    <span class="keyword">return</span> cfg</span><br><span class="line">    </span><br><span class="line"><span class="comment">#--- 根据配置信息创建会话</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_session</span>(<span class="params">config_dict: <span class="built_in">dict</span> = <span class="literal">None</span>, force_as_default: <span class="built_in">bool</span> = <span class="literal">False</span></span>) -&gt; tf.Session:</span><br><span class="line">    <span class="comment"># &quot;&quot;&quot;根据config_dict创建tf.Session.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 设置TF配置属性.</span></span><br><span class="line">    cfg = _sanitize_tf_config(config_dict)</span><br><span class="line">    config_proto = tf.ConfigProto()</span><br><span class="line">    <span class="keyword">for</span> key, value <span class="keyword">in</span> cfg.items():</span><br><span class="line">        fields = key.split(<span class="string">&quot;.&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> fields[<span class="number">0</span>] <span class="keyword">not</span> <span class="keyword">in</span> [<span class="string">&quot;rnd&quot;</span>, <span class="string">&quot;env&quot;</span>]:</span><br><span class="line">            obj = config_proto</span><br><span class="line">            <span class="keyword">for</span> field <span class="keyword">in</span> fields[:-<span class="number">1</span>]:</span><br><span class="line">                obj = <span class="built_in">getattr</span>(obj, field)</span><br><span class="line">            <span class="built_in">setattr</span>(obj, fields[-<span class="number">1</span>], value)</span><br><span class="line">    <span class="comment"># 创建会话.</span></span><br><span class="line">    session = tf.Session(config=config_proto)</span><br><span class="line">    <span class="keyword">if</span> force_as_default:</span><br><span class="line">        <span class="comment"># pylint: disable=protected-access</span></span><br><span class="line">        <span class="comment"># 将自己设置为default session</span></span><br><span class="line">        session._default_session = session.as_default()</span><br><span class="line">        session._default_session.enforce_nesting = <span class="literal">False</span></span><br><span class="line">        session._default_session.__enter__() <span class="comment"># pylint: disable=no-member</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> session</span><br></pre></td></tr></table></figure>
<p>以上函数中，<code>def init_tf(config_dict:dict=None)-&gt;None</code>定义了名为<strong>init_tf</strong>的函数：该函数接受名为<strong>config_dict</strong>的变量，<code>config_dict:dict=None</code>表示<strong>config_dict</strong>的期望类型为字典以及初始值为<strong>None</strong>；其中的冒号<code>:</code>是一种<strong>Type Annotation</strong>，其用于提示变量的类型为<code>dict</code>；<code>-&gt;</code>用于注释函数的返回类型为<strong>None</strong>。</p>
<p><code>if tf.get_default_session() is not None: return</code>用于获取当前会话(Session)，如果会话不为空则退出<code>init_tf</code>，若未创建会话则执行后续代码。</p>
<p><code>cfg=_sanitize_tf_config(config_dict)</code>调用了<code>_sanitize_tf_config</code>函数，此函数中创建了一个参数字典，我们可以通过以下方式打印其中的值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> <span class="built_in">zip</span>(cfg.keys(), cfg.values()):</span><br><span class="line">        <span class="built_in">print</span>(key, <span class="string">&#x27;:&#x27;</span>, value)</span><br><span class="line"><span class="comment">###--------结果如下--------###</span></span><br><span class="line">rnd.np_random_seed : <span class="literal">None</span></span><br><span class="line">rnd.tf_random_seed : auto</span><br><span class="line">env.TF_CPP_MIN_LOG_LEVEL : <span class="number">1</span></span><br><span class="line">graph_options.place_pruned_graph : <span class="literal">True</span></span><br><span class="line">gpu_options.allow_growth : <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>在函数<code>_sanitize_tf_config</code>中，首先创建了名为<strong>cfg</strong>的字典:该字典中包含上个代码框中的默认<strong>key</strong>及其<strong>value</strong>，当该函数的输入变量<strong>config_dict</strong>不为空时则执行<code>cfg.update(config_dict)</code>将新的字典添加到<strong>cfg</strong>中，最后返回字典<strong>cfg</strong>。</p>
<p><strong>np_random_seed</strong>默认为<strong>None</strong> 。当<strong>tf_random_seed</strong>为<strong>‘auto’</strong>（默认状态）时，执行<code>tf_random_seed=np.random.randint(1 &lt;&lt; 31)</code>，即生成一个小于<strong>1&lt;&lt;31=2147483648</strong>的值并赋给<strong>tf_random_seed</strong>，若为其它非<strong>‘auto’</strong>及非<strong>None</strong>值，则将其作为种子输入到<code>tf.set_random_seed()</code>中。</p>
<p>接下来的代码 <code>key.split(&quot;.&quot;)</code>以”<strong>.</strong>“分割了字典中的<strong>key</strong>并找到名为”<strong>env</strong>“的项，后续操作等价于<code>os.environ[&#39;TF_CPP_MIN_LOG_LEVEL&#39;]=’1‘</code>。即，将<strong>tf</strong>的<strong>log</strong>输出级别设置为1。</p>
<p><code>create_session(cfg,force_as_default=True)</code>将创建的配置信息以字典变量方式传入函数<strong>create_session</strong>并强制设置当前会话为默认会话。</p>
<p><code>obj=getattr(obj,field)</code>获取了<strong>obj</strong>的<strong>graph_options</strong>和<strong>gpu_options</strong>属性并分别设置其中的<strong>place_pruned_graph</strong>和<strong>allow_growth</strong>为<strong>True</strong>.</p>
<h2 id="Gs-print-layers"><a href="#Gs-print-layers" class="headerlink" title="Gs.print_layers()"></a>Gs.print_layers()</h2><p>回到主函数中,<code>Gs.print_layers()</code>结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">G                               Params    OutputShape          WeightShape     </span><br><span class="line">---                             ---       ---                  ---             </span><br><span class="line">latents_in                      -         (?, <span class="number">512</span>)             -               </span><br><span class="line">labels_in                       -         (?, <span class="number">0</span>)               -               </span><br><span class="line">lod                             -         ()                   -               </span><br><span class="line">dlatent_avg                     -         (<span class="number">512</span>,)               -               </span><br><span class="line">G_mapping/latents_in            -         (?, <span class="number">512</span>)             -               </span><br><span class="line">G_mapping/labels_in             -         (?, <span class="number">0</span>)               -               </span><br><span class="line">G_mapping/PixelNorm             -         (?, <span class="number">512</span>)             -               </span><br><span class="line">G_mapping/Dense0                <span class="number">262656</span>    (?, <span class="number">512</span>)             (<span class="number">512</span>, <span class="number">512</span>)      </span><br><span class="line">G_mapping/Dense1                <span class="number">262656</span>    (?, <span class="number">512</span>)             (<span class="number">512</span>, <span class="number">512</span>)      </span><br><span class="line">G_mapping/Dense2                <span class="number">262656</span>    (?, <span class="number">512</span>)             (<span class="number">512</span>, <span class="number">512</span>)      </span><br><span class="line">G_mapping/Dense3                <span class="number">262656</span>    (?, <span class="number">512</span>)             (<span class="number">512</span>, <span class="number">512</span>)      </span><br><span class="line">G_mapping/Dense4                <span class="number">262656</span>    (?, <span class="number">512</span>)             (<span class="number">512</span>, <span class="number">512</span>)      </span><br><span class="line">G_mapping/Dense5                <span class="number">262656</span>    (?, <span class="number">512</span>)             (<span class="number">512</span>, <span class="number">512</span>)      </span><br><span class="line">G_mapping/Dense6                <span class="number">262656</span>    (?, <span class="number">512</span>)             (<span class="number">512</span>, <span class="number">512</span>)      </span><br><span class="line">G_mapping/Dense7                <span class="number">262656</span>    (?, <span class="number">512</span>)             (<span class="number">512</span>, <span class="number">512</span>)      </span><br><span class="line">G_mapping/Broadcast             -         (?, <span class="number">18</span>, <span class="number">512</span>)         -               </span><br><span class="line">G_mapping/dlatents_out          -         (?, <span class="number">18</span>, <span class="number">512</span>)         -               </span><br><span class="line">Truncation                      -         (?, <span class="number">18</span>, <span class="number">512</span>)         -               </span><br><span class="line">G_synthesis/dlatents_in         -         (?, <span class="number">18</span>, <span class="number">512</span>)         -               </span><br><span class="line">G_synthesis/4x4/Const           <span class="number">534528</span>    (?, <span class="number">512</span>, <span class="number">4</span>, <span class="number">4</span>)       (<span class="number">512</span>,)          </span><br><span class="line">G_synthesis/4x4/Conv            <span class="number">2885632</span>   (?, <span class="number">512</span>, <span class="number">4</span>, <span class="number">4</span>)       (<span class="number">3</span>, <span class="number">3</span>, <span class="number">512</span>, <span class="number">512</span>)</span><br><span class="line">G_synthesis/ToRGB_lod8          <span class="number">1539</span>      (?, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>)         (<span class="number">1</span>, <span class="number">1</span>, <span class="number">512</span>, <span class="number">3</span>)  </span><br><span class="line">G_synthesis/8x8/Conv0_up        <span class="number">2885632</span>   (?, <span class="number">512</span>, <span class="number">8</span>, <span class="number">8</span>)       (<span class="number">3</span>, <span class="number">3</span>, <span class="number">512</span>, <span class="number">512</span>)</span><br><span class="line">G_synthesis/8x8/Conv1           <span class="number">2885632</span>   (?, <span class="number">512</span>, <span class="number">8</span>, <span class="number">8</span>)       (<span class="number">3</span>, <span class="number">3</span>, <span class="number">512</span>, <span class="number">512</span>)</span><br><span class="line">G_synthesis/ToRGB_lod7          <span class="number">1539</span>      (?, <span class="number">3</span>, <span class="number">8</span>, <span class="number">8</span>)         (<span class="number">1</span>, <span class="number">1</span>, <span class="number">512</span>, <span class="number">3</span>)  </span><br><span class="line">G_synthesis/Upscale2D           -         (?, <span class="number">3</span>, <span class="number">8</span>, <span class="number">8</span>)         -               </span><br><span class="line">G_synthesis/Grow_lod7           -         (?, <span class="number">3</span>, <span class="number">8</span>, <span class="number">8</span>)         -               </span><br><span class="line">G_synthesis/16x16/Conv0_up      <span class="number">2885632</span>   (?, <span class="number">512</span>, <span class="number">16</span>, <span class="number">16</span>)     (<span class="number">3</span>, <span class="number">3</span>, <span class="number">512</span>, <span class="number">512</span>)</span><br><span class="line">G_synthesis/16x16/Conv1         <span class="number">2885632</span>   (?, <span class="number">512</span>, <span class="number">16</span>, <span class="number">16</span>)     (<span class="number">3</span>, <span class="number">3</span>, <span class="number">512</span>, <span class="number">512</span>)</span><br><span class="line">G_synthesis/ToRGB_lod6          <span class="number">1539</span>      (?, <span class="number">3</span>, <span class="number">16</span>, <span class="number">16</span>)       (<span class="number">1</span>, <span class="number">1</span>, <span class="number">512</span>, <span class="number">3</span>)  </span><br><span class="line">G_synthesis/Upscale2D_1         -         (?, <span class="number">3</span>, <span class="number">16</span>, <span class="number">16</span>)       -               </span><br><span class="line">G_synthesis/Grow_lod6           -         (?, <span class="number">3</span>, <span class="number">16</span>, <span class="number">16</span>)       -               </span><br><span class="line">G_synthesis/32x32/Conv0_up      <span class="number">2885632</span>   (?, <span class="number">512</span>, <span class="number">32</span>, <span class="number">32</span>)     (<span class="number">3</span>, <span class="number">3</span>, <span class="number">512</span>, <span class="number">512</span>)</span><br><span class="line">G_synthesis/32x32/Conv1         <span class="number">2885632</span>   (?, <span class="number">512</span>, <span class="number">32</span>, <span class="number">32</span>)     (<span class="number">3</span>, <span class="number">3</span>, <span class="number">512</span>, <span class="number">512</span>)</span><br><span class="line">G_synthesis/ToRGB_lod5          <span class="number">1539</span>      (?, <span class="number">3</span>, <span class="number">32</span>, <span class="number">32</span>)       (<span class="number">1</span>, <span class="number">1</span>, <span class="number">512</span>, <span class="number">3</span>)  </span><br><span class="line">G_synthesis/Upscale2D_2         -         (?, <span class="number">3</span>, <span class="number">32</span>, <span class="number">32</span>)       -               </span><br><span class="line">G_synthesis/Grow_lod5           -         (?, <span class="number">3</span>, <span class="number">32</span>, <span class="number">32</span>)       -               </span><br><span class="line">G_synthesis/64x64/Conv0_up      <span class="number">1442816</span>   (?, <span class="number">256</span>, <span class="number">64</span>, <span class="number">64</span>)     (<span class="number">3</span>, <span class="number">3</span>, <span class="number">512</span>, <span class="number">256</span>)</span><br><span class="line">G_synthesis/64x64/Conv1         <span class="number">852992</span>    (?, <span class="number">256</span>, <span class="number">64</span>, <span class="number">64</span>)     (<span class="number">3</span>, <span class="number">3</span>, <span class="number">256</span>, <span class="number">256</span>)</span><br><span class="line">G_synthesis/ToRGB_lod4          <span class="number">771</span>       (?, <span class="number">3</span>, <span class="number">64</span>, <span class="number">64</span>)       (<span class="number">1</span>, <span class="number">1</span>, <span class="number">256</span>, <span class="number">3</span>)  </span><br><span class="line">G_synthesis/Upscale2D_3         -         (?, <span class="number">3</span>, <span class="number">64</span>, <span class="number">64</span>)       -               </span><br><span class="line">G_synthesis/Grow_lod4           -         (?, <span class="number">3</span>, <span class="number">64</span>, <span class="number">64</span>)       -               </span><br><span class="line">G_synthesis/128x128/Conv0_up    <span class="number">426496</span>    (?, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>)   (<span class="number">3</span>, <span class="number">3</span>, <span class="number">256</span>, <span class="number">128</span>)</span><br><span class="line">G_synthesis/128x128/Conv1       <span class="number">279040</span>    (?, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>)   (<span class="number">3</span>, <span class="number">3</span>, <span class="number">128</span>, <span class="number">128</span>)</span><br><span class="line">G_synthesis/ToRGB_lod3          <span class="number">387</span>       (?, <span class="number">3</span>, <span class="number">128</span>, <span class="number">128</span>)     (<span class="number">1</span>, <span class="number">1</span>, <span class="number">128</span>, <span class="number">3</span>)  </span><br><span class="line">G_synthesis/Upscale2D_4         -         (?, <span class="number">3</span>, <span class="number">128</span>, <span class="number">128</span>)     -               </span><br><span class="line">G_synthesis/Grow_lod3           -         (?, <span class="number">3</span>, <span class="number">128</span>, <span class="number">128</span>)     -               </span><br><span class="line">G_synthesis/256x256/Conv0_up    <span class="number">139520</span>    (?, <span class="number">64</span>, <span class="number">256</span>, <span class="number">256</span>)    (<span class="number">3</span>, <span class="number">3</span>, <span class="number">128</span>, <span class="number">64</span>) </span><br><span class="line">G_synthesis/256x256/Conv1       <span class="number">102656</span>    (?, <span class="number">64</span>, <span class="number">256</span>, <span class="number">256</span>)    (<span class="number">3</span>, <span class="number">3</span>, <span class="number">64</span>, <span class="number">64</span>)  </span><br><span class="line">G_synthesis/ToRGB_lod2          <span class="number">195</span>       (?, <span class="number">3</span>, <span class="number">256</span>, <span class="number">256</span>)     (<span class="number">1</span>, <span class="number">1</span>, <span class="number">64</span>, <span class="number">3</span>)   </span><br><span class="line">G_synthesis/Upscale2D_5         -         (?, <span class="number">3</span>, <span class="number">256</span>, <span class="number">256</span>)     -               </span><br><span class="line">G_synthesis/Grow_lod2           -         (?, <span class="number">3</span>, <span class="number">256</span>, <span class="number">256</span>)     -               </span><br><span class="line">G_synthesis/512x512/Conv0_up    <span class="number">51328</span>     (?, <span class="number">32</span>, <span class="number">512</span>, <span class="number">512</span>)    (<span class="number">3</span>, <span class="number">3</span>, <span class="number">64</span>, <span class="number">32</span>)  </span><br><span class="line">G_synthesis/512x512/Conv1       <span class="number">42112</span>     (?, <span class="number">32</span>, <span class="number">512</span>, <span class="number">512</span>)    (<span class="number">3</span>, <span class="number">3</span>, <span class="number">32</span>, <span class="number">32</span>)  </span><br><span class="line">G_synthesis/ToRGB_lod1          <span class="number">99</span>        (?, <span class="number">3</span>, <span class="number">512</span>, <span class="number">512</span>)     (<span class="number">1</span>, <span class="number">1</span>, <span class="number">32</span>, <span class="number">3</span>)   </span><br><span class="line">G_synthesis/Upscale2D_6         -         (?, <span class="number">3</span>, <span class="number">512</span>, <span class="number">512</span>)     -               </span><br><span class="line">G_synthesis/Grow_lod1           -         (?, <span class="number">3</span>, <span class="number">512</span>, <span class="number">512</span>)     -               </span><br><span class="line">G_synthesis/1024x1024/Conv0_up  <span class="number">21056</span>     (?, <span class="number">16</span>, <span class="number">1024</span>, <span class="number">1024</span>)  (<span class="number">3</span>, <span class="number">3</span>, <span class="number">32</span>, <span class="number">16</span>)  </span><br><span class="line">G_synthesis/1024x1024/Conv1     <span class="number">18752</span>     (?, <span class="number">16</span>, <span class="number">1024</span>, <span class="number">1024</span>)  (<span class="number">3</span>, <span class="number">3</span>, <span class="number">16</span>, <span class="number">16</span>)  </span><br><span class="line">G_synthesis/ToRGB_lod0          <span class="number">51</span>        (?, <span class="number">3</span>, <span class="number">1024</span>, <span class="number">1024</span>)   (<span class="number">1</span>, <span class="number">1</span>, <span class="number">16</span>, <span class="number">3</span>)   </span><br><span class="line">G_synthesis/Upscale2D_7         -         (?, <span class="number">3</span>, <span class="number">1024</span>, <span class="number">1024</span>)   -               </span><br><span class="line">G_synthesis/Grow_lod0           -         (?, <span class="number">3</span>, <span class="number">1024</span>, <span class="number">1024</span>)   -               </span><br><span class="line">G_synthesis/images_out          -         (?, <span class="number">3</span>, <span class="number">1024</span>, <span class="number">1024</span>)   -               </span><br><span class="line">G_synthesis/lod                 -         ()                   -               </span><br><span class="line">G_synthesis/noise0              -         (<span class="number">1</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">4</span>)         -               </span><br><span class="line">G_synthesis/noise1              -         (<span class="number">1</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">4</span>)         -               </span><br><span class="line">G_synthesis/noise2              -         (<span class="number">1</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">8</span>)         -               </span><br><span class="line">G_synthesis/noise3              -         (<span class="number">1</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">8</span>)         -               </span><br><span class="line">G_synthesis/noise4              -         (<span class="number">1</span>, <span class="number">1</span>, <span class="number">16</span>, <span class="number">16</span>)       -               </span><br><span class="line">G_synthesis/noise5              -         (<span class="number">1</span>, <span class="number">1</span>, <span class="number">16</span>, <span class="number">16</span>)       -               </span><br><span class="line">G_synthesis/noise6              -         (<span class="number">1</span>, <span class="number">1</span>, <span class="number">32</span>, <span class="number">32</span>)       -               </span><br><span class="line">G_synthesis/noise7              -         (<span class="number">1</span>, <span class="number">1</span>, <span class="number">32</span>, <span class="number">32</span>)       -               </span><br><span class="line">G_synthesis/noise8              -         (<span class="number">1</span>, <span class="number">1</span>, <span class="number">64</span>, <span class="number">64</span>)       -               </span><br><span class="line">G_synthesis/noise9              -         (<span class="number">1</span>, <span class="number">1</span>, <span class="number">64</span>, <span class="number">64</span>)       -               </span><br><span class="line">G_synthesis/noise10             -         (<span class="number">1</span>, <span class="number">1</span>, <span class="number">128</span>, <span class="number">128</span>)     -               </span><br><span class="line">G_synthesis/noise11             -         (<span class="number">1</span>, <span class="number">1</span>, <span class="number">128</span>, <span class="number">128</span>)     -               </span><br><span class="line">G_synthesis/noise12             -         (<span class="number">1</span>, <span class="number">1</span>, <span class="number">256</span>, <span class="number">256</span>)     -               </span><br><span class="line">G_synthesis/noise13             -         (<span class="number">1</span>, <span class="number">1</span>, <span class="number">256</span>, <span class="number">256</span>)     -               </span><br><span class="line">G_synthesis/noise14             -         (<span class="number">1</span>, <span class="number">1</span>, <span class="number">512</span>, <span class="number">512</span>)     -               </span><br><span class="line">G_synthesis/noise15             -         (<span class="number">1</span>, <span class="number">1</span>, <span class="number">512</span>, <span class="number">512</span>)     -               </span><br><span class="line">G_synthesis/noise16             -         (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1024</span>, <span class="number">1024</span>)   -               </span><br><span class="line">G_synthesis/noise17             -         (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1024</span>, <span class="number">1024</span>)   -               </span><br><span class="line">images_out                      -         (?, <span class="number">3</span>, <span class="number">1024</span>, <span class="number">1024</span>)   -               </span><br><span class="line">---                             ---       ---                  ---             </span><br><span class="line">Total                           <span class="number">26219627</span>                                       </span><br></pre></td></tr></table></figure>
<h2 id="np-random-RandomState"><a href="#np-random-RandomState" class="headerlink" title="np.random.RandomState"></a>np.random.RandomState</h2><p>代码<code>rnd = np.random.RandomState(seed)</code>基于<strong>Mesenne Twister</strong>算法生成伪随机数:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">       rnd = np.random.RandomState(<span class="literal">None</span>)</span><br><span class="line">       <span class="built_in">print</span>(rnd.randint(<span class="number">1</span>, <span class="number">10</span>, <span class="number">5</span>))</span><br><span class="line">[output]::</span><br><span class="line">[<span class="number">7</span> <span class="number">6</span> <span class="number">7</span> <span class="number">5</span> <span class="number">6</span>]</span><br><span class="line">[<span class="number">7</span> <span class="number">4</span> <span class="number">5</span> <span class="number">3</span> <span class="number">9</span>]</span><br><span class="line">[<span class="number">1</span> <span class="number">7</span> <span class="number">9</span> <span class="number">3</span> <span class="number">6</span>]</span><br><span class="line">[<span class="number">5</span> <span class="number">3</span> <span class="number">3</span> <span class="number">1</span> <span class="number">3</span>]</span><br><span class="line">[<span class="number">9</span> <span class="number">3</span> <span class="number">5</span> <span class="number">2</span> <span class="number">9</span>]</span><br><span class="line">&gt;&gt;&gt;<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">       rnd = np.random.RandomState(<span class="number">1</span>)</span><br><span class="line">       <span class="built_in">print</span>(rnd.randint(<span class="number">1</span>, <span class="number">10</span>, <span class="number">5</span>))</span><br><span class="line">[output]::</span><br><span class="line">[<span class="number">6</span> <span class="number">9</span> <span class="number">6</span> <span class="number">1</span> <span class="number">1</span>]</span><br><span class="line">[<span class="number">6</span> <span class="number">9</span> <span class="number">6</span> <span class="number">1</span> <span class="number">1</span>]</span><br><span class="line">[<span class="number">6</span> <span class="number">9</span> <span class="number">6</span> <span class="number">1</span> <span class="number">1</span>]</span><br><span class="line">[<span class="number">6</span> <span class="number">9</span> <span class="number">6</span> <span class="number">1</span> <span class="number">1</span>]</span><br><span class="line">[<span class="number">6</span> <span class="number">9</span> <span class="number">6</span> <span class="number">1</span> <span class="number">1</span>]</span><br><span class="line">&gt;&gt;&gt;rnd = np.random.RandomState(<span class="number">1</span>)</span><br><span class="line">   <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">       <span class="built_in">print</span>(rnd.randint(<span class="number">1</span>, <span class="number">10</span>, <span class="number">5</span>))</span><br><span class="line">[output]::</span><br><span class="line">[<span class="number">6</span> <span class="number">9</span> <span class="number">6</span> <span class="number">1</span> <span class="number">1</span>]</span><br><span class="line">[<span class="number">2</span> <span class="number">8</span> <span class="number">7</span> <span class="number">3</span> <span class="number">5</span>]</span><br><span class="line">[<span class="number">6</span> <span class="number">3</span> <span class="number">5</span> <span class="number">3</span> <span class="number">5</span>]</span><br><span class="line">[<span class="number">8</span> <span class="number">8</span> <span class="number">2</span> <span class="number">8</span> <span class="number">1</span>]</span><br><span class="line">[<span class="number">7</span> <span class="number">8</span> <span class="number">7</span> <span class="number">2</span> <span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p>   <code>latents = rnd.randn(1, Gs.input_shape[1])</code>生成一个(1, 512)的随机向量。<br>   <code>fmt=dict(func=tflib.convert_images_to_uint8,nchw_to_nhwc=True)</code>将函数<code>tflib.convert_images_to_uint8</code>以及<strong>bool</strong>值<code>nchw_to_nhwc=True</code>打包成字典<strong>fmt</strong>。</p>
<h2 id="tflib-convert-images-to-uint8"><a href="#tflib-convert-images-to-uint8" class="headerlink" title="tflib.convert_images_to_uint8"></a>tflib.convert_images_to_uint8</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;将数据类型为float32的minibatch图像转换为uint8.以及调整数据格式.</span></span><br><span class="line"><span class="string">可以用来对Network.run()的输出做转换处理.&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">convert_images_to_uint8</span>(<span class="params">images, drange=[-<span class="number">1</span>,<span class="number">1</span>], nchw_to_nhwc=<span class="literal">False</span>, shrink=<span class="number">1</span></span>):</span><br><span class="line">    images = tf.cast(images, tf.float32)</span><br><span class="line">    <span class="keyword">if</span> shrink &gt; <span class="number">1</span>:</span><br><span class="line">        ksize = [<span class="number">1</span>, <span class="number">1</span>, shrink, shrink]</span><br><span class="line">        images = tf.nn.avg_pool(images, ksize=ksize, strides=ksize, padding=<span class="string">&quot;VALID&quot;</span>, data_format=<span class="string">&quot;NCHW&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> nchw_to_nhwc:</span><br><span class="line">        images = tf.transpose(images, [<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>])</span><br><span class="line">    scale = <span class="number">255</span> / (drange[<span class="number">1</span>] - drange[<span class="number">0</span>]) <span class="comment"># scale = 127.5</span></span><br><span class="line">    images = images * scale + (<span class="number">0.5</span> - drange[<span class="number">0</span>] * scale)</span><br><span class="line">    <span class="keyword">return</span> tf.saturate_cast(images, tf.uint8)</span><br></pre></td></tr></table></figure>
<p> <strong>“NHWC”</strong>模式下，批次数据的排列顺序为[batch, height, width, channels]（TF的默认设置）<br> <strong>“NCHW”</strong>模式下，批次数据的排列顺序为[batch, channels, height, width]<br> <strong>NHWC</strong>和<strong>NCHW</strong>的解读可参照<a href="https://blog.csdn.net/weixin_41847115/article/details/83794551#commentBox">深度学习(4):NCHW和NHWC</a>，后续个人将完善这部分的学习。</p>
<h2 id="Gs-run"><a href="#Gs-run" class="headerlink" title="Gs.run"></a>Gs.run</h2><p><code>images=Gs.run(latents,None,truncation_psi=0.7,randomize_noise=True,output_transform=fmt)</code>调用<strong>dnnlib/tflib/network.py</strong>中<strong>Network</strong>类的<strong>run</strong>。关于<strong>network.py</strong>的解读将放在其它文章中。</p>
<h2 id="os-makedirs-amp-os-path-join"><a href="#os-makedirs-amp-os-path-join" class="headerlink" title="os.makedirs &amp; os.path.join"></a>os.makedirs &amp; os.path.join</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">os.makedirs(config.result_dir, exist_ok=<span class="literal">True</span>)</span><br><span class="line">png_filename = os.path.join(config.result_dir,<span class="string">&#x27;example.png&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p><code>os.makedirs(config.result_dir, exist_ok=True)</code>会根据<strong>config.result_dir</strong>提供的路径创建相应的文件夹，<strong>exist_ok=True</strong>用于当上述文件夹已经存在时屏蔽<code>OSError</code> 。<br><code>os.path.join(a)</code>函数可以将多个路径分量(父路径以及文件名)通过分隔符<code>&#39;/&#39;</code>连接在一起，本例中将<strong>config.result_dir</strong>与<strong>‘example.png’</strong>连接并赋值给<strong>png_filename</strong>，相当于<code>png_filename=&quot;%s/%s&quot;%(config.result_dir,&#39;example.png&#39;)</code>。</p>
<h2 id="PIL-Image-fromarray"><a href="#PIL-Image-fromarray" class="headerlink" title="PIL.Image.fromarray"></a>PIL.Image.fromarray</h2><p><code>PIL.Image.fromarray(images[0],&#39;RGB&#39;).save(png_filename)</code>将<strong>imgages[0]</strong>以<strong>RGB</strong>格式存储在文件<strong>png_filename</strong>中。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>GAN</category>
      </categories>
      <tags>
        <tag>styleGAN</tag>
      </tags>
  </entry>
  <entry>
    <title>Centos安装后无法启动Windows问题</title>
    <url>/2020/08/30/system/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="CentOS安装后Windows无法启动问题"><a href="#CentOS安装后Windows无法启动问题" class="headerlink" title="CentOS安装后Windows无法启动问题"></a>CentOS安装后Windows无法启动问题</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root]$ wget -O /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-7.repo</span><br><span class="line">[root]$ yum update</span><br><span class="line">[root]$ yum install ntfs-3g</span><br><span class="line">[root]$ grub2-mkconfig -o /boot/grub2/grub.cfg </span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>装机</category>
      </categories>
      <tags>
        <tag>装机</tag>
      </tags>
  </entry>
  <entry>
    <title>Tensorboard记录Loss变化</title>
    <url>/2020/10/14/tensorflow1.14.0_loss_summary/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="利用Tensorboard记录Loss值"><a href="#利用Tensorboard记录Loss值" class="headerlink" title="利用Tensorboard记录Loss值"></a>利用Tensorboard记录Loss值</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">运行环境：</span><br><span class="line">tensorflow==<span class="number">1.14</span><span class="number">.0</span></span><br><span class="line">keras==<span class="number">2.2</span><span class="number">.5</span></span><br></pre></td></tr></table></figure>
<h1 id="构建模型"><a href="#构建模型" class="headerlink" title="构建模型"></a>构建模型</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">CNN = build_cnn()</span><br><span class="line"><span class="comment"># type(CNN) = keras.engine.training.Model</span></span><br></pre></td></tr></table></figure>
<h1 id="log记录函数"><a href="#log记录函数" class="headerlink" title="log记录函数"></a>log记录函数</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">write_log</span>(<span class="params">callback, names, logs, batch_no</span>):</span><br><span class="line">    <span class="keyword">for</span> name, value <span class="keyword">in</span> <span class="built_in">zip</span>(names, logs):</span><br><span class="line">        summary = tf.Summary()</span><br><span class="line">        summary_value = summary.value.add()</span><br><span class="line">        summary_value.simple_value = value</span><br><span class="line">        summary_value.tag = name</span><br><span class="line">        callback.writer.add_summary(summary, batch_no)</span><br><span class="line">        callback.writer.flush()</span><br></pre></td></tr></table></figure>
<h1 id="创建Tensorboard记录"><a href="#创建Tensorboard记录" class="headerlink" title="创建Tensorboard记录"></a>创建Tensorboard记录</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># log_path = &#x27;./logs&#x27;</span></span><br><span class="line">callback = TensorBoard(log_path)</span><br><span class="line">callback.set_model(CNN)</span><br></pre></td></tr></table></figure>
<h1 id="在训练过程中记录Loss"><a href="#在训练过程中记录Loss" class="headerlink" title="在训练过程中记录Loss"></a>在训练过程中记录Loss</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">datasize = X.shape[<span class="number">0</span>]</span><br><span class="line">batches = datasize//batch_size</span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(epochs):</span><br><span class="line">	<span class="keyword">for</span> batch <span class="keyword">in</span> <span class="built_in">range</span>(batches):</span><br><span class="line">		loss = CNN.train_on_batch(x, y)</span><br><span class="line">		write_log(callback, </span><br><span class="line">                  CNN.metrics_names,</span><br><span class="line">                  loss,</span><br><span class="line">                  epoch * batches + batch)</span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>tensorflow</category>
      </categories>
      <tags>
        <tag>tensorboard</tag>
      </tags>
  </entry>
  <entry>
    <title>tensorflow之scope使用</title>
    <url>/2020/07/12/tf_name_scope_variable_scope_new/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="tensorflow中名称作用域和变量作用域"><a href="#tensorflow中名称作用域和变量作用域" class="headerlink" title="tensorflow中名称作用域和变量作用域"></a>tensorflow中名称作用域和变量作用域</h1><p>名称作用域和变量作用域能让我们在<strong>tensorboard</strong>中更清晰得看到各类变量所处的命名空间以及输入、输出的流动方向。当神经网络架构较为复杂时，可以通过为网络不同块的变量和运算创建作用域的形式来使<strong>graph</strong>更整洁。(源码为官方代码，<strong>注释为翻译版</strong>，英文版请查看源码<strong>doc</strong>或者关注<a href="https://tensorflow.google.cn/api_docs/python/tf/compat/v1/variable_scope">官方网站</a>)</p>
<h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Init signature:</span><br><span class="line">tf.variable_scope(</span><br><span class="line">    name_or_scope, <span class="comment"># 传入&lt;str&gt;或者scope</span></span><br><span class="line">    default_name=<span class="literal">None</span>, <span class="comment"># 若name_or_scope==None，则自动生成具有唯一标示的名称；</span></span><br><span class="line">    values=<span class="literal">None</span>, <span class="comment"># 需要用于op的Tensor列表</span></span><br><span class="line">    initializer=<span class="literal">None</span>, <span class="comment"># 该scope中变量默认初始化方式</span></span><br><span class="line">    regularizer=<span class="literal">None</span>, <span class="comment"># 该scope中变量默认正则化方式</span></span><br><span class="line">    caching_device=<span class="literal">None</span>, <span class="comment"># 该scope中变量默认缓存设备</span></span><br><span class="line">    partitioner=<span class="literal">None</span>, <span class="comment"># 该scope中变量的默认分区</span></span><br><span class="line">    custom_getter=<span class="literal">None</span>, <span class="comment"># 不知道干啥的</span></span><br><span class="line">    reuse=<span class="literal">None</span>, <span class="comment"># 是否重用，True,None or tf.AUTO_REUSE</span></span><br><span class="line">    dtype=<span class="literal">None</span>, <span class="comment"># 变量类型(默认为传入的变量类型或者从父scope继承)</span></span><br><span class="line">    use_resource=<span class="literal">None</span>, <span class="comment"># False: 所有变量均为均为常规变量。\\ True: 具有良定义语义学的experimental ResourceVariables</span></span><br><span class="line">    constraint=<span class="literal">None</span>, <span class="comment"># 在优化器更新变量之后，使用一个投影函数对输出进行变换。</span></span><br><span class="line">    auxiliary_name_scope=<span class="literal">True</span>, <span class="comment"># True:创建一个辅助name scope;该变量不具有继承属性，\\ 只有第一次创建时才有作用；所以应在重新进入已经创建好的scope时才使用。</span></span><br><span class="line">)</span><br><span class="line"><span class="comment"># 函数返回一个可以被capture和reuse的socpe。</span></span><br></pre></td></tr></table></figure>
<p>函数注释:     </p>
<p>一个定义<code>vars</code>或<code>layers</code>生成<code>ops</code>的上下文管理器。</p>
<p>这一上下文管理器会确认（可选）<code>values</code>是否来自于同一<code>graph</code>，确保<code>graph</code>是默认<code>graph</code>，并且会<code>push</code>名称作用域(<code>name_scpoe</code>)和变量作用域(<code>variable_scope</code>)</p>
<p>如果<code>name_or_scope</code>不为<code>None</code>,则使用<code>as is</code>.如果<code>scope</code>为<code>None</code>,则使用<code>default_name</code>。此时，如果已经使用过相同的名字，则在其后添加<code>_N</code>表示第<strong>N</strong>个具有相同名称前缀的作用域或变量来使其具有唯一性。</p>
<p>在<code>variable_scope</code>中可以创建新的变量，也可以共享已经创建的变量，并且可以检查是否存在意外创建或共享的情况。</p>
<p>创建一个新的变量：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> tf.compat.v1.variable_scope(<span class="string">&quot;foo&quot;</span>):</span><br><span class="line">    <span class="keyword">with</span> tf.compat.v1.variable_scope(<span class="string">&quot;bar&quot;</span>):</span><br><span class="line">        v = tf.compat.v1.get_variable(<span class="string">&quot;v&quot;</span>, [<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">assert</span> v.name == <span class="string">&quot;foo/bar/v:0&quot;</span></span><br></pre></td></tr></table></figure>
<p>安全进入一个已经创建好的<code>variable scope</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> tf.compat.v1.variable_scope(<span class="string">&quot;foo&quot;</span>) <span class="keyword">as</span> vs:</span><br><span class="line">  <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新进入变量作用域</span></span><br><span class="line"><span class="keyword">with</span> tf.compat.v1.variable_scope(vs, auxiliary_name_scope=<span class="literal">False</span>) <span class="keyword">as</span> vs1:</span><br><span class="line">  <span class="comment"># 重建原始的名称作用域</span></span><br><span class="line">  <span class="keyword">with</span> tf.name_scope(vs1.original_name_scope):</span><br><span class="line">      v = tf.compat.v1.get_variable(<span class="string">&quot;v&quot;</span>, [<span class="number">1</span>])</span><br><span class="line">      <span class="keyword">assert</span> v.name == <span class="string">&quot;foo/v:0&quot;</span></span><br><span class="line">      c = tf.constant([<span class="number">1</span>], name=<span class="string">&quot;c&quot;</span>)</span><br><span class="line">      <span class="keyword">assert</span> c.name == <span class="string">&quot;foo/c:0&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(v)</span><br><span class="line">&lt;tf.Variable <span class="string">&#x27;foo/v:0&#x27;</span> shape=(<span class="number">1</span>,) dtype=float32_ref&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">type</span>(v))</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;tensorflow.python.ops.variables.RefVariable&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(c)</span><br><span class="line">Tensor(<span class="string">&quot;foo/c:0&quot;</span>, shape=(<span class="number">1</span>,), dtype=int32)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">type</span>(c))</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;tensorflow.python.framework.ops.Tensor&#x27;</span>&gt;</span><br></pre></td></tr></table></figure>
<p>通过 <code>AUTO_REUSE</code>共享变量：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line">  <span class="keyword">with</span> tf.compat.v1.variable_scope(<span class="string">&quot;foo&quot;</span>,</span><br><span class="line">  reuse=tf.compat.v1.AUTO_REUSE):</span><br><span class="line">    v = tf.compat.v1.get_variable(<span class="string">&quot;v&quot;</span>, [<span class="number">1</span>])</span><br><span class="line">  <span class="keyword">return</span> v</span><br><span class="line"></span><br><span class="line">v1 = foo()  <span class="comment"># 创建变量 v.</span></span><br><span class="line">v2 = foo()  <span class="comment"># 获取创建的 v，即v1.</span></span><br><span class="line"><span class="keyword">assert</span> v1 == v2</span><br><span class="line"><span class="keyword">assert</span> <span class="built_in">id</span>(v1) == <span class="built_in">id</span>(v2) </span><br><span class="line"><span class="comment"># 相当于v1和v2均指向相同的内存地址</span></span><br></pre></td></tr></table></figure>
<p>通过 <code>reuse=True</code>共享变量:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> tf.compat.v1.variable_scope(<span class="string">&quot;foo&quot;</span>):</span><br><span class="line">    v = tf.compat.v1.get_variable(<span class="string">&quot;v&quot;</span>, [<span class="number">1</span>])</span><br><span class="line"><span class="keyword">with</span> tf.compat.v1.variable_scope(<span class="string">&quot;foo&quot;</span>, reuse=<span class="literal">True</span>):</span><br><span class="line">    v1 = tf.compat.v1.get_variable(<span class="string">&quot;v&quot;</span>, [<span class="number">1</span>])</span><br><span class="line"><span class="keyword">assert</span> v1 == v</span><br><span class="line"><span class="keyword">assert</span> <span class="built_in">id</span>(v1) == <span class="built_in">id</span>(v)</span><br></pre></td></tr></table></figure>
<p>在当前<code>scope</code>内设置<code>reuse</code>:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 注意：必须要把scope.reuse_variables()放在已创建的变量之后以及重用之前。</span></span><br><span class="line"><span class="keyword">with</span> tf.compat.v1.variable_scope(<span class="string">&quot;foo&quot;</span>) <span class="keyword">as</span> scope:</span><br><span class="line">    v = tf.compat.v1.get_variable(<span class="string">&quot;v&quot;</span>, [<span class="number">1</span>])</span><br><span class="line">    scope.reuse_variables()</span><br><span class="line">    v1 = tf.compat.v1.get_variable(<span class="string">&quot;v&quot;</span>, [<span class="number">1</span>])</span><br><span class="line"><span class="keyword">assert</span> v1 == v</span><br></pre></td></tr></table></figure>
<p>为了避免变量的意外共享，当并未在<code>scope</code>中设置<code>reuse</code>而重复定义相同命名的变量时会抛出<code>ValueError</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> tf.compat.v1.variable_scope(<span class="string">&quot;foo&quot;</span>):</span><br><span class="line">    v = tf.compat.v1.get_variable(<span class="string">&quot;v&quot;</span>, [<span class="number">1</span>])</span><br><span class="line">    v1 = tf.compat.v1.get_variable(<span class="string">&quot;v&quot;</span>, [<span class="number">1</span>])</span><br><span class="line">    <span class="comment">#  Raises ValueError(&quot;... v already exists ...&quot;).</span></span><br></pre></td></tr></table></figure>
<p>同样地，当<code>reuse</code>为<code>True</code>时，如果第一次定义变量也会抛出<code>VauleError</code>(即没有可以用来重用的变量)：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> tf.compat.v1.variable_scope(<span class="string">&quot;foo&quot;</span>, reuse=<span class="literal">True</span>):</span><br><span class="line">    v = tf.compat.v1.get_variable(<span class="string">&quot;v&quot;</span>, [<span class="number">1</span>])</span><br><span class="line">    <span class="comment">#  Raises ValueError(&quot;... v does not exists ...&quot;).</span></span><br></pre></td></tr></table></figure>
<p> <code>reuse</code>的继承属性：当打开一个<code>reusing</code>作用域时，其中的所有子作用域也将是<code>resuing</code>的。</p>
<p>多线程环境中的变量作用域说明：variable scope是线程的局部变量，所以一个线程的scope对于另一线程而言是不可见的。另外，当使用<code>default_name</code>，唯一的<code>scope</code>名称也只是相对于每一个线程而言的，如果多个线程使用了相同的名字，一个新的线程仍然能够创建相同的<code>scope</code></p>
<p>以下示例中，变量是被线程共享的(同一<code>graph</code>中)。严格来讲，只有当<code>resue</code>为<code>True</code>时，线程在创建其它线程已经创建过的同名变量时才会成功。</p>
<p>另外，每个线程的起始<code>scope</code>为空，所以如果想在其它线程中保留主线程<code>scope</code>中变量的名称前缀，需要capture主线程的scope并在其它线程中重新进入这一<code>scope</code>，例：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">main_thread_scope = variable_scope.get_variable_scope()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Thread&#x27;s target function:</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">thread_target_fn</span>(<span class="params">captured_scope</span>):</span><br><span class="line">  <span class="keyword">with</span> variable_scope.variable_scope(captured_scope):</span><br><span class="line">    <span class="comment"># .... regular code for this thread</span></span><br><span class="line">    </span><br><span class="line">thread = threading.Thread(target=thread_target_fn, args=(main_thread_scope,))</span><br></pre></td></tr></table></figure>
<h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><h2 id="variable-scope"><a href="#variable-scope" class="headerlink" title="variable_scope"></a>variable_scope</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">scope1 = <span class="string">&quot;Test1&quot;</span></span><br><span class="line"><span class="keyword">with</span> tf.variable_scope(scope1):</span><br><span class="line">    testA = tf.get_variable(<span class="string">&quot;testA1&quot;</span>, [<span class="number">3</span>, <span class="number">256</span>, <span class="number">256</span>])</span><br><span class="line">    testB = tf.get_variable(<span class="string">&quot;testA2&quot;</span>, [<span class="number">3</span>, <span class="number">256</span>, <span class="number">256</span>])</span><br><span class="line">    testC = tf.multiply(testA, testB, name = <span class="string">&quot;Mul-testA12&quot;</span>)</span><br><span class="line">    testD = tf.Variable([<span class="number">1</span>],name=<span class="string">&quot;testD&quot;</span>)</span><br><span class="line"><span class="comment"># testA: &lt;tf.Variable &#x27;Test1/testA1:0&#x27; shape=(3, 256, 256) dtype=float32_ref&gt;</span></span><br><span class="line"><span class="comment"># testB: &lt;tf.Variable &#x27;Test1/testA2:0&#x27; shape=(3, 256, 256) dtype=float32_ref&gt;</span></span><br><span class="line"><span class="comment"># testC: Tensor(&quot;Test1/Mul-testA12:0&quot;, shape=(3, 256, 256), dtype=float32)</span></span><br><span class="line"><span class="comment"># testD: &lt;tf.Variable &#x27;Test1/testD:0&#x27; shape=(1,) dtype=int32_ref&gt;</span></span><br></pre></td></tr></table></figure>
<p>可以看到<code>variable_scope</code>能够同时影响到<code>tf.get_variable</code>以及<code>op</code>的命名，也就是说，变量域的作用范围内命名的变量，其前缀为变量域名。<br><img src="/2020/07/12/tf_name_scope_variable_scope_new/variablescope.png" alt="Tensorboard"></p>
<h2 id="name-scope"><a href="#name-scope" class="headerlink" title="name_scope"></a>name_scope</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">scope1 = <span class="string">&quot;Test1&quot;</span></span><br><span class="line"><span class="keyword">with</span> tf.name_scope(scope1):</span><br><span class="line">    testA = tf.get_variable(<span class="string">&quot;testA1&quot;</span>, [<span class="number">3</span>, <span class="number">256</span>, <span class="number">256</span>])</span><br><span class="line">    testB = tf.get_variable(<span class="string">&quot;testA2&quot;</span>, [<span class="number">3</span>, <span class="number">256</span>, <span class="number">256</span>])</span><br><span class="line">    testC = tf.multiply(testA, testB, name = <span class="string">&quot;Mul-testA12&quot;</span>)</span><br><span class="line">    testD = tf.Variable([<span class="number">1</span>],name=<span class="string">&quot;testD&quot;</span>)</span><br><span class="line"><span class="comment"># testA: &lt;tf.Variable &#x27;testA1:0&#x27; shape=(3, 256, 256) dtype=float32_ref&gt;</span></span><br><span class="line"><span class="comment"># testB: &lt;tf.Variable &#x27;testA2:0&#x27; shape=(3, 256, 256) dtype=float32_ref&gt;</span></span><br><span class="line"><span class="comment"># testC: Tensor(&quot;Test1/Mul-testAC:0&quot;, shape=(3, 256, 256), dtype=float32)</span></span><br><span class="line"><span class="comment"># testD: &lt;tf.Variable &#x27;Test1/testD:0&#x27; shape=(1,) dtype=int32_ref&gt;</span></span><br></pre></td></tr></table></figure>
<p>而在<code>name_scope</code>中，其不会影响到由<code>tf.get_variable</code>得到的变量，只会作用于<code>op</code>运算得到的变量以及由<code>tf.Variable</code>得到的变量。<br><img src="/2020/07/12/tf_name_scope_variable_scope_new/namescope.png" alt="Tensorboard"></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Tensorflow</category>
      </categories>
      <tags>
        <tag>scope</tag>
      </tags>
  </entry>
  <entry>
    <title>第三章 最速下降法</title>
    <url>/2022/12/21/seismic_inversion_3/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="第3章-最速下降法"><a href="#第3章-最速下降法" class="headerlink" title="第3章 最速下降法"></a>第3章 最速下降法</h1><p>本章介绍最速下降优化方法（Steppest descent，SD），其通过沿着最速下降，即负梯度$-\rm \textbf g$方向来迭代地求解优化问题。对于大型优化问题，由于其不需要计算Hessian矩阵的逆，所以其相对于牛顿方法而言计算量更小，但是由于不考虑曲率信息，其Hessian是病态的，所以可能会导致收敛效率较低。然而经验告诉我们，基于预处理和正则化的迭代最速下降法，再加上多尺度反演方法，对于解决大型的地震数据反演问题是非常有效的。</p>
<h2 id="3-1-最速下降法介绍"><a href="#3-1-最速下降法介绍" class="headerlink" title="3.1 最速下降法介绍"></a>3.1 最速下降法介绍</h2><p>在多数三维地球物理问题中，求取和存储Hessian矩阵$\rm \textbf H$的逆是不现实的。例如一个共$1000^3=10^9$网格点的速度模型，其Hessian矩阵的逆的求取需要对$10^18$个元素进行存储和计算。另一种避免计算大型矩阵的逆，但是可能会导致低收敛效率的方法是最速下降法。回顾公式2.18：</p>
<script type="math/tex; mode=display">
\rm \textbf x^{(k+1)}=\rm \textbf x^{(k)}-\alpha[\rm \textbf H^{(k)}]^{-1}\rm \textbf g^{(k)}
\tag{2.18}</script><p>用单位矩阵代替$\rm \textbf H^{-1}$，即可得到最速下降的公式</p>
<script type="math/tex; mode=display">
\rm \textbf x^{(k+1)}=\rm \textbf x^{(k)}-\alpha\rm \textbf g^{(k)}
\tag{3.1}</script><p>其中，$\alpha$是一个正数，其表示步长。$\rm \textbf x^{(k+1)}$的迭代公式沿着负梯度方向（下坡方向）$-\rm \textbf g^{(k)}$寻找一个更好的解。给定起始点$\rm \textbf x^{(k)}$以及负梯度方向$-\rm \textbf g^{(k)}$，需要进一步计算$\alpha$以使得$f(\rm \textbf x^{(k)}-\alpha\rm \textbf g^{(k)})$最小。与之相等价的是，计算的步长需要使$\rm \textbf x^{(k+1)} - \rm \textbf x^{(k)}$与 $\rm \textbf x^{(k+1)}$的等值线相切或接触（如图3.1.b所示）。当残差矢量（误差函数的均方根）小于某个设定的值后迭代终止。</p>
<h3 id="3-1-1收敛速度"><a href="#3-1-1收敛速度" class="headerlink" title="3.1.1收敛速度"></a>3.1.1收敛速度</h3><h2 id="3-2-步长计算"><a href="#3-2-步长计算" class="headerlink" title="3.2 步长计算"></a>3.2 步长计算</h2><p><strong>精确线搜索</strong>和<strong>数值线搜索</strong>是两种常用的计算公式3.1中的步长$\alpha$来使以下公式成立的算法：</p>
<script type="math/tex; mode=display">\underset{\alpha>0} {\rm min} f(\rm \textbf x^{(k)}-\alpha \Delta \rm \textbf x)\tag{3.7}</script><p>其中，$-\Delta \rm \textbf x$是预定义的搜索方向，即当前模型的下山方向。精确线搜索方法使用解析公式确定$\alpha$。而数值线搜索方法则在方向$-\Delta \rm \textbf x$上通过$\alpha$的多项式来近似$f(\rm \textbf x)$（Nocedal and Wright，1999。通过对梯度和曲率施加限定条件来避免陷入局部极小。<br>限制性步长（restricted-step）方法只在一个置信区域（trust region）内搜索最优模型$\rm \textbf x^{(k)}+\alpha \Delta \rm \textbf x$，这个置信区域以$\rm \textbf x$为中心，以$r$为半径，同时置信区域和步长之间的关系满足$||\alpha \Delta \rm \textbf x||&lt;r$。由于根据非线性目标函数估计得到的梯度和曲率只在$\rm \textbf x$附近是合适的，而在较远的变量位置是不合适的，因此这种限制有时是必须的。<br>与直接使用原目标函数$f(\rm \textbf x)=\rm \textbf x^T\rm \textbf H \rm \textbf x+\rm \textbf g^T\rm \textbf x$相比，也可以通过构造一个阻尼目标函数$\tilde f(\rm \textbf x)=\rm \textbf x^T\rm \textbf H \rm \textbf x+\eta^2\rm \textbf x^T\rm \textbf x+\rm \textbf g^T\rm \textbf x$来使病态Hessian稳定下来。这里,$\eta^2$是一个控制置信区域的正整数。$\eta^2$越大，步长越小，所以目标函数$\Delta \tilde f=\tilde f(\rm \textbf x+\Delta  \tilde{\rm \textbf x})-\tilde f(\rm \textbf x)$的减少量将会比$\Delta  f= f(\rm \textbf x+\Delta  \rm \textbf x)- f(\rm \textbf x)$更小。如果$\Delta \tilde f/ \Delta f \geq 0.5$，阻尼不够大，所以需要增大$\eta^2$直到$\Delta \tilde f/ \Delta f$在0.25到0.5之间，对于大型3D问题，试错法（trail-and-error）的计算效率是非常低的。### 3.2.1 精确线搜索<br>下面给出精确线搜索的推导。一维线搜索问题定义为，对于给定的$\rm \textbf x$和$\Delta \rm \textbf x$，找到最优的$\alpha$来使$f(\rm \textbf x+\alpha\Delta  \rm \textbf x)$最小，这种情况下，公式2.9变为</p>
<script type="math/tex; mode=display">f({\rm \textbf x}+\alpha\Delta {\rm \textbf x}) 
\approx f({\rm \textbf x})
+\alpha {\rm \textbf g}^T \Delta {\rm \textbf x}
+\frac{\alpha^2}{2}\Delta {\rm \textbf x}^T \rm \textbf H \Delta \rm \textbf x.
\tag{3.8}</script><p>上式对$\alpha$求导，并令导数等于0，可得：</p>
<script type="math/tex; mode=display">\frac{\partial f(\rm \textbf x+\alpha \Delta \rm \textbf x)}{\partial \alpha}
=\rm \textbf g^T\Delta \rm \textbf x+\alpha \Delta \rm \textbf x^T \rm \textbf H \Delta \rm \textbf x 
=0\tag{3.9}</script><p>可得到$\alpha$的解析解为：</p>
<script type="math/tex; mode=display">\alpha ^\ast = \frac{-\rm \textbf g^g \Delta \rm \textbf x}{\Delta \rm \textbf x^T \rm \textbf H \Delta \rm \textbf x}\tag{3.10}</script><p>由此求得的步长为精确步长。这种线搜索方法为精确线搜索，因为如果$f(\rm \textbf x)$是二次泛函，那么公式3.10中的步长是完全正确的。对于最速下降法，$\Delta \rm \textbf x=-\rm \textbf g$，所以：</p>
<script type="math/tex; mode=display">\alpha^{\ast}= \frac{\rm \textbf g^T \rm \textbf g}{ \rm \textbf g^T \rm \textbf H \rm \textbf g} \tag{3.10}</script><p>经验告诉我们，精确线搜索方法应用效果非常不好，而地震反问题中通常使用数值线搜索方法。</p>
<h3 id="3-2-2-非精确牛顿法和非精确线搜索"><a href="#3-2-2-非精确牛顿法和非精确线搜索" class="headerlink" title="3.2.2 非精确牛顿法和非精确线搜索"></a>3.2.2 非精确牛顿法和非精确线搜索</h3><p>近似Hessian矩阵逆的方法被称为非精确牛顿法（Gill et al., 1981）。如果有一小部分反演是基于共轭梯度法来迭代近似求解的，那么非精确牛顿法又被称为截断牛顿法（truncated Newton method）。在一定的迭代次数后，共轭梯度法的解将会位于最速下降法和牛顿矢量之间，如图3.2所示。AlTheyab et al., (2013)提出了一种内外双循环的FWI算法，在内部循环中通过线性共轭梯度法来迭代近似Hessian的逆。在章节21中介绍了这种方法，其内部循环迭代得到的速度模型被用作外部循环的背景模型，而外部循环是通过非线性共轭梯度法进行迭代的。<br>通过设定终止条件来停止线搜索的方法被称为非精确线搜索方法。常用的停止准则有Wolfe准则（Nocedal and Wright, 1999）：</p>
<script type="math/tex; mode=display">\overset {actual function} { f(\rm \textbf x^{(k)}) }
\leq\overset {linear \space prediction\space of \space function} { f(\rm \textbf x^{(k)} + c_1\alpha\Delta \rm \textbf x^{(k)T} \nabla f(\rm \textbf x^{(k)}) }
\tag{3.12}</script><p>其中，$0&lt;c_1&lt;1$，函数在$\rm \textbf x^{(k)} + c_1\alpha \rm \textbf x{(k)}$的预测要大于实际值，否则步长会超过线性近似的有效范围。用户设置一个初始步长值，如果步长满足上述条件，则会计算一个新的梯度并重新搜索；如果步长不满足上述条件，原始步长减半并重新测试是否满足Wolfe准则。<br>有时较小的步长会很容易满足上述准则，进而导致搜索效率低。为了避免过小的步长，我们也需要通过曲率条件来找到一个更合适的步长：</p>
<script type="math/tex; mode=display">
\overset {slope \space at \space new \space pt.}
{   { \Delta \rm \textbf x^{(k)} } \nabla f(\rm \textbf x^{(k)}+\alpha {\rm \textbf x^{(k)})}   }
\geq
\overset {scaled \space slope \space at \space starting \space pt.}
{   c_2\Delta {\rm \textbf x^{(k)}} \nabla f(\rm \textbf x^{(k)})   }
\tag{3.13}</script><p>其中，$0&lt;c_1&lt;c_2&lt;1$。在这一准则中，沿着$\rm \textbf x{(k)}$处的搜索方向的放缩后的斜率要小于或者等于$\rm \textbf x^{(k)}+\alpha\rm \textbf x^{(k)}$处的该值。这样就可以避免步长较小，因为$\rm \textbf x^{(k)}+\alpha\rm \textbf x^{(k)}$处的斜率可能等于起始点$\rm \textbf x{(k)}$处的值。</p>
<h3 id="3-2-3-数值线搜索法"><a href="#3-2-3-数值线搜索法" class="headerlink" title="3.2.3 数值线搜索法"></a>3.2.3 数值线搜索法</h3><p>当高度非线性的损失函数会打破局部二次假设，这时确切线搜索方法就不再准确了。取而代之可以在下坡方向的多个点上计算损失函数来估计步长。例如。二次线搜索首先定义搜索方向$\Delta \rm \textbf x$，然后计算多个可能步长，例如$\alpha_1=0.5$和$\alpha_2=1$，然后计算两个目标泛函$f(\rm \textbf x+\alpha_1\Delta \rm \textbf x)$和$f(\rm \textbf x + \alpha_2 \Delta \rm \textbf x)$，看他们是否小于$f(\rm \textbf x)$。然后通过下述公式来对泛函进行插值：</p>
<script type="math/tex; mode=display">
\begin{align}
\notag f(\rm \textbf x+\alpha\Delta \rm \textbf x) & = 
\frac{(\alpha-\alpha_1) (\alpha-\alpha_2)}{\alpha_1\alpha_2} f(\rm \textbf x) \\
\notag & + \frac{\alpha(\alpha-\alpha_2)}{\alpha_1(\alpha_1-\alpha_2)} f(\rm \textbf x+\Delta \alpha_1 \Delta \rm \textbf x) \\
\notag & + \frac{\alpha(\alpha-\alpha_1)}{\alpha_2(\alpha_2-\alpha_1)} f(\rm \textbf x+\Delta \alpha_2 \Delta \rm \textbf x) 0\leq\alpha \leq \alpha_2.
\end{align}
\tag{3.14}</script><p>上述函数是一个关于$\alpha$的二次多项式。上述函数最小时$\alpha$的值可以通过求$f(\alpha)$对$\alpha$的导数并令其为零，然后求解$\alpha$。<br>方程3.14需要求目标函数$f(\rm \textbf x)$在三处的值，所以另一种方法是利用$f(\rm \textbf x), f(\rm \textbf x + \alpha_1 \Delta \rm \textbf x)$以及$f(\rm \textbf x)$在$\rm \textbf x$的方向导数进行二次插值：</p>
<script type="math/tex; mode=display">f({\rm \textbf x} +  \Delta {\rm \textbf x})
= \frac{\alpha^2}{\alpha_1^2}[f({\rm \textbf x} +  \Delta {\rm \textbf x}) - \alpha_1 f ({\rm \textbf x})'-f({\rm \textbf x})] + \alpha f({\rm \textbf x})'+f (\rm \textbf x)
\tag{3.15}</script><p>其中，$f(\rm \textbf x)’=\frac{df(\rm \textbf x+\alpha\Delta \rm \textbf x)}{d\alpha}$表示$f(\rm \textbf x)$研制搜索方向的导数。</p>
<h2 id="3-3-最速下降法和线性方程系统"><a href="#3-3-最速下降法和线性方程系统" class="headerlink" title="3.3 最速下降法和线性方程系统"></a>3.3 最速下降法和线性方程系统</h2><p>正定矩阵${\rm \textbf L}$构成的$N \times N$线性方程系统${\rm \textbf {Lx}}={\rm \textbf t}$，其有解且能够最小化二次函数（线性方程组的求解问题可转化为求以下函数最小值问题）</p>
<script type="math/tex; mode=display">f({\rm \textbf x})=
-{\rm \textbf t}^T{\rm \textbf x}+\frac{1}{2}{\rm \textbf x}^T{\rm \textbf {Lx}}
\tag{3.19}</script><p>$f({\rm \textbf x})$的梯度为$({\rm \textbf {Lx}}-{\rm \textbf t})$，$Hessian$为$\rm \textbf L$，所以最速下降公式变为：</p>
<script type="math/tex; mode=display">
\begin{align}
\notag \rm \textbf x^{(k+1)} & =\rm \textbf x^{(k)}-\alpha ({\rm \textbf {Lx}}^{(k)}-{\rm \textbf t}) \\
&= {\rm \textbf x}^{(k)}-\alpha {\rm \textbf r}^{(k)}
\end{align}
\tag{3.20}</script><p>其中，残差矢量为${\rm \textbf r}^{(k)}= {\rm \textbf {Lx}}^{(k)}-{\rm \textbf t}$。</p>
<p>$M \times N$超定线性方程组${\rm \textbf {Lx}}={\rm \textbf t}(M&gt;N)$也能够利用最速下降法最小化目标函数求解：</p>
<script type="math/tex; mode=display">
\begin{align}
\notag f({\rm \textbf x}) &= \frac{1}{2} ({\rm \textbf {Lx}}-{\rm \textbf t}) ^T ({\rm \textbf {Lx}}-{\rm \textbf t}) \\
&=\frac{1}{2} {\rm \textbf t}^T {\rm \textbf t} -{\rm \textbf t}^T {\rm \textbf {Lx}} + \frac{1}{2}{\rm \textbf x}^T{\rm \textbf L}^T{\rm \textbf {Lx}}
\end{align}
\tag{3.21}</script><p>对未知数$\rm \textbf x$求导可得$f(\rm \textbf x)$的梯度为</p>
<script type="math/tex; mode=display">\nabla f (\rm\textbf x)={\rm\textbf L}^T{\rm\textbf {Lx}}-{\rm\textbf L}^T{\rm\textbf t}
\tag{3.22}</script><p>此时最速下降法的解为：</p>
<script type="math/tex; mode=display">
\begin{align}
\notag \rm \textbf x^{(k+1)} & =\rm \textbf x^{(k)}-\alpha {\rm \textbf L}^T ({\rm \textbf {Lx}}^{(k)}-{\rm \textbf t}) \\
&= {\rm \textbf x}^{(k)}-\alpha {\rm \textbf L}^T {\rm \textbf r}^{(k)}
\end{align}
\tag{3.23}</script><p>其中${\rm \textbf r}^{(k)}= {\rm \textbf {Lx}}^{(k)}-{\rm \textbf t}$为第k次迭代的残差。通过对比3.23和3.20可以发现，与方阵$\rm \textbf L$相比，残差项前多了一个$\rm \textbf L$的转置项。如果$\rm \textbf L$的特征值为$\sigma _i$那么，${\rm \textbf L}^T{\rm \textbf L}$的特征值为$\sigma _i^2$。所以一般方程要比方阵更病态。后面层析和偏移章节中会提到，这个转置矩阵相当于层析中的反传旅行时残差和最小二乘偏移中的反传地震道。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Seismic Inversion</category>
      </categories>
      <tags>
        <tag>最速下降法</tag>
      </tags>
  </entry>
</search>
