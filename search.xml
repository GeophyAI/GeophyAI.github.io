<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Wave physics as an analog recurrent neural network</title>
    <url>/2021/04/23/10.1126sciadv.aay6946/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1>Wave physics as an analog recurrent neural network</h1>
<p>原文地址：<a href="https://advances.sciencemag.org/content/5/12/eaay6946.abstract" target="_blank" rel="noopener">模拟递归神经网络的波动物理</a><br>
doi: <a href="http://sci-hub.ren/10.1126/sciadv.aay6946" target="_blank" rel="noopener">10.1126/sciadv.aay6946</a><br>
翻译时间：2021年4月23日</p>
<h2 id="ABSTRACTS">ABSTRACTS</h2>
<p>模拟机器学习硬件平台有望比数字平台更快、更节能。声学和光学中的波物理，是为时变信号构建模拟处理器最自然的选择。本文明确了波动物理与RNN（Recurrent neural networks，循环神经网络）之间的映射。这种映射表明，利用标准的神经网络训练技术，可以使物理波动系统学习到时序数据中的复杂特征。例如，我们证明了，当原始音频信号在逆向设计的非均匀介质中散射和传播时，能够实现元音分类（vowel classification），且其性能与RNN的“数字化实现”相当。这些发现为一类新的模拟机器学习平台提供了可能，该平台能够快速有效地对数据在其原有域进行处理（即不通过将问题转化网络训练的方式）。</p>
<h2 id="INTRODUCTION">INTRODUCTION</h2>
<p>近年来，机器学习在执行复杂的信息处理任务方面取得了巨大的成功，例如计算机视觉（CV)<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="O. Russakovsky, J. Deng, H. Su, J. Krause, S. Satheesh, S. Ma, Z. Huang, A. Karpathy, A. Khosla, M. Bernstein, A. C. Berg, L. Fei-Fei, Imagenet large scale visual recognition challenge. Int. J. Comput. Vis. 115, 211–252 (2015).
">[1]</span></a></sup>、机器翻译<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="I. Sutskever, O. Vinyals, Q. V. Le, Sequence to sequence learning with neural networks, in Advances in Neural Information Processing Systems, NIPS Proceedings, Montreal, CA, 2014.
">[2]</span></a></sup>等传统上难以处理的领域。然而，<br>
这些应用的计算需求正呈指数级增长，促使人们不断开发新的、专门的硬件平台，以便快速高效地执行机器学习模型，其中包括从架构上模仿大脑生物电路的神经形态硬件平台<sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="J. M. Shainline, S. M. Buckley, R. P. Mirin, S. W. Nam, Superconducting optoelectronic circuits for neuromorphic computing. Phys. Rev. Appl. 7, 034013 (2017).
">[3]</span></a></sup><sup id="fnref:4"><a href="#fn:4" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="A. N. Tait, T. F. D. Lima, E. Zhou, A. X. Wu, M. A. Nahmias, B. J. Shastri, P. R. Prucnal, Neuromorphic photonic networks using silicon photonic weight banks. Sci. Rep. 7, 7430 (2017).
">[4]</span></a></sup><sup id="fnref:5"><a href="#fn:5" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="M. Romera, P. Talatchian, S. Tsunegi, F. Abreu Araujo, V. Cros, P. Bortolotti, J. Trastoy, K. Yakushiji, A. Fukushima, H. Kubota, S. Yuasa, M. Ernoult, D. Vodenicarevic, T. Hirtzlin, N. Locatelli, D. Querlioz, J. Grollier, Vowel recognition with four coupled spin-torque nano-oscillators. Nature 563, 230–234 (2018).
">[5]</span></a></sup>等。此外，使用连续物理系统自然演化来执行计算的模拟计算平台也正在成为实现机器学习的一个重要方向<sup id="fnref:6"><a href="#fn:6" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Y. Shen, N. C. Harris, S. Skirlo, M. Prabhu, T. Baehr-Jones, M. Hochberg, X. Sun, S. Zhao, H. Larochelle, D. Englund, M. Soljačić, Deep learning with coherent nanophotonic circuits. Nat. Photonics 11, 441–446 (2017).
">[6]</span></a></sup><sup id="fnref:7"><a href="#fn:7" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="J. Biamonte, P. Wittek, N. Pancotti, P. Rebentrost, N. Wiebe, S. Lloyd, Quantum machine learning. Nature 549, 195–202 (2017).
">[7]</span></a></sup><sup id="fnref:8"><a href="#fn:8" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="F. Laporte, A. Katumba, J. Dambre, P. Bienstman, Numerical demonstration of neuromorphic computing with photonic crystal cavities. Opt. Express 26,7955–7964 (2018).
">[8]</span></a></sup><sup id="fnref:9"><a href="#fn:9" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="X. Lin, Y. Rivenson, N. T. Yardimci, M. Veli, Y. Luo, M. Jarrahi, A. Ozcan, All-optical machine learning using diffractive deep neural networks. Science 361, 1004–1008 (2018).
">[9]</span></a></sup><sup id="fnref:10"><a href="#fn:10" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="E. Khoram, A. Chen, D. Liu, L. Ying, Q. Wang, M. Yuan, Z. Yu, Nanophotonic media for artificial neural inference. Photon. Res. 7, 823–827 (2019).
">[10]</span></a></sup>。本项工作中，我们发现了诸如声波、光学等波动物理现象与RNN计算之间的映射关系。RNN是最重要的机器学习模型之一，其已被广泛用于执行自然语言处理<sup id="fnref:11"><a href="#fn:11" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="K. Yao, G. Zweig, M.-Y. Hwang, Y. Shi, D. Yu, Recurrent neural networks for language understanding (Interspeech, 2013), pp. 2524–2528; https://www.microsoft.com/en-us/ research/publication/recurrent-neural-networks-for-language-understanding/.
">[11]</span></a></sup>和时间序列预测<sup id="fnref:12"><a href="#fn:12" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="M. Hüsken, P. Stagge, Recurrent neural networks for time series classification. Neurocomputing 50, 223–235 (2003).
">[12]</span></a></sup><sup id="fnref:13"><a href="#fn:13" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="G. Dorffner, Neural networks for time series processing. Neural Net. World 6, 447–468 (1996).
">[13]</span></a></sup><sup id="fnref:14"><a href="#fn:14" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="J. T. Connor, R. D. Martin, L. E. Atlas, Recurrent neural networks and robust time series prediction. IEEE Trans. Neural Netw. 5, 240–254 (1994).
">[14]</span></a></sup>等任务。我们证明了基于波的物理系统可以训练成RNN，因此，可以被动地处理数据原有域的信号和信息，而无需进行模数转换，从而有效提升处理效率并降低功耗。在这个框架中，与有意将信号反馈给输入不同的是，递归关系自然地发生在物理本身的时间动力学中，用于信息处理的内存和容量由在空间中传播的波提供。</p>
<h2 id="RESULTS">RESULTS</h2>
<h3 id="波动力学与RNN之间的等效性">波动力学与RNN之间的等效性</h3>
<p>本节中，我们介绍RNN运算与波动力学之间的关系。RNN通过对输入序列逐步应用相同的基本运算来得到输出序列，先前时刻的信息则被编码到RNN的隐藏状态中并在每个时刻进行更新。隐藏状态允许RNN保存历史信息的记忆，并学习到数据的时间结构以及长程依赖关系<sup id="fnref:15"><a href="#fn:15" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="J. L. Elman, Finding structure in time. Cognit. Sci. 14, 179–211 (1990).">[15]</span></a></sup>。在给定的时刻$\boldsymbol t$，RNN作用于输入矢量$\boldsymbol x_t$以及隐藏状态矢量$\boldsymbol h_{t-1}$，计算得到输出矢量$\boldsymbol y_t$以及更新后的隐藏状态$\boldsymbol h_t$。</p>
<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">O. Russakovsky, J. Deng, H. Su, J. Krause, S. Satheesh, S. Ma, Z. Huang, A. Karpathy, A. Khosla, M. Bernstein, A. C. Berg, L. Fei-Fei, Imagenet large scale visual recognition challenge. Int. J. Comput. Vis. 115, 211–252 (2015).<a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">I. Sutskever, O. Vinyals, Q. V. Le, Sequence to sequence learning with neural networks, in Advances in Neural Information Processing Systems, NIPS Proceedings, Montreal, CA, 2014.<a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">J. M. Shainline, S. M. Buckley, R. P. Mirin, S. W. Nam, Superconducting optoelectronic circuits for neuromorphic computing. Phys. Rev. Appl. 7, 034013 (2017).<a href="#fnref:3" rev="footnote"> ↩</a></span></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">A. N. Tait, T. F. D. Lima, E. Zhou, A. X. Wu, M. A. Nahmias, B. J. Shastri, P. R. Prucnal, Neuromorphic photonic networks using silicon photonic weight banks. Sci. Rep. 7, 7430 (2017).<a href="#fnref:4" rev="footnote"> ↩</a></span></li><li id="fn:5"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">5.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">M. Romera, P. Talatchian, S. Tsunegi, F. Abreu Araujo, V. Cros, P. Bortolotti, J. Trastoy, K. Yakushiji, A. Fukushima, H. Kubota, S. Yuasa, M. Ernoult, D. Vodenicarevic, T. Hirtzlin, N. Locatelli, D. Querlioz, J. Grollier, Vowel recognition with four coupled spin-torque nano-oscillators. Nature 563, 230–234 (2018).<a href="#fnref:5" rev="footnote"> ↩</a></span></li><li id="fn:6"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">6.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">Y. Shen, N. C. Harris, S. Skirlo, M. Prabhu, T. Baehr-Jones, M. Hochberg, X. Sun, S. Zhao, H. Larochelle, D. Englund, M. Soljačić, Deep learning with coherent nanophotonic circuits. Nat. Photonics 11, 441–446 (2017).<a href="#fnref:6" rev="footnote"> ↩</a></span></li><li id="fn:7"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">7.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">J. Biamonte, P. Wittek, N. Pancotti, P. Rebentrost, N. Wiebe, S. Lloyd, Quantum machine learning. Nature 549, 195–202 (2017).<a href="#fnref:7" rev="footnote"> ↩</a></span></li><li id="fn:8"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">8.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">F. Laporte, A. Katumba, J. Dambre, P. Bienstman, Numerical demonstration of neuromorphic computing with photonic crystal cavities. Opt. Express 26,7955–7964 (2018).<a href="#fnref:8" rev="footnote"> ↩</a></span></li><li id="fn:9"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">9.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">X. Lin, Y. Rivenson, N. T. Yardimci, M. Veli, Y. Luo, M. Jarrahi, A. Ozcan, All-optical machine learning using diffractive deep neural networks. Science 361, 1004–1008 (2018).<a href="#fnref:9" rev="footnote"> ↩</a></span></li><li id="fn:10"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">10.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">E. Khoram, A. Chen, D. Liu, L. Ying, Q. Wang, M. Yuan, Z. Yu, Nanophotonic media for artificial neural inference. Photon. Res. 7, 823–827 (2019).<a href="#fnref:10" rev="footnote"> ↩</a></span></li><li id="fn:11"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">11.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">K. Yao, G. Zweig, M.-Y. Hwang, Y. Shi, D. Yu, Recurrent neural networks for language understanding (Interspeech, 2013), pp. 2524–2528; https://www.microsoft.com/en-us/ research/publication/recurrent-neural-networks-for-language-understanding/.<a href="#fnref:11" rev="footnote"> ↩</a></span></li><li id="fn:12"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">12.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">M. Hüsken, P. Stagge, Recurrent neural networks for time series classification. Neurocomputing 50, 223–235 (2003).<a href="#fnref:12" rev="footnote"> ↩</a></span></li><li id="fn:13"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">13.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">G. Dorffner, Neural networks for time series processing. Neural Net. World 6, 447–468 (1996).<a href="#fnref:13" rev="footnote"> ↩</a></span></li><li id="fn:14"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">14.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">J. T. Connor, R. D. Martin, L. E. Atlas, Recurrent neural networks and robust time series prediction. IEEE Trans. Neural Netw. 5, 240–254 (1994).<a href="#fnref:14" rev="footnote"> ↩</a></span></li><li id="fn:15"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">15.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">J. L. Elman, Finding structure in time. Cognit. Sci. 14, 179–211 (1990).<a href="#fnref:15" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>文献翻译</category>
      </categories>
      <tags>
        <tag>深度学习与计算地球物理</tag>
      </tags>
  </entry>
  <entry>
    <title>Dell工作站CentOS-7装机</title>
    <url>/2020/06/07/installation/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1>工作站CentOS7装机</h1>
<h2 id="简介">简介</h2>
<p>本次装机的工作站型号为<strong>Dell Precision T3630</strong>，搭载有<strong>Intel®Xoen@E2286G</strong>处理器（6核心/12线程，4.00GHz），512G固态硬盘、1T机械硬盘以及<strong>RTX2080Ti</strong>显卡一张（单涡轮）。文章将分为以下几部分介绍：</p>
<a id="more"></a>
<ol>
<li><strong>CentOS7</strong>系统安装；</li>
<li>显卡驱动、<strong>CUDA Toolkit</strong>以及<strong>cuDNN</strong>安装；</li>
<li>深度学习环境配置，诸如常用的框架 <strong>Tensorflow</strong>、<strong>Keras</strong>等；</li>
</ol>
<p><em>本章节主要介绍第一部分内容，其它内容将在其它日志中更新，欢迎关注。需要注意的是除系统iso文件外，其他所有安装包作者均在安装完的系统内部下载的（主机插了网线，下载速度比较快，卧室离路由器太远收不到5GHz的信号，2.5GHz下载实在是太慢了），如果没有有线网络的小伙伴可以考虑将手机接到主机上联网下载，而且这台工作站支持Type-c接口哦。</em></p>
<h2 id="准备工作">准备工作</h2>
<p><em>准备工作</em>：一个6G及以上内存的U盘（用于镜像文件的制作，CentOS7安装文件大小为4.8G），一个U盘启动制作工具以及CentOS-7-x86_64-xxx.iso镜像文件一个。<br>
U盘制作工具使用<a href="https://cn.ultraiso.net/xiazai.html" target="_blank" rel="noopener">UltraISO</a>，镜像文件使用国内的<a href="http://mirrors.aliyun.com/centos/7/isos/x86_64/" target="_blank" rel="noopener">阿里云源</a>下载，作者安装的是DVD版本（<a href="http://mirrors.aliyun.com/centos/7/isos/x86_64/CentOS-7-x86_64-DVD-2003.iso" target="_blank" rel="noopener">CentOS-7-x86_64-DVD-2003.iso</a>），文件大小为4.5G，此安装包内能够满足一般用户的需求，并且在安装过程中可以根据实际需要对packages进行选择。选择此版本的原因是保持与实验室工作站环境的一致性，尽量减少代码移植过程中出现的问题（但人工智能的代码的可移植性是比较差的，其主要与<em>Tensorflow</em>、<em>Keras</em>等框架的版本相关）。</p>
<h2 id="CentOS7-64bit系统安装">CentOS7-64bit系统安装</h2>
<h3 id="U盘启动制作">U盘启动制作</h3>
<ol>
<li>下载并安装UltraISO（<a href="https://cn.ultraiso.net/xiazai.html" target="_blank" rel="noopener">下载地址</a>）；</li>
<li>下载CentosOS-7镜像文件（<a href="http://mirrors.aliyun.com/centos/7/isos/x86_64/" target="_blank" rel="noopener">下载地址</a>），选择DVD版本（<a href="http://mirrors.aliyun.com/centos/7/isos/x86_64/CentOS-7-x86_64-DVD-2003.iso" target="_blank" rel="noopener">CentOS-7-x86_64-DVD-2003.iso</a>）；</li>
<li>备用电脑中插入U盘（制作启动U盘需要将其格式化，所以先要备份好U盘中的原始数据）；</li>
<li>打开UltraISO程序—<strong>继续试用</strong>；<br>
<img src="/2020/06/07/installation/ultraiso_enter.png" alt="UltraISO"></li>
<li>单击左上角<strong>文件</strong>—<strong>打开</strong>；<br>
<img src="/2020/06/07/installation/ultraiso_open.png" alt="UltraISOstart"></li>
<li>选择下载好的iso文件；<br>
<img src="/2020/06/07/installation/ultraiso_select.png" alt="SelectISO"></li>
<li><strong>启动</strong>—<strong>写入硬盘映像</strong><br>
<img src="/2020/06/07/installation/ultraiso_start.png" alt="WriteSelect"></li>
<li>在<strong>硬盘驱动器</strong>一栏选择自己的U盘，其他设置保持默认，然后单击<strong>写入</strong>开始U盘启动制作过程；<br>
<img src="/2020/06/07/installation/ultraiso_write.png" alt="WriteToUdisk"></li>
<li>写入完成后我们可以看到U盘盘符的名字有些奇怪(UltraISO软件问题，使用其他U盘启动制作工具可能会解决该问题)，如果直接用它安装系统会出现错误，这时我们要修改U盘的盘符(U盘处右键—属性)为引号内的内容“ <strong>CENTOS7</strong> ”（必须为大写）；<br>
<img src="/2020/06/07/installation/u_modify.png" alt="ModifyU"></li>
<li>然后进入<em>U盘/EFI/BOOT</em>，在目录中找到grub.cfg文件并打开，将其中所有的 <strong>CentOS\x207\x20x86_64</strong> 替换为 <strong>CENTOS7</strong>（与U盘盘符保持一致），这样启动盘就制作完成了。<br>
<img src="/2020/06/07/installation/grub.png" alt="Grub"></li>
</ol>
<h3 id="系统安装">系统安装</h3>
<p>作者使用的主机没有预装其它系统，准备只安装 <strong>CentOS7</strong> 用于科研。</p>
<ol>
<li>启动主机，在显示器显示 <em><strong>DELL</strong></em> 商标时 按下 <strong>F2</strong> 进入 <strong>BIOS</strong> 设置界面；<br>
<img src="/2020/06/07/installation/f2.jpg" alt="F2"></li>
<li>在 <strong>Settings—General—Boot Squence</strong> 右侧选择 <strong>UEFI</strong> 模式并点击下方的 <strong>Apply</strong> 按钮；<br>
<img src="/2020/06/07/installation/uefi.jpg" alt="BOOT"></li>
<li>在 <strong>Settings—System Configuration—SATA Operation</strong> 右侧选择 <strong>AHCI</strong> （默认为 <strong>RAID ON</strong>）使硬盘处于可发现模式，点击下方的 <strong>Apply</strong> 按钮；<br>
<img src="/2020/06/07/installation/ahci.jpg" alt="AHCI"></li>
<li>按下 <strong>Esc</strong> 保存设置，重启主机并在 <em><strong>DELL</strong></em> 商标界面按下 <strong>F12</strong>进入启动盘选择界面 ，确认 <strong>Boot mode</strong> 是否为 <strong>UEFI</strong> 以及 <strong>Secure Boot</strong> 是否为 <strong>off</strong> 状态，若状态有误则返回 <strong>BIOS</strong> 重新设置；<br>
<img src="/2020/06/07/installation/f10.jpg" alt="SELECTU"></li>
<li>若没有错误，选择 **UEFI BOOT: **下方的U盘并按回车、进入；</li>
<li>在安装界面选择 <strong>Install CentOS7</strong>；<br>
<img src="/2020/06/07/installation/install_centos7.jpg" alt="CENTOS7"></li>
<li><strong>SOFTWARE SELECTION</strong> 选择 <strong>GNOME Desktop</strong>，右侧可自定义需要安装的软件包以及环境；<br>
<img src="/2020/06/07/installation/selection.jpg" alt="SOFTWAVESELECTION"></li>
<li><strong>INSTALLATION DESTINATION</strong>  选择512G的固态硬盘并选择自动分区（在硬盘选择界面下方 <strong>Other Storage Options—Partitioning</strong> 处选择 <strong>Automatically configure partitioning</strong> ）</li>
<li><strong>Begin Installation</strong>；</li>
<li>系统安装过程中需要完成用户信息的设置，等待完成后 <strong>Reboot</strong>进入系统。</li>
</ol>
<h2 id="系统环境配置">系统环境配置</h2>
<p>在 <strong>CentOS</strong> 使用过程中，我们经常需要从网络上下载各种安装包， <strong>yum(CentOS)</strong> 或 <strong>apt-get(Ubuntu)</strong> 是比较常用的方式，但是系统自带的安装源服务器都在国外，下载速度非常慢，因此我们需要使用国内的诸如清华源、豆瓣源、阿里源等加速下载，下面介绍一些简单的下载加速技巧。<br>
（以下操作均需要在 <strong>root</strong> 权限下运行）首先，查看系统是否安装有 <strong>wget</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ wget --version</span><br></pre></td></tr></table></figure>
<p>如果未安装的话首先使用 <strong>yum</strong> 进行安装（）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root]$ yum -y install wget</span><br><span class="line"><span class="comment"># -y 表示安装的自动选择</span></span><br></pre></td></tr></table></figure>
<p>再次查询即可看到 <strong>wget</strong> 的安装位置、版本等信息。<br>
然后备份系统原有的 <strong>yum</strong> 下载源并下载阿里源、生成缓存：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root] cp /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.bak</span><br><span class="line">[root] wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo <span class="comment">#阿里云安装，也可以安装网易等源</span></span><br><span class="line">[root] yum makecache <span class="comment">#生成缓存</span></span><br></pre></td></tr></table></figure>
<p>安装ntfs-3g以挂载ntfs格式的硬盘</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root] wget https://tuxera.com/opensource/ntfs-3g_ntfsprogs-2017.3.23.tgz</span><br><span class="line">[root] tar zxvf ntfs-3g_ntfsprogs-2017.3.23.tgz</span><br><span class="line">[root] ./configure</span><br><span class="line">[root] <span class="built_in">cd</span> ntfs-3g_ntfsprogs-2017.3.23/</span><br><span class="line">[root] make</span><br><span class="line">[root] make install</span><br><span class="line">[root] mount -t ntfs-3g /deb/sda2 /mnt/data/</span><br></pre></td></tr></table></figure>
<p>设置开机自动挂载硬盘</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root] <span class="built_in">cd</span> /etc</span><br><span class="line">[root] cp fstab fstab.bak</span><br><span class="line">[root] vim fstab</span><br><span class="line"><span class="comment">##---file start---##</span></span><br><span class="line">/dev/sda(替换为自己的盘符)         /mnt/data(替换为自己需要挂载的路径)  ntfs-3g  defaults  0 0</span><br><span class="line"><span class="comment">##---file end--##</span></span><br></pre></td></tr></table></figure>
<p>这时就可以畅快地使用 <code>yum -y install</code>畅快地下载各种安装包啦。</p>
]]></content>
      <categories>
        <category>装机</category>
      </categories>
      <tags>
        <tag>CentOS系统安装</tag>
      </tags>
  </entry>
  <entry>
    <title>常用链接</title>
    <url>/2020/08/02/links/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1>常用链接查询</h1>
<ul>
<li>
<h2 id="文献相关">文献相关</h2>
</li>
</ul>
<ol>
<li>
<p><strong>arxiv</strong>文献下载过慢问题：</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[Answer] 文献链接中 https://arxiv.org 换成 http://xxx.itp.ac.cn</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>利用<strong>doi</strong>下载文献：</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[Answer] http://sci-hub.ren/</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>SEG</strong>文献下载：</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[Answer] https://library.seg.org/</span><br><span class="line">[Answer] https://ifc.cup.edu.cn <span class="comment">#CUP-VPN</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>地震勘探领域（中文）：</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[Answer] http://www.geophy.cn/CN/volumn/home.shtml <span class="comment">#地球物理学报</span></span><br><span class="line">[Answer] http://journal08.magtechjournal.com/Jwk_ogp/CN/volumn/home.shtml <span class="comment">#石油地球物理勘探</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>
<h2 id="数据集">数据集</h2>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[Answer] http://academictorrents.com/ <span class="comment">#种子下载，可搭配VUZE</span></span><br><span class="line">[Answer] https://pan.baidu.com/s/<span class="number">1</span>rQWLNmh2RczmNkry9dfDdg <span class="comment"># CelebA  密码:v65m</span></span><br><span class="line">[Answer] https://pan.baidu.com/s/<span class="number">1j</span>_JOdpjF53h_af6GSHha3w <span class="comment"># ffhq 密码:tkp5</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<h2 id="预训练模型">预训练模型</h2>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[Answer] <span class="comment"># inception-v4_weights_tf_dim_ordering_tf_kernels_notop.h5</span></span><br><span class="line">[Answer] <span class="comment"># inception-v4_weights_tf_dim_ordering_tf_kernels.h5</span></span><br><span class="line">[Answer] <span class="comment"># inception_v3_weights_tf_dim_ordering_tf_kernels.h5</span></span><br><span class="line">[Answer] <span class="comment"># vgg19_weights_tf_dim_ordering_tf_kernels_notop.h5</span></span><br><span class="line">[Answer] <span class="comment"># vgg19.npy</span></span><br><span class="line">[Answer] <span class="comment"># vgg16.npy</span></span><br><span class="line">[Answer] <span class="comment"># inception_v3_features.pkl (styleGAN)</span></span><br><span class="line">[Answer] <span class="comment"># karras2019stylegan-ffhq-1024x1024.pkl (styleGAN)</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<h2 id="深度学习框架">深度学习框架</h2>
</li>
</ul>
<ol>
<li>
<p>Oneflow</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">https://www.oneflow.org/ <span class="comment"># official website</span></span><br><span class="line">https://github.com/Oneflow-Inc/oneflow <span class="comment"># codes</span></span><br><span class="line">https://docs.oneflow.org/ <span class="comment"># doc</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Tensorflow</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">https://tensorflow.google.cn/</span><br><span class="line">https://github.com/tensorflow/tensorflow</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Keras</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">https://keras.io/ <span class="comment"># official website</span></span><br><span class="line">https://github.com/keras-team/keras <span class="comment"># codes</span></span><br><span class="line">https://keras.io/zh/ <span class="comment"># doc</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Pytorch</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">https://pytorch.org/ <span class="comment"># official website</span></span><br><span class="line">https://github.com/pytorch/pytorch <span class="comment"># codes</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>
<h2 id="其它">其它</h2>
</li>
</ul>
<ol>
<li>Blog<br>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">https://www.tablesgenerator.com/markdown_tables <span class="comment"># Markdown表格生成器</span></span><br></pre></td></tr></table></figure></li>
<li>天然地震<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">http://seismo-live.org/</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>commons</category>
      </categories>
      <tags>
        <tag>链接</tag>
      </tags>
  </entry>
  <entry>
    <title>OBSpy天然地震II</title>
    <url>/2020/09/03/obspy2/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1>OBSpy教程之获取地震事件</h1>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> obspy <span class="keyword">import</span> UTCDateTime</span><br><span class="line"><span class="keyword">from</span> obspy.geodetics.flinnengdahl <span class="keyword">import</span> FlinnEngdahl</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_events</span><span class="params">(starttime, endtime, minmagnitude)</span>:</span></span><br><span class="line">    <span class="keyword">from</span> obspy.clients.fdsn <span class="keyword">import</span> Client</span><br><span class="line">    c = Client(<span class="string">"IRIS"</span>)</span><br><span class="line">    events = c.get_events(starttime=starttime,</span><br><span class="line">                          endtime=endtime,</span><br><span class="line">                          minmagnitude=minmagnitude)</span><br><span class="line">    <span class="keyword">return</span> events</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_region_and_mag</span><span class="params">(event)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> hasattr(event, <span class="string">"preferred_origin"</span>):</span><br><span class="line">    <span class="comment"># Get the time from the preferred origin, alternatively the first</span></span><br><span class="line">    <span class="comment"># origin.</span></span><br><span class="line">        origin = event.preferred_origin()</span><br><span class="line">        <span class="keyword">if</span> origin <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> event.origins:</span><br><span class="line">                origin = event.origins[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        time = origin.time</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Do the same for the magnitude.</span></span><br><span class="line">        mag = event.preferred_magnitude()</span><br><span class="line">        <span class="keyword">if</span> mag <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> event.magnitudes:</span><br><span class="line">                mag = event.magnitudes[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">if</span> mag <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            mag = <span class="string">""</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">        	<span class="comment"># mag.mag/mag.magnitude_type:获取震级、震级单位类型</span></span><br><span class="line">            mag = <span class="string">"%.1f %s"</span> % (mag.mag, mag.magnitude_type)</span><br><span class="line">		<span class="comment"># 根据经纬度获取地区名</span></span><br><span class="line">        region = FlinnEngdahl().get_region(origin.longitude,</span><br><span class="line">                                           origin.latitude)</span><br><span class="line">        <span class="comment">#or region = event.event_descriptions[0].text</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> region, mag, time</span><br><span class="line"></span><br><span class="line">starttime = UTCDateTime(<span class="string">'2019-08-31T23:59:59.840000Z'</span>)</span><br><span class="line">endtime = UTCDateTime(<span class="string">'2020-08-31T23:59:59.840000Z'</span>)</span><br><span class="line">minmagnitude = <span class="number">6.5</span></span><br><span class="line">events = get_events(starttime, endtime, minmagnitude)</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="built_in">print</span>(events)</span><br><span class="line">31 Event(s) <span class="keyword">in</span> Catalog:</span><br><span class="line">2020-08-30T21:20:29.655000Z |  +0.769,  -29.833 | 6.5 mww</span><br><span class="line">2020-08-21T04:09:52.276000Z |  -6.670, +123.493 | 6.9 mww</span><br><span class="line">...</span><br><span class="line">2019-09-25T23:46:43.029000Z |  -3.460, +128.368 | 6.5 Mww</span><br><span class="line">2019-09-01T15:54:20.411000Z | -20.360, -178.567 | 6.6 mww</span><br><span class="line">To see all events call <span class="string">'print(CatalogObject.__str__(print_all=True))'</span></span><br><span class="line">&gt;&gt;&gt; <span class="keyword">for</span> i <span class="keyword">in</span> range(len(events)):</span><br><span class="line">....region, mag, time = get_region_and_mag(events[i])</span><br><span class="line">....<span class="built_in">print</span>(region, mag, time)</span><br><span class="line">CENTRAL MID-ATLANTIC RIDGE 6.5 mww 2020-08-30T21:20:29.655000Z</span><br><span class="line">BANDA SEA 6.9 mww 2020-08-21T04:09:52.276000Z</span><br><span class="line">SOUTHERN SUMATRA, INDONESIA 6.9 mww 2020-08-18T22:29:24.731000Z</span><br><span class="line">SOUTHERN SUMATRA, INDONESIA 6.8 mww 2020-08-18T22:23:59.478000Z</span><br><span class="line">SAMAR, PHILIPPINES 6.6 mww 2020-08-18T00:03:48.698000Z</span><br><span class="line">ALASKA PENINSULA 7.8 Mww 2020-07-22T06:12:44.593000Z</span><br><span class="line">EASTERN NEW GUINEA REG., P.N.G. 7.0 mww 2020-07-17T02:50:22.162000Z</span><br><span class="line">JAVA SEA 6.7 Mww 2020-07-06T22:54:47.897000Z</span><br><span class="line">NEAR COAST OF OAXACA, MEXICO 7.4 mww 2020-06-23T15:29:04.329000Z</span><br><span class="line">SOUTH OF KERMADEC ISLANDS 7.4 Mww 2020-06-18T12:49:53.747000Z</span><br><span class="line">RYUKYU ISLANDS, JAPAN 6.6 Mww 2020-06-13T15:51:24.069000Z</span><br><span class="line">NORTHERN CHILE 6.8 mww 2020-06-03T07:35:34.844000Z</span><br><span class="line">NEVADA 6.5 Mww 2020-05-15T11:03:27.176000Z</span><br><span class="line">SANTA CRUZ ISLANDS 6.6 mww 2020-05-12T22:41:12.177000Z</span><br><span class="line">BANDA SEA 6.8 Mww 2020-05-06T13:53:56.960000Z</span><br><span class="line">CRETE, GREECE 6.6 mww 2020-05-02T12:51:06.662000Z</span><br><span class="line">BONIN ISLANDS, JAPAN REGION 6.6 Mww 2020-04-18T08:25:37.081000Z</span><br><span class="line">WESTERN IDAHO 6.8 Ml 2020-03-31T23:52:31.094000Z</span><br><span class="line">EAST OF KURIL ISLANDS 7.5 Mww 2020-03-25T02:49:20.896000Z</span><br><span class="line">KURIL ISLANDS 7.0 mww 2020-02-13T10:33:44.492000Z</span><br><span class="line">CUBA REGION 7.7 mww 2020-01-28T19:10:24.963000Z</span><br><span class="line">TURKEY 6.7 Mww 2020-01-24T17:55:13.987000Z</span><br><span class="line">MINDANAO, PHILIPPINES 6.8 mww 2019-12-15T06:11:51.155000Z</span><br><span class="line">NORTHERN MOLUCCA SEA 7.1 Mww 2019-11-14T16:17:40.582000Z</span><br><span class="line">FIJI ISLANDS REGION 6.5 Mww 2019-11-08T10:44:44.876000Z</span><br><span class="line">TONGA ISLANDS 6.6 Mww 2019-11-04T22:43:32.280000Z</span><br><span class="line">MINDANAO, PHILIPPINES 6.5 mww 2019-10-31T01:11:19.122000Z</span><br><span class="line">MINDANAO, PHILIPPINES 6.6 Mww 2019-10-29T01:04:43.863000Z</span><br><span class="line">OFF COAST OF CENTRAL CHILE 6.7 mww 2019-09-29T15:57:53.236000Z</span><br><span class="line">SERAM, INDONESIA 6.5 Mww 2019-09-25T23:46:43.029000Z</span><br><span class="line">FIJI ISLANDS REGION 6.6 mww 2019-09-01T15:54:20.411000Z</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">events.plot()</span><br></pre></td></tr></table></figure>
<p><img src="/2020/09/03/obspy2/events.png" alt="events"></p>
<p>上述代码获取了从starttime到endtime之间一年以内，震级为6.5级以上的地震事件，并将其发生的地理位置、震级和时间（UTC）打印出来。</p>
]]></content>
      <categories>
        <category>obspy</category>
      </categories>
      <tags>
        <tag>天然地震</tag>
      </tags>
  </entry>
  <entry>
    <title>OBSpy天然地震III</title>
    <url>/2020/09/06/obspy3/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1>天然地震</h1>
<h2 id="OBSpy教程之Client">OBSpy教程之Client</h2>
<h3 id="获取不同Client的url">获取不同Client的url</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> obspy.clients.fdsn <span class="keyword">import</span> Client</span><br><span class="line">c=Client(base_url=<span class="string">"IRIS"</span>)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">base_url: Base URL of FDSN web service compatible server</span></span><br><span class="line"><span class="string">(e.g. "http://service.iris.edu") or key string for recognized</span></span><br><span class="line"><span class="string">server (one of 'BGR', 'EMSC', 'ETH', 'GEONET', 'GFZ', 'ICGC',</span></span><br><span class="line"><span class="string">'INGV', 'IPGP', 'IRIS', 'ISC', 'KNMI', 'KOERI', 'LMU', 'NCEDC',</span></span><br><span class="line"><span class="string">'NIEP', 'NOA', 'ODC', 'ORFEUS', 'RASPISHAKE', 'RESIF', 'SCEDC',</span></span><br><span class="line"><span class="string">'TEXNET', 'UIB-NORSAR', 'USGS', 'USP').</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">   The list below get from 'Client(abbr).base_url', where abbr</span></span><br><span class="line"><span class="string">   is the key string of server.</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>Client_abbr</th>
<th>base_url</th>
</tr>
</thead>
<tbody>
<tr>
<td>BGR</td>
<td><a href="http://eida.bgr.de" target="_blank" rel="noopener">http://eida.bgr.de</a></td>
</tr>
<tr>
<td>EMSC</td>
<td><a href="http://www.seismicportal.eu" target="_blank" rel="noopener">http://www.seismicportal.eu</a></td>
</tr>
<tr>
<td>ETH</td>
<td><a href="http://eida.ethz.ch" target="_blank" rel="noopener">http://eida.ethz.ch</a></td>
</tr>
<tr>
<td>GEONET</td>
<td><a href="http://service.geonet.org.nz" target="_blank" rel="noopener">http://service.geonet.org.nz</a></td>
</tr>
<tr>
<td>GFZ</td>
<td><a href="http://geofon.gfz-potsdam.de" target="_blank" rel="noopener">http://geofon.gfz-potsdam.de</a></td>
</tr>
<tr>
<td>ICGC</td>
<td><a href="http://ws.icgc.cat" target="_blank" rel="noopener">http://ws.icgc.cat</a></td>
</tr>
<tr>
<td>INGV</td>
<td><a href="http://webservices.ingv.it" target="_blank" rel="noopener">http://webservices.ingv.it</a></td>
</tr>
<tr>
<td>IPGP</td>
<td><a href="http://ws.ipgp.fr" target="_blank" rel="noopener">http://ws.ipgp.fr</a></td>
</tr>
<tr>
<td>IRIS</td>
<td><a href="http://service.iris.edu" target="_blank" rel="noopener">http://service.iris.edu</a></td>
</tr>
<tr>
<td>ISC</td>
<td><a href="http://isc-mirror.iris.washington.edu" target="_blank" rel="noopener">http://isc-mirror.iris.washington.edu</a></td>
</tr>
<tr>
<td>KNMI</td>
<td><a href="http://rdsa.knmi.nl" target="_blank" rel="noopener">http://rdsa.knmi.nl</a></td>
</tr>
<tr>
<td>KOERI</td>
<td><a href="http://eida.koeri.boun.edu.tr" target="_blank" rel="noopener">http://eida.koeri.boun.edu.tr</a></td>
</tr>
<tr>
<td>LMU</td>
<td><a href="http://erde.geophysik.uni-muenchen.de" target="_blank" rel="noopener">http://erde.geophysik.uni-muenchen.de</a></td>
</tr>
<tr>
<td>NCEDC</td>
<td><a href="http://service.ncedc.org" target="_blank" rel="noopener">http://service.ncedc.org</a></td>
</tr>
<tr>
<td>NIEP</td>
<td><a href="http://eida-sc3.infp.ro" target="_blank" rel="noopener">http://eida-sc3.infp.ro</a></td>
</tr>
<tr>
<td>NOA</td>
<td><a href="http://eida.gein.noa.gr" target="_blank" rel="noopener">http://eida.gein.noa.gr</a></td>
</tr>
<tr>
<td>ODC</td>
<td><a href="http://www.orfeus-eu.org" target="_blank" rel="noopener">http://www.orfeus-eu.org</a></td>
</tr>
<tr>
<td>ORFEUS</td>
<td><a href="http://www.orfeus-eu.org" target="_blank" rel="noopener">http://www.orfeus-eu.org</a></td>
</tr>
<tr>
<td>RASPISHAKE</td>
<td><a href="http://fdsnws.raspberryshakedata.com" target="_blank" rel="noopener">http://fdsnws.raspberryshakedata.com</a></td>
</tr>
<tr>
<td>RESIF</td>
<td><a href="http://ws.resif.fr" target="_blank" rel="noopener">http://ws.resif.fr</a></td>
</tr>
<tr>
<td>SCEDC</td>
<td><a href="http://service.scedc.caltech.edu" target="_blank" rel="noopener">http://service.scedc.caltech.edu</a></td>
</tr>
<tr>
<td>TEXNET</td>
<td><a href="http://rtserve.beg.utexas.edu" target="_blank" rel="noopener">http://rtserve.beg.utexas.edu</a></td>
</tr>
<tr>
<td>UIB-NORSAR</td>
<td><a href="http://eida.geo.uib.no" target="_blank" rel="noopener">http://eida.geo.uib.no</a></td>
</tr>
<tr>
<td>USGS</td>
<td><a href="http://earthquake.usgs.gov" target="_blank" rel="noopener">http://earthquake.usgs.gov</a></td>
</tr>
<tr>
<td>USP</td>
<td><a href="http://sismo.iag.usp.br" target="_blank" rel="noopener">http://sismo.iag.usp.br</a></td>
</tr>
</tbody>
</table>
<h3 id="在地图上显示network中的台站位置">在地图上显示network中的台站位置</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">c = Client(<span class="string">"IRIS"</span>)</span><br><span class="line">cgt = c.get_stations(network=<span class="string">"II"</span>)</span><br><span class="line">cgt.plot()</span><br></pre></td></tr></table></figure>
<p><img src="/2020/09/06/obspy3/IRIS_II.png" alt="cgt"></p>
<h3 id="根据日期获取指定台站数据并按天分割">根据日期获取指定台站数据并按天分割</h3>
<p>当需要下载指定台站、指定日期范围内的地震数据时，可以使用以下代码。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> obspy</span><br><span class="line"><span class="keyword">from</span> obspy.clients.fdsn.mass_downloader <span class="keyword">import</span> RectangularDomain, Restrictions, MassDownloader</span><br><span class="line"><span class="keyword">from</span> obspy <span class="keyword">import</span> UTCDateTime</span><br><span class="line"></span><br><span class="line">domain = RectangularDomain(minlatitude=<span class="number">-90</span>,</span><br><span class="line">                           maxlatitude=<span class="number">90</span>,</span><br><span class="line">                           minlongitude=<span class="number">-180</span>, </span><br><span class="line">                           maxlongitude=<span class="number">180</span>)</span><br><span class="line"></span><br><span class="line">restrictions = Restrictions(starttime=UTCDateTime(<span class="number">2020</span>, <span class="number">7</span>, <span class="number">20</span>),</span><br><span class="line">                            endtime=UTCDateTime(<span class="number">2020</span>, <span class="number">7</span>, <span class="number">22</span>), </span><br><span class="line">                            chunklength_in_sec=<span class="number">86400</span>, </span><br><span class="line">                            network=<span class="string">"II"</span>, </span><br><span class="line">                            station=<span class="string">"KDAK"</span>, </span><br><span class="line">                            location=<span class="string">"*"</span>,</span><br><span class="line">                            channel=<span class="string">"*"</span>, </span><br><span class="line">                            reject_channels_with_gaps=<span class="literal">False</span>, </span><br><span class="line">                            minimum_length=<span class="number">0.0</span>, </span><br><span class="line">                            minimum_interstation_distance_in_m=<span class="number">100.0</span>)</span><br><span class="line">mdl = MassDownloader()<span class="comment"># providers=["IRIS"]</span></span><br><span class="line">mdl.download(domain,</span><br><span class="line">             restrictions, </span><br><span class="line">             mseed_storage=<span class="string">"./data/KDAK/waveforms"</span>, </span><br><span class="line">             stationxml_storage=<span class="string">"./data/KDAK/stations"</span>)</span><br></pre></td></tr></table></figure>
<p>以上代码中，下载了从<code>starttime</code>到<code>endtime</code>范围内，网络<code>II</code>、台站<code>KDAK</code>的所有通道数据，并将其截取为每个文件86400s长度（即一天）</p>
]]></content>
      <categories>
        <category>obspy</category>
      </categories>
      <tags>
        <tag>天然地震</tag>
      </tags>
  </entry>
  <entry>
    <title>OBSpy天然地震IV</title>
    <url>/2020/09/08/obspy4/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1>天然地震</h1>
<h2 id="OBSpy教程之获取到时">OBSpy教程之获取到时</h2>
<p>09月08日18时04分在山东青岛市崂山区海域（北纬35.96度，东经120.82度）发生3.0级地震，震源深度13千米。（<a href="http://news.ceic.ac.cn/CD20200908180457.html" target="_blank" rel="noopener">@中国地震台网</a>）<br>
这里我们使用OBSpy获取上海某台站记录的此地震波形。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> obspy</span><br><span class="line"><span class="keyword">from</span> obspy.clients.fdsn <span class="keyword">import</span> Client</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">event_time = obspy.UTCDateTime(<span class="string">"2020-09-08T10:04:44.5"</span>)</span><br><span class="line">inv = c_event.get_stations(network=<span class="string">"IC"</span>,</span><br><span class="line">                           station=<span class="string">"BJT"</span>, <span class="comment">#BeiJing(lat:40.0183,lon:116.1679)</span></span><br><span class="line">                           level=<span class="string">"response"</span>)</span><br><span class="line">inv.extend(c_event.get_stations(network=<span class="string">"IC"</span>,</span><br><span class="line">                                station=<span class="string">"SSE"</span>, <span class="comment">#ShangHai(lat:31.0948,lon:121.1908)</span></span><br><span class="line">                                level=<span class="string">"response"</span>))</span><br><span class="line">client = Client(<span class="string">"IRIS"</span>)</span><br><span class="line">st = client.get_waveforms(network=<span class="string">"IC"</span>, </span><br><span class="line">                          station=<span class="string">"*"</span>,</span><br><span class="line">                          location=<span class="string">"*"</span>, </span><br><span class="line">                          channel=<span class="string">"BH*"</span>, </span><br><span class="line">                          starttime=event_time - <span class="number">10</span> * <span class="number">60</span>, </span><br><span class="line">                          endtime=event_time + <span class="number">10</span> * <span class="number">60</span>)</span><br><span class="line">st.write(<span class="string">'./QingDaoEvent20200908/QDshock.mseed'</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/2020/09/08/obspy4/stations.png" alt="stations.png"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">25 Trace(s) <span class="keyword">in</span> Stream:</span><br><span class="line"></span><br><span class="line">IC.BJT.00.BH1 | 2020-09-08T09:54:44.519539Z - 2020-09-08T10:14:44.469539Z | 20.0 Hz, 24000 samples</span><br><span class="line">...</span><br><span class="line">(23 other traces)</span><br><span class="line">...</span><br><span class="line">IC.QIZ.00.BHZ | 2020-09-08T09:54:44.519538Z - 2020-09-08T10:14:44.469538Z | 20.0 Hz, 24000 samples</span><br><span class="line"></span><br><span class="line">[Use <span class="string">"print(Stream.__str__(extended=True))"</span> to <span class="built_in">print</span> all Traces]</span><br></pre></td></tr></table></figure>
<p>台网：<a href="https://www.fdsn.org/networks/detail/IC/" target="_blank" rel="noopener">IC</a>，共获取了25道记录，以位于北京白家疃的BJT台站数据为例，计算地震波到达此站的UTC时并将P波到时绘制在图上。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> obspy.taup <span class="keyword">import</span> TauPyModel</span><br><span class="line"><span class="keyword">from</span> obspy.geodetics <span class="keyword">import</span> locations2degrees</span><br><span class="line">m = TauPyModel(model=<span class="string">"ak135"</span>, verbose=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">st = st.select(station=<span class="string">"BJT"</span>)</span><br><span class="line">Trace = <span class="number">0</span></span><br><span class="line">qd_event_latitude = <span class="number">35.96</span></span><br><span class="line">qd_event_longitude = <span class="number">120.82</span></span><br><span class="line">qd_event_depth = <span class="number">13</span> <span class="comment">#km</span></span><br><span class="line"><span class="comment">#coords = inv.get_coordinates(st[0].get_id())</span></span><br><span class="line"><span class="comment"># coords = &#123;"longitude":121.445,</span></span><br><span class="line"><span class="comment">#           "latitude": 31.213&#125;</span></span><br><span class="line">coords = &#123;<span class="string">"longitude"</span>:<span class="number">116.1679</span>,</span><br><span class="line">          <span class="string">"latitude"</span>: <span class="number">40.0183</span>&#125;</span><br><span class="line">distance = locations2degrees(qd_event_latitude, </span><br><span class="line">                             qd_event_longitude,</span><br><span class="line">                             coords[<span class="string">"latitude"</span>],</span><br><span class="line">                             coords[<span class="string">"longitude"</span>])</span><br><span class="line">arrivals = m.get_ray_paths(distance_in_degree=distance,</span><br><span class="line">                           source_depth_in_km=qd_event_depth)</span><br><span class="line">first_arrival = event_time + arrivals[<span class="number">0</span>].time</span><br><span class="line">delta = first_arrival - st[Trace].stats.starttime</span><br><span class="line">time = np.arange(<span class="number">0</span>, st[Trace].stats.npts/ st[Trace].stats.sampling_rate, st[Trace].stats.delta)</span><br><span class="line">fig, axes = plt.subplots(nrows = <span class="number">1</span>, ncols = <span class="number">1</span> , figsize = (<span class="number">16</span>,<span class="number">4</span>))</span><br><span class="line">axes.plot(time, st[Trace].data, color = <span class="string">'black'</span>)</span><br><span class="line">axes.axvline(delta, color = <span class="string">'red'</span>)</span><br><span class="line">axes.set_xlabel(<span class="string">"Time [s]"</span>+st[Trace].stats.channel)</span><br></pre></td></tr></table></figure>
<p><img src="/2020/09/08/obspy4/traveltime.png" alt="traveltime"></p>
]]></content>
      <categories>
        <category>obspy</category>
      </categories>
      <tags>
        <tag>天然地震</tag>
      </tags>
  </entry>
  <entry>
    <title>OBSpy installation Q&amp;A</title>
    <url>/2020/09/05/obspy_install/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1>Q&amp;A of installation of obspy</h1>
<h2 id="Q-ImportError-Neither-Basemap-nor-Cartopy-could-be-imported">Q: ImportError: Neither Basemap nor Cartopy could be imported.</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[user]$ conda install basemap</span><br></pre></td></tr></table></figure>
<h2 id="Q-ImportError-cannot-import-name-‘is-scalar’">Q: ImportError: cannot import name ‘is scalar’</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[user]$ pip install matplotlib==<span class="number">3.0</span><span class="number">.0</span></span><br></pre></td></tr></table></figure>
<h2 id="Q-AttributeError-‘Axes’-object-has-no-attribute-‘get-axis-bgcolor’">Q: AttributeError: ‘Axes’ object has no attribute ‘get axis bgcolor’</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[user]$ vim ~/.conda/envs/seismic/lib/python3<span class="number">.6</span>/site-packages/mpl_toolkits/basemap/__init__.py</span><br><span class="line"><span class="comment"># Change the directory of you own basemap installaion dir.</span></span><br><span class="line">[user]$ <span class="comment"># replace all 'get_axis_bgcolor' with 'get_facecolor()' in file __init__.py</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>obspy</category>
      </categories>
      <tags>
        <tag>天然地震</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux中论文写作环境搭建</title>
    <url>/2020/07/02/paper_env/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1>文字编辑器</h1>
<p>使用 <a href="https://linux.wps.cn/" target="_blank" rel="noopener">WPS for linux</a>，安装包格式为rpm，安装过程如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[usrname]$ rpm -ivh wps-office-11.1.0.9522-1.x86_64.rpm</span><br><span class="line"><span class="comment">#安装完成后可能会缺少相关字体，例如中文论文常用的宋体、黑体等，可以从windows中拷贝到linux下，将ttf字体文件复制到/usr/share/fonts/wps-office文件夹中，重启wps即可看到中文字体</span></span><br><span class="line">[usrname]$ wps <span class="comment"># 安装包中包含PDF、Presentation、Spreadsheets和Writter</span></span><br></pre></td></tr></table></figure>
<p>常用部分中文 <strong>ttf</strong> 格式字体<a href="https://pan.baidu.com/s/19eR8GaxYuE6ISLGdVGWUDg" target="_blank" rel="noopener">百度网盘(提取码:s7lq)</a>。</p>
<h1>公式编辑器</h1>
<p>使用 <strong><a href="https://www.xm1math.net/texmaker/download.html" target="_blank" rel="noopener">texmaker</a></strong>，实际上完全可以使用 <strong>texmaker</strong> 完成整个论文撰写工作。（<code>#texmaker 的下载要注意与qt版本相对应</code>）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[usrname]$ tar -jxvf texmaker-5.0.3.tar.bz2</span><br><span class="line">[usrname]$ <span class="built_in">cd</span> texmaker-5.0.3/</span><br><span class="line">[usrname]$ qmake texmaker.pro</span><br><span class="line">[usrname]$ make &amp;&amp; make install</span><br><span class="line">[usrname]$ texmaker</span><br></pre></td></tr></table></figure>
<h1>安装32位wine</h1>
<p>在研究 <strong>LaTex</strong> 搭配 <strong>python</strong> 中的 <code>pandoc</code>实现 <code>tex2word</code> 无果后（经由<code>pandoc</code>转换出的word文件会丢失部分 <strong>tex</strong> 中设置好的格式，可能是<code>\usepackage</code>导致的；但如果只需要由 <strong>tex</strong> 生成 <strong>pdf</strong>文件，LaTex还是值得深入学习一下的），退而求其次，本来想通过wine安装 <strong>MS office</strong>，但转念一想不如装个 <strong>MathTpye</strong> 来的方便，结果也没好装到哪去。。。</p>
<p>为了使用32位MathType，首先安装32位wine，小编安装的是<a href="https://dl.winehq.org/wine/source/5.0/wine-5.0.1.tar.xz" target="_blank" rel="noopener">5.0.1版本源码</a>，由于主机环境为x86_64，所以我们需要为系统安装32位依赖环境，否则无法执行 <strong>./configure</strong> ：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root]$ yum install glibc-devel.i686 dbus-devel.i686 freetype-devel.i686 pulseaudio-libs-devel.i686 </span><br><span class="line"> libX11-devel.i686 mesa-libGLU-devel.i686 libICE-devel.i686 libXext-devel.i686 libXcursor-devel.i686 </span><br><span class="line"> libXi-devel.i686 libXxf86vm-devel.i686 libXrender-devel.i686 libXinerama-devel.i686 libXcomposite-devel.i686 </span><br><span class="line"> libXrandr-devel.i686 mesa-libGL-devel.i686 mesa-libOSMesa-devel.i686 libxml2-devel.i686 libxslt-devel.i686 </span><br><span class="line"> zlib-devel.i686 gnutls-devel.i686 ncurses-devel.i686 sane-backends-devel.i686 libv4l-devel.i686 </span><br><span class="line"> libgphoto2-devel.i686 libexif-devel.i686 lcms2-devel.i686 gettext-devel.i686 isdn4k-utils-devel.i686 </span><br><span class="line"> cups-devel.i686 fontconfig-devel.i686 gsm-devel.i686 libjpeg-turbo-devel.i686 pkgconfig.i686  </span><br><span class="line"> libtiff-devel.i686 unixODBC.i686 openldap-devel.i686 alsa-lib-devel.i686 audiofile-devel.i686 </span><br><span class="line"> freeglut-devel.i686 giflib-devel.i686 gstreamer-devel.i686 gstreamer-plugins-base-devel.i686 libXmu-devel.i686 </span><br><span class="line"> libXxf86dga-devel.i686 libieee1284-devel.i686 libpng-devel.i686 librsvg2-devel.i686 </span><br><span class="line"> libstdc++-devel.i686 libusb-devel.i686 unixODBC-devel.i686 qt-devel.i686</span><br><span class="line">[root]$ yum install libXext.i686</span><br><span class="line">[root]$ yum install libXext.x86_64</span><br><span class="line">[root]$ yum install ia32-libs.i686</span><br><span class="line">[root]$ yum install xulrunner.i686</span><br><span class="line">[root]$ yum install libX11-devel freetype-devel zlib-devel libxcb-devel</span><br><span class="line">[root]$ tar -xvf wine-5.0.1.tar.xz</span><br><span class="line">[root]$ <span class="built_in">cd</span> wine-5.0.1</span><br><span class="line">[root]$ ./configure</span><br><span class="line">[root]$ make <span class="comment">#make耗费时间比较长，耐心等待即可</span></span><br><span class="line">[root]$ make install</span><br><span class="line">[root]$ wine --version <span class="comment">#查看32位wine版本</span></span><br></pre></td></tr></table></figure>
<p>然后执行<code>winecfg</code>，如果系统默认语言为 <strong>en</strong>，此时看到的 <strong>wine</strong> 配置界面应同样为英文，若系统已经安装了中文字体，例如 <strong>simsun.ttf</strong> 等，在 <strong>terminal</strong> 执行<code>export LANG=zh_CN.utf8</code> 即可将语言临时调整为中文。</p>
<h1>中文版MathType安装及语言配置</h1>
<p>下载好 <strong>Mathtype</strong> 之后，打开系统（屏幕左上角）的<code>Applications &gt; Wine &gt; Wine Software uninstaller </code>，点击其中的<code>install</code>并选择安装包即可完成安装。可以通过<code>Applications &gt; Wine &gt; MathType</code>打开公式编辑器。</p>
<p>如果字体出现乱码等情况，首先要考虑是否系统环境与wine环境不一致所导致，详情请参考：<a href="http://linux-wiki.cn/wiki/zh-hans/wine%E7%9A%84%E4%B8%AD%E6%96%87%E6%98%BE%E7%A4%BA%E4%B8%8E%E5%AD%97%E4%BD%93%E8%AE%BE%E7%BD%AE" target="_blank" rel="noopener">这位热心网友的解答</a>。</p>
<p>小编在修改完<code>~/.wine/system.reg</code>以及<code>~/.wine//drive_c/windows/win.ini</code>（root用户和普通用户根目录下都含有此文件，均做修改并不能解决字体部分乱码问题，怀疑是系统语言的限制）后运行 <strong>MathType</strong> 过程中出现部分中文字体为 ？？？的情况，再次运行<code>export LANG=zh_CN.utf8</code>即可显示所有中文字体。（测试发现，如果系统环境为en，需要在每次启动MathType时在terminal中临时切换为中文，即运行上述代码。或者，使用 <code>alias</code> 为软件创建命令行快捷打开方式）。</p>
]]></content>
      <categories>
        <category>paper</category>
      </categories>
      <tags>
        <tag>Linux&amp;Windows--cross</tag>
      </tags>
  </entry>
  <entry>
    <title>pyseis--基于conv的声波正演模拟</title>
    <url>/2020/08/20/pyseis_fdtd_basedonconv/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1>基于神经网络中卷积操作的标量声波方程正演模拟</h1>
<p>编写一个声波方程的正演模拟程序，是入门地震数据处理中数值模拟这一领域的基础，同时也是后续做<strong>RTM</strong>、<strong>FWI</strong>等方向的基础。个人一般用<strong>C</strong>、<strong>C++</strong> 或者<strong>CUDA</strong>编写<strong>CPU(GPU)</strong> 版本的程序，对于初入这一行业的小白来讲门槛比较高，既要掌握语言语法、还要将偏微分方程“变现”（将其离散化并变为计算机语言），并且后续代码的移植也非常困难；但好处是可操作性强（可以直接对内存、显存进行操作），代码可读性强（不会像python一样过一阵再看自己写的代码就看不懂了）。</p>
<p>所以… … …</p>
<p>之前做过一些尝试，把<strong>C</strong>的正演程序直接改成<strong>python</strong>的语法，但是发现效率极其低下，已经找不到当时的代码了，回忆了一下应该是思维定式（菜）惹的祸：波场计算的时候用<strong>for</strong>循环处理了<strong>numpy</strong>数组（大误），现在想想是真的菜。</p>
<p>下面我们以深度学习中卷积操作的视角重新审视一下基于有限差分的标量声波方程正演模拟。</p>
<h2 id="标量声波方程">标量声波方程</h2>
<p>我们首先来看二维空间中的波动方程，<br>
<img src="/2020/08/20/pyseis_fdtd_basedonconv/scalar_o.gif" alt="img"><br>
左侧是<strong>u</strong>对时间的二阶导数，右侧是<strong>u</strong>对空间的二阶偏导数与源<strong>f</strong>之和，为求解 <strong>t</strong>时刻 <strong>(i, j)</strong> 处的波场分量，首先需要将其离散化。我们一般将二维空间中的拉普拉斯算子用Taylor展开的形式来逼近，用<strong>k</strong>、<strong>k-1</strong>、和<strong>k-2</strong>表示相邻的三个时刻，空间步长<strong>dx=dz=dh</strong>,时间步长为<strong>dt</strong>，介质速度为<strong>Vp</strong>，则有<br>
<img src="/2020/08/20/pyseis_fdtd_basedonconv/scalar.gif" alt="scalar"><br>
我们会发现它实质上是一个迭代的过程，这里给出的公式只能够计算一个时间切片内的波场，在编程计算时，计算完<strong>k</strong>时刻波场后，需要将<strong>k</strong>和<strong>k-1</strong>时刻分别更新为<strong>k-1</strong>和<strong>k-2</strong>时刻，这样就可以计算下一个&quot;k&quot;时刻的波场(对应实际的k+1)。</p>
<h2 id="神经网络中的卷积操作">神经网络中的卷积操作</h2>
<p>神经网络中的二维卷积实质上是卷积核与像素矩阵pixel-wise的互相关、求和，它与一维信号中的卷积还不太一样<br>
<img src="/2020/08/20/pyseis_fdtd_basedonconv/conv.gif" alt="conv"><br>
图片来自(<a href="https://www.jianshu.com/p/1ea2949c0056" target="_blank" rel="noopener">简书</a>)<br>
动图中可以很明显地看出，单层的卷积计算也并不是很复杂，只是拿一个window在已知的输入上滑动，这个window就是神经网络卷积、反卷积中的卷积核kernel，滑动的步长被称为stride，边缘处灰色值被称为padding(用于填充边缘保证输入和输出的大小)，kernel和输入的每一个block相乘相加即可得到输出的一个像素值。</p>
<h2 id="基于卷积op的有限差分">基于卷积op的有限差分</h2>
<p>很久之前就在想有没有办法能够将正演接入神经网络中，利用python中现成的工具包快速完成一些复杂的计算，这要涉及到数据流问题、输入输出转换问题、数据接口问题等等。前一阵利用<strong>pycuda</strong>完成了几个版本的正演模拟(常规网格标量声波和一阶速度应力交错网格弹性波)计算<strong>package</strong>，能够通过简单的输入速度模型(<strong>numpy</strong>)和参数设置生成数据流并怼到神经网络里面，但是<strong>pycuda</strong>的底层代码还是用<strong>CUDA</strong>写的，只是通过它的<strong>SourceMoudle</strong>来编译运行，所以不能直接接到<strong>TF</strong>的<strong>Graph</strong>中，进行更加高级的运算，比如求导等(<strong>package</strong>中有未公开发表的部分，待发表后将源码放出)。</p>
<p>要想利用<strong>TF</strong>等框架的自动微分，就必须要使用<strong>TF</strong>原生的函数或者定义 <code>@tf.function</code>来追踪变量，由此有了以下尝试。</p>
<p>我们观察离散格式的标量声波方程中带有求和符号的一项，可以看到它是每一个点上沿着<strong>x</strong>方向和<strong>z</strong>方向的求和叠加，假设有限差分精度为<strong>2N</strong>，那么求和项中的系数可以通过求解以下方程得到<br>
<img src="/2020/08/20/pyseis_fdtd_basedonconv/coes.gif" alt="coes"></p>
<p>仔细观察即可发现，每个(i,j)处横向或纵向的求和都可以用以该点为中心，长度和宽度均为<strong>2*N+1</strong>的<strong>block</strong>与一个相同大小的卷积核<strong>f</strong>进行卷积来代替，例如当差分精度为<strong>4</strong>时，卷积核的大小应为<strong>5x5</strong>，以(i,j)为中心的求和(dx=dz=dh)可以用如下卷积操作代替(注：第一个矩阵中的省略号不代表值为0，只是其与卷积核相乘后的值为0，当网格不同方向的大小不同时需要区分水平方向卷积核以及垂直方向卷积核)，那么整个卷积就可以写为<code>tf.nn.depthwise_conv2d(input=x, filter=f, strides=[1, 1, 1, 1], padding='SAME')</code><br>
<img src="/2020/08/20/pyseis_fdtd_basedonconv/conv1.gif" alt="conv1"></p>
<p>基本原理如上所述，这样一来，我们就可以利用TF框架来实现正演模拟了(完整的代码请联系shaowinw@geophyai.com，小站流量不多了，暂不提供下载功能)。</p>
]]></content>
      <categories>
        <category>pyseis</category>
      </categories>
      <tags>
        <tag>fdtd</tag>
      </tags>
  </entry>
  <entry>
    <title>pyseis--有限差分系数计算</title>
    <url>/2020/08/16/pyseis_v0.0.1_normal_coes/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1>正演模拟中二阶导数差分系数计算</h1>
<h2 id="整数网格点二阶导数的任意偶数阶精度有限差分系数计算">整数网格点二阶导数的任意偶数阶精度有限差分系数计算</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> numpy.linalg <span class="keyword">import</span> solve</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Normal_Grid_Coefficients</span><span class="params">(N, diff_order = <span class="number">2</span>)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">        Coefficients of arbitrary even order Taylor</span></span><br><span class="line"><span class="string">        expansion when the discrete values are at </span></span><br><span class="line"><span class="string">        integral grid point. Such as for normal grid</span></span><br><span class="line"><span class="string">        second-order acoustic forward modeling.</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        Parameters:</span></span><br><span class="line"><span class="string">        ----------</span></span><br><span class="line"><span class="string">        N : Half-order of Taylor expansion or the</span></span><br><span class="line"><span class="string">            length of unilateral operator.</span></span><br><span class="line"><span class="string">        diff_order : Not used in this method. Just</span></span><br><span class="line"><span class="string">            for notice.</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        Returns:</span></span><br><span class="line"><span class="string">        ----------</span></span><br><span class="line"><span class="string">        out : 1-D ndarray.</span></span><br><span class="line"><span class="string">        The length of output is (2*N+1) with the </span></span><br><span class="line"><span class="string">        first coefficient is C0.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    </span><br><span class="line">    holder = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">        matrix = []</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(N):</span><br><span class="line">            matrix.append(np.power((i+<span class="number">1</span>)**j, <span class="number">2</span>))</span><br><span class="line">        holder.append(matrix)</span><br><span class="line">    holder = np.array(holder).T</span><br><span class="line">    constant = np.zeros(N)</span><br><span class="line">    constant[<span class="number">0</span>] = <span class="number">1.0</span></span><br><span class="line">    x = solve(holder, constant)</span><br><span class="line">    </span><br><span class="line">    t1 = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">        x[i] = x[i]/np.power(i+<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">        t1+=x[i]</span><br><span class="line">    </span><br><span class="line">    coes = np.zeros(N+<span class="number">1</span>)</span><br><span class="line">    coes[<span class="number">0</span>] = <span class="number">-2</span>*t1</span><br><span class="line">    coes[<span class="number">1</span>:len(coes)] = x</span><br><span class="line">    <span class="keyword">return</span> coes</span><br></pre></td></tr></table></figure>
<h2 id="半网格点一阶导数的任意偶数阶精度有限差分系数计算">半网格点一阶导数的任意偶数阶精度有限差分系数计算</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Staggered_Grid_Coefficients</span><span class="params">(N, diff_order = <span class="number">1</span>)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">        Coefficients of arbitrary even order Taylor</span></span><br><span class="line"><span class="string">        expansion when the discrete values are at </span></span><br><span class="line"><span class="string">        half grid point. Such as for staggered grid</span></span><br><span class="line"><span class="string">        first-order velocity-stress elastic forward</span></span><br><span class="line"><span class="string">        modeling.</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        Parameters:</span></span><br><span class="line"><span class="string">        ----------</span></span><br><span class="line"><span class="string">        N : Half-order of Taylor expansion or the</span></span><br><span class="line"><span class="string">            length of unilateral operator.</span></span><br><span class="line"><span class="string">        diff_order : Differential order of discretization,</span></span><br><span class="line"><span class="string">            not used in this method. Just for notice.</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        Returns:</span></span><br><span class="line"><span class="string">        ----------</span></span><br><span class="line"><span class="string">        out : 1-D ndarray.</span></span><br><span class="line"><span class="string">        The length of output is (2*N).</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    </span><br><span class="line">    holder = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">        matrix = []</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(N):</span><br><span class="line">            matrix.append(np.power(<span class="number">2</span>*j+<span class="number">1</span>, <span class="number">2</span> * (i + <span class="number">1</span>) - <span class="number">1</span>))</span><br><span class="line">        holder.append(matrix)</span><br><span class="line">    holder = np.array(holder)</span><br><span class="line">    constant = np.zeros(N)</span><br><span class="line"></span><br><span class="line">    constant[<span class="number">0</span>] = <span class="number">1.0</span><span class="comment">#*f</span></span><br><span class="line">    x = solve(holder, constant)</span><br><span class="line">    </span><br><span class="line">    coes = np.zeros(N)</span><br><span class="line">    coes[<span class="number">0</span>:len(coes)] = x</span><br><span class="line">    <span class="keyword">return</span> coes</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>pyseis</category>
      </categories>
      <tags>
        <tag>差分系数</tag>
      </tags>
  </entry>
  <entry>
    <title>Python之import argparse</title>
    <url>/2020/06/21/python_argparse/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1>Python之命令行解析–argparse</h1>
<p>在 <strong>terminal</strong> 执行 <strong>.py</strong> 文件经常遇到。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">import</span> argparse</span><br><span class="line">$ Aparser = argparse.ArgumentParser(</span><br><span class="line">		    prog=<span class="literal">None</span>, <span class="comment">#给程序起名儿，默认为sys.argv[0]</span></span><br><span class="line">		    usage=<span class="literal">None</span>, <span class="comment">#参数用法备注，默认从参数中自动生成</span></span><br><span class="line">		    description=<span class="literal">None</span>, <span class="comment">#程序目的备注，显示在help之前</span></span><br><span class="line">		    epilog=<span class="literal">None</span>, <span class="comment">#参数描述后跟着的解释，显示在help之后</span></span><br><span class="line">		    parents=[], <span class="comment">#由ArgumentParser对象组成的列表，它们的arguments选项会被包含到新ArgumentParser对象中。(类似于继承)</span></span><br><span class="line">		    formatter_class=&lt;class 'argparse.HelpFormatter'&gt;, #help输出格式</span><br><span class="line">		    prefix_chars=<span class="string">'-'</span>, <span class="comment">#每个参数的前缀，默认为‘- arg’</span></span><br><span class="line">		    fromfile_prefix_chars=<span class="literal">None</span>, <span class="comment">#前缀字符，放置在文件名之前</span></span><br><span class="line">		    argument_default=<span class="literal">None</span>, <span class="comment">#没用到</span></span><br><span class="line">		    conflict_handler=<span class="string">'error'</span>, <span class="comment">#冲突解决，保持默认</span></span><br><span class="line">		    add_help=<span class="literal">True</span>, <span class="comment">#是否增加-h/-help选项 (默认为True)。设为False时，help信息里面不再显示-h –help信息.</span></span><br><span class="line">		    allow_abbrev=<span class="literal">True</span>, <span class="comment">#允许较长的参数名称使用缩写</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>测试代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">##aarparse.py:测试argparse</span></span><br><span class="line"><span class="comment">##aarparse.py:测试argparse</span></span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line">parser = argparse.ArgumentParser(prog = <span class="string">'我叫测试程序'</span>, description=<span class="string">'测试argparse模块'</span>)</span><br><span class="line">parser.add_argument(<span class="string">'--第一个参数'</span>, metavar = <span class="string">'&lt;参数备注&gt;'</span>, default = <span class="number">1996</span>,</span><br><span class="line">                    help=<span class="string">'显示第一个参数的用处'</span>, type = int)</span><br><span class="line">parser.add_argument(<span class="string">'--第二个参数'</span>, metavar = <span class="string">'&lt;参数备注&gt;'</span>,</span><br><span class="line">                    help=<span class="string">'显示第二个参数的用处'</span>, type = int)</span><br><span class="line">parser.add_argument(<span class="string">'--third_parameter'</span>, type = str, default = <span class="string">'input'</span>, help = <span class="string">'what will third_parameter do?'</span>)</span><br><span class="line">parser.add_argument(<span class="string">'--choices'</span>, type = int, default = <span class="number">1</span> , choices =[<span class="string">'1'</span>,<span class="string">'3'</span>,<span class="string">'8'</span>], help = <span class="string">'choose a number from chioces'</span>)</span><br><span class="line">args = parser.parse_args()</span><br><span class="line"><span class="keyword">if</span> args.第一个参数 == <span class="number">2020</span>:</span><br><span class="line">    print(<span class="string">'今年是2020年。'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'今年是'</span> + str(args.第一个参数) + <span class="string">'年。'</span>)</span><br><span class="line">print(<span class="string">'choices = '</span> + str(args.choices))</span><br></pre></td></tr></table></figure>
<p>测试结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ python aarparse.py -h</span><br><span class="line">usage: 我叫测试程序 [-h] [--第一个参数 &lt;参数备注&gt;] [--第二个参数 &lt;参数备注&gt;]</span><br><span class="line">              [--third_parameter THIRD_PARAMETER] [--choices &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">8</span>&#125;]</span><br><span class="line"></span><br><span class="line">测试argparse模块</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line">  -h, --help            show this help message <span class="keyword">and</span> exit</span><br><span class="line">  --第一个参数 &lt;参数备注&gt;        显示第一个参数的用处</span><br><span class="line">  --第二个参数 &lt;参数备注&gt;        显示第二个参数的用处</span><br><span class="line">  --third_parameter THIRD_PARAMETER</span><br><span class="line">                        what will third_parameter do?</span><br><span class="line">  --choices &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">8</span>&#125;     choose a number <span class="keyword">from</span> chioces</span><br><span class="line">$ python aarparse.py</span><br><span class="line">今年是<span class="number">1996</span>年。</span><br><span class="line">choices = <span class="number">1</span></span><br><span class="line">$ python aarparse.py --第一个参数 <span class="number">2020</span> --choices <span class="number">3</span></span><br><span class="line">今年是<span class="number">2020</span>年。</span><br><span class="line">choices = <span class="number">3</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>argparse</tag>
      </tags>
  </entry>
  <entry>
    <title>Python之深copy与浅copy</title>
    <url>/2020/07/13/python_copy/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1>C和Python中简单变量的拷贝问题</h1>
<p>所谓浅拷贝，即变量之间的差异只体现在声明的名称上，他们实质上指向同一块内存地址；而深拷贝则是内存地址完全不相同的两个变量。<br>
在C中(包括C++,CUDA)，两个值相同的变量内存地址是不同的，而在python中则不太一样，下面我们通过几个例子了解一下python中浅拷贝和深拷贝问题。</p>
<h1>C</h1>
<p>用代码说话。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"addr of a = %p\n"</span>, &amp;a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"addr of b = %p\n"</span>, &amp;b);</span><br><span class="line">a = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"addr of a = %p\n"</span>, &amp;a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"addr of b = %p\n"</span>, &amp;b);</span><br><span class="line">b = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"addr of a = %p\n"</span>, &amp;a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"addr of b = %p\n"</span>, &amp;b);</span><br><span class="line">[usr]./test_shallowcopy_ofC.out</span><br><span class="line">addr of a = <span class="number">0x7ffdb8b0344c</span></span><br><span class="line">addr of b = <span class="number">0x7ffdb8b03448</span></span><br><span class="line">addr of a = <span class="number">0x7ffdb8b0344c</span></span><br><span class="line">addr of b = <span class="number">0x7ffdb8b03448</span></span><br><span class="line">addr of a = <span class="number">0x7ffdb8b0344c</span></span><br><span class="line">addr of b = <span class="number">0x7ffdb8b03448</span></span><br><span class="line"><span class="comment">// 整个过程中a,b的地址并没有发生改变</span></span><br></pre></td></tr></table></figure>
<h1>Python</h1>
<h2 id="简单变量">简单变量</h2>
<p>用代码说话。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># copypy.py</span></span><br><span class="line">a = <span class="number">1</span></span><br><span class="line">b = <span class="number">1</span></span><br><span class="line">print(<span class="string">"addr_of_a="</span>,hex(id(a))) <span class="comment"># 输出a的16进制地址</span></span><br><span class="line">print(<span class="string">"addr_of_b="</span>,hex(id(b)))</span><br><span class="line">a = <span class="number">2</span></span><br><span class="line">print(<span class="string">"addr_of_a="</span>,hex(id(a)))</span><br><span class="line">print(<span class="string">"addr_of_b="</span>,hex(id(b)))</span><br><span class="line">b = <span class="number">2</span></span><br><span class="line">print(<span class="string">"addr_of_a="</span>,hex(id(a)))</span><br><span class="line">print(<span class="string">"addr_of_b="</span>,hex(id(b)))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>python copypy.py</span><br><span class="line">addr_of_a= <span class="number">0x563c06329320</span></span><br><span class="line">addr_of_b= <span class="number">0x563c06329320</span></span><br><span class="line"><span class="comment"># 当初始化的两个变量值相同时，其地址相同</span></span><br><span class="line">addr_of_a= <span class="number">0x563c06329340</span></span><br><span class="line">addr_of_b= <span class="number">0x563c06329320</span></span><br><span class="line"><span class="comment"># 改变某一个变量后其地址也会发生改变</span></span><br><span class="line">addr_of_a= <span class="number">0x563c06329340</span></span><br><span class="line">addr_of_b= <span class="number">0x563c06329340</span></span><br><span class="line"><span class="comment"># 将两个变量改变为相同的值，他们的地址也会变为相同</span></span><br></pre></td></tr></table></figure>
<h2 id="列表">列表</h2>
<p>所以，当使用直接赋值的方式<code>b = a</code>进行变量值的传递时可能会出现问题，当两个变量只是简单的两个数值时似乎并没有什么不同，我们再看以下例子。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># test_copylist.py</span></span><br><span class="line">a = [<span class="literal">True</span>, [<span class="literal">True</span>, <span class="literal">True</span>], <span class="literal">True</span>]</span><br><span class="line">b = a</span><br><span class="line">print(<span class="string">'a='</span>,a)</span><br><span class="line">print(<span class="string">'b='</span>,b)</span><br><span class="line">a[<span class="number">0</span>] = <span class="literal">False</span></span><br><span class="line">a[<span class="number">1</span>][<span class="number">0</span>] = [<span class="literal">False</span>]</span><br><span class="line">print(<span class="string">'a='</span>,a)</span><br><span class="line">print(<span class="string">'b='</span>,b)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>python test_copylist.py</span><br><span class="line">a=[<span class="literal">True</span>, [<span class="literal">True</span>, <span class="literal">True</span>], <span class="literal">True</span>]</span><br><span class="line">b=[<span class="literal">True</span>, [<span class="literal">True</span>, <span class="literal">True</span>], <span class="literal">True</span>]</span><br><span class="line">a=[<span class="literal">False</span>, [[<span class="literal">False</span>], <span class="literal">True</span>], <span class="literal">True</span>]</span><br><span class="line">b=[<span class="literal">False</span>, [[<span class="literal">False</span>], <span class="literal">True</span>], <span class="literal">True</span>]</span><br><span class="line"><span class="comment"># 可以看到当a的值改变时，b的值也会随之变化；</span></span><br><span class="line"><span class="comment"># 这是因为a和b均指向了相同的内存地址；</span></span><br><span class="line"><span class="comment"># 在C语言中这种情况是不会发生的</span></span><br></pre></td></tr></table></figure>
<p>这显然不是我们想看到结果，如果要实现C中赋值的效果(深拷贝)，就需要用到<code>copy</code>模块，模块中有<code>copy.copy()</code>和<code>copy.deepcopy()</code>两个函数，我们看一下使用方法：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># test_copylist2.py</span></span><br><span class="line"><span class="keyword">import</span> copy</span><br><span class="line">a = [<span class="literal">True</span>, [<span class="literal">True</span>, <span class="literal">True</span>], <span class="literal">False</span>]</span><br><span class="line">b = a</span><br><span class="line">copy_a = copy.copy(a)</span><br><span class="line">dcopy_a = copy.deepcopy(a)</span><br><span class="line">print(<span class="string">'Before change'</span>)</span><br><span class="line">print(<span class="string">'addr_of_a='</span>,hex(id(a)))</span><br><span class="line">print(<span class="string">'addr_of_b='</span>,hex(id(b)))</span><br><span class="line">print(<span class="string">'a='</span>,a)</span><br><span class="line">print(<span class="string">'copy_a='</span>,copy_a)</span><br><span class="line">print(<span class="string">'dcopy_a='</span>,dcopy_a)</span><br><span class="line"></span><br><span class="line">a[<span class="number">0</span>] = <span class="literal">False</span></span><br><span class="line">a[<span class="number">1</span>][<span class="number">0</span>] = <span class="literal">False</span></span><br><span class="line">print(<span class="string">'After change'</span>)</span><br><span class="line">print(<span class="string">'addr_of_a='</span>,hex(id(a)))</span><br><span class="line">print(<span class="string">'addr_of_b='</span>,hex(id(b)))</span><br><span class="line">print(<span class="string">'a='</span>,a)</span><br><span class="line">print(<span class="string">'copy_a='</span>,copy_a)</span><br><span class="line">print(<span class="string">'dcopy_a='</span>,dcopy_a)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>python test_copylist2.py</span><br><span class="line">Before change</span><br><span class="line">addr_of_a= <span class="number">0x7f8562f439c8</span></span><br><span class="line">addr_of_b= <span class="number">0x7f8562f439c8</span></span><br><span class="line">a= [<span class="literal">True</span>, [<span class="literal">True</span>, <span class="literal">True</span>], <span class="literal">False</span>]</span><br><span class="line">copy_a= [<span class="literal">True</span>, [<span class="literal">True</span>, <span class="literal">True</span>], <span class="literal">False</span>]</span><br><span class="line">dcopy_a= [<span class="literal">True</span>, [<span class="literal">True</span>, <span class="literal">True</span>], <span class="literal">False</span>]</span><br><span class="line">After change</span><br><span class="line">addr_of_a= <span class="number">0x7f8562f439c8</span></span><br><span class="line">addr_of_b= <span class="number">0x7f8562f439c8</span></span><br><span class="line">a= [<span class="literal">False</span>, [<span class="literal">False</span>, <span class="literal">True</span>], <span class="literal">False</span>]</span><br><span class="line">b= [<span class="literal">False</span>, [<span class="literal">False</span>, <span class="literal">True</span>], <span class="literal">False</span>] <span class="comment"># a is b=True</span></span><br><span class="line">copy_a= [<span class="literal">True</span>, [<span class="literal">False</span>, <span class="literal">True</span>], <span class="literal">False</span>]</span><br><span class="line"><span class="comment"># copy.copy无法拷贝第二级列表</span></span><br><span class="line">dcopy_a= [<span class="literal">True</span>, [<span class="literal">True</span>, <span class="literal">True</span>], <span class="literal">False</span>]</span><br><span class="line"><span class="comment"># copy.deeocopy将创建一个新的变量并从源变量copy值</span></span><br></pre></td></tr></table></figure>
<h1>总结</h1>
<p>如果想要实现C中的拷贝效果，即字面意义上的变量赋值，需要使用<code>y=copy.deepcopy(x)</code>(后续x的变化不会改变y的值)。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>copy</tag>
      </tags>
  </entry>
  <entry>
    <title>Python之更换matplotlib字体</title>
    <url>/2020/06/24/python_fontofmatplotlib.pyplot/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1>更换plt字体</h1>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#Windows环境为Win10，系统自带字体为ttf格式</span></span><br><span class="line">[Windows10]<span class="comment"># C:\Windows\Fonts</span></span><br><span class="line">[Linux]<span class="comment"># cd /../../Fonts #找个地方建个文件夹，把win的字体copy进去</span></span><br><span class="line"><span class="comment">##------.py Start------##</span></span><br><span class="line"><span class="comment">#以win10中New Times字体为例</span></span><br><span class="line"><span class="built_in">times</span> = matplotlib.font_manager.FontProperties(fname=<span class="string">'/Fonts/TIMES.TTF'</span>)</span><br><span class="line">fontname = <span class="built_in">times</span></span><br><span class="line">plt.xticks(fontproperties=fontname, fontsize=12)<span class="comment">#x轴标签</span></span><br><span class="line">plt.yticks(fontproperties=fontname, fontsize=12)<span class="comment">#y轴标签</span></span><br><span class="line">plt.xlabel(<span class="string">'x'</span>, fontproperties=fontname, fontsize=14)<span class="comment">#x坐标轴</span></span><br><span class="line">plt.ylabel(<span class="string">'y'</span>, fontproperties=fontname, fontsize=14)<span class="comment">#y坐标轴</span></span><br><span class="line">plt.legend(prop=fontname,fontsize=12)<span class="comment">#图例</span></span><br><span class="line">plt.show()</span><br><span class="line"><span class="comment">##------.py End------##</span></span><br></pre></td></tr></table></figure>
<p>全局字体设置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#plt.colorbar字体更换</span></span><br><span class="line">[linux]<span class="comment"># cd /home/usrname/.cache/matplotlib</span></span><br><span class="line">[linux]<span class="comment"># vim fontlist-v310.json fontlist-v310.json</span></span><br><span class="line"><span class="comment"># 在ttflist中添加你想要的字体</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="string">"fname"</span>: <span class="string">"字体路径"</span>,</span><br><span class="line">   <span class="string">"name"</span>: <span class="string">"Times New Roman"</span>, <span class="comment">#调用时的字体名称</span></span><br><span class="line">   <span class="string">"style"</span>: <span class="string">"normal"</span>,</span><br><span class="line">   <span class="string">"variant"</span>: <span class="string">"normal"</span>,</span><br><span class="line">   <span class="string">"weight"</span>: 700,</span><br><span class="line">   <span class="string">"stretch"</span>: <span class="string">"normal"</span>,</span><br><span class="line">   <span class="string">"size"</span>: <span class="string">"scalable"</span>,</span><br><span class="line">   <span class="string">"__class__"</span>: <span class="string">"FontEntry"</span></span><br><span class="line"> &#125;,</span><br><span class="line">[linux]<span class="comment"># 在程序中设置plt的全局字体</span></span><br><span class="line"><span class="comment">##------.py Start------##</span></span><br><span class="line">plt.rcParams[<span class="string">'font.family'</span>] = <span class="string">'Times New Roman'</span></span><br><span class="line"><span class="comment">##------.py End------##</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>font</tag>
      </tags>
  </entry>
  <entry>
    <title>地震数据波形变密度绘图</title>
    <url>/2020/10/05/python_wiggle_trace/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1>地震数据变密度显示</h1>
<p>以下代码节选自fatiando包的vis.mpl.seismic_wiggle模块</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot</span><br><span class="line"><span class="keyword">import</span> numpy</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">seismic_wiggle</span><span class="params">(section, dt=<span class="number">0.004</span>, ranges=None, scale=<span class="number">1.</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                   color=<span class="string">'k'</span>, normalize=False)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Plot a seismic section (numpy 2D array matrix) as wiggles.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Parameters:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    * section :  二维数组，第一个维度为时间，第二个维度为导数</span></span><br><span class="line"><span class="string">        matrix of traces (first dimension time, second dimension traces)</span></span><br><span class="line"><span class="string">    * dt : float</span></span><br><span class="line"><span class="string">        时间采样率（默认四毫秒）</span></span><br><span class="line"><span class="string">    * ranges : (x1, x2)</span></span><br><span class="line"><span class="string">        水平最大最小值（默认为道号）</span></span><br><span class="line"><span class="string">    * scale : float</span></span><br><span class="line"><span class="string">        比例因子</span></span><br><span class="line"><span class="string">    * color : tuple of strings</span></span><br><span class="line"><span class="string">        Color for filling the wiggle, positive  and negative lobes.</span></span><br><span class="line"><span class="string">    * normalize :</span></span><br><span class="line"><span class="string">        True: 使用全局最大和最小值将所有道的数据归一化到[-0.5, 0.5]</span></span><br><span class="line"><span class="string">    .. warning::</span></span><br><span class="line"><span class="string">        Slow for more than 200 traces, in this case decimate your</span></span><br><span class="line"><span class="string">        data or use ``seismic_image``.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    npts, ntraces = section.shape  <span class="comment"># time/traces</span></span><br><span class="line">    <span class="keyword">if</span> ntraces &lt; <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">raise</span> IndexError(<span class="string">"Nothing to plot"</span>)</span><br><span class="line">    <span class="keyword">if</span> npts &lt; <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">raise</span> IndexError(<span class="string">"Nothing to plot"</span>)</span><br><span class="line">    t = numpy.linspace(<span class="number">0</span>, dt*npts, npts)</span><br><span class="line">    amp = <span class="number">1.</span>  <span class="comment"># normalization factor</span></span><br><span class="line">    gmin = <span class="number">0.</span>  <span class="comment"># global minimum</span></span><br><span class="line">    toffset = <span class="number">0.</span>  <span class="comment"># offset in time to make 0 centered</span></span><br><span class="line">    <span class="keyword">if</span> normalize:</span><br><span class="line">        gmax = section.max()</span><br><span class="line">        gmin = section.min()</span><br><span class="line">        amp = (gmax-gmin)</span><br><span class="line">        toffset = <span class="number">0.5</span></span><br><span class="line">    pyplot.ylim(max(t), <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span> ranges <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        ranges = (<span class="number">0</span>, ntraces)</span><br><span class="line">    x0, x1 = ranges</span><br><span class="line">    <span class="comment"># horizontal increment</span></span><br><span class="line">    dx = float((x1-x0)/ntraces)</span><br><span class="line">    pyplot.xlim(x0, x1)</span><br><span class="line">    <span class="keyword">for</span> i, trace <span class="keyword">in</span> enumerate(section.transpose()):</span><br><span class="line">        tr = (((trace-gmin)/amp)-toffset)*scale*dx</span><br><span class="line">        x = x0+i*dx  <span class="comment"># x positon for this trace</span></span><br><span class="line">        pyplot.plot(x+tr, t, <span class="string">'k'</span>)</span><br><span class="line">        pyplot.fill_betweenx(t, x+tr, x, tr &gt; <span class="number">0</span>, color=color)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>pyseis</category>
      </categories>
      <tags>
        <tag>地震数据绘图</tag>
      </tags>
  </entry>
  <entry>
    <title>OBSpy+rf接收函数计算</title>
    <url>/2020/12/25/recfunc/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1>Receiver Function profile with rf package</h1>
<h3 id="本文档翻译自https-nbviewer-jupyter-org-github-trichter-notebooks-blob-master-receiver-function-profile-chile-ipynb">本文档翻译自<a href="https://nbviewer.jupyter.org/github/trichter/notebooks/blob/master/receiver_function_profile_chile.ipynb" target="_blank" rel="noopener">https://nbviewer.jupyter.org/github/trichter/notebooks/blob/master/receiver_function_profile_chile.ipynb</a></h3>
<p>此ipynb脚本借助<a href="https://github.com/trichter/rf" target="_blank" rel="noopener">rf软件包</a>使用智利北部的IPOC数据演示了receiver function的计算和剖面叠加。此脚本依赖项ObsPy，rf，h5py，obspyh5和tqdm。首先，我们导入必要的函数，并为目录，地震和波形文件定义文件名。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> obspy <span class="keyword">import</span> read_inventory, read_events, UTCDateTime <span class="keyword">as</span> UTC</span><br><span class="line"><span class="keyword">from</span> obspy.clients.fdsn <span class="keyword">import</span> Client</span><br><span class="line"><span class="keyword">from</span> rf <span class="keyword">import</span> read_rf, RFStream</span><br><span class="line"><span class="keyword">from</span> rf <span class="keyword">import</span> get_profile_boxes, iter_event_data, IterMultipleComponents</span><br><span class="line"><span class="keyword">from</span> rf.imaging <span class="keyword">import</span> plot_profile_map</span><br><span class="line"><span class="keyword">from</span> rf.profile <span class="keyword">import</span> profile</span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">	创建-&gt;data文件夹并定义文件名称</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">data = os.path.join(<span class="string">'data'</span>, <span class="string">''</span>)</span><br><span class="line">invfile = data + <span class="string">'rf_profile_stations.xml'</span></span><br><span class="line">catfile = data + <span class="string">'rf_profile_events.xml'</span></span><br><span class="line">datafile = data + <span class="string">'rf_profile_data.h5'</span></span><br><span class="line">rffile = data + <span class="string">'rf_profile_rfs.h5'</span></span><br><span class="line">profilefile = data + <span class="string">'rf_profile_profile.h5'</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(data):  <span class="comment"># create data folder if necessary</span></span><br><span class="line">    os.mkdir(data)</span><br></pre></td></tr></table></figure>
<p>如有必要，可以下载震级5.5和6.5之间的2010年库存数据和事件并作图。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(invfile):</span><br><span class="line">    client = Client(<span class="string">'GFZ'</span>)</span><br><span class="line">    inventory = client.get_stations(network=<span class="string">'CX'</span>, channel=<span class="string">'BH?'</span>, level=<span class="string">'channel'</span>,</span><br><span class="line">                                    minlatitude=<span class="number">-24</span>, maxlatitude=<span class="number">-19</span>)</span><br><span class="line">    inventory.write(invfile, <span class="string">'STATIONXML'</span>)</span><br><span class="line">inventory = read_inventory(invfile)</span><br><span class="line">inventory.plot(label=<span class="literal">False</span>)</span><br><span class="line">fig = inventory.plot(<span class="string">'local'</span>, color_per_network=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">coords = inventory.get_coordinates(<span class="string">'CX.PB01..BHZ'</span>)</span><br><span class="line">lonlat = (coords[<span class="string">'longitude'</span>], coords[<span class="string">'latitude'</span>])</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(catfile):</span><br><span class="line">    client = Client()</span><br><span class="line">    kwargs = &#123;<span class="string">'starttime'</span>: UTC(<span class="string">'2010-01-01'</span>), <span class="string">'endtime'</span>: UTC(<span class="string">'2011-01-01'</span>), </span><br><span class="line">              <span class="string">'latitude'</span>: lonlat[<span class="number">1</span>], <span class="string">'longitude'</span>: lonlat[<span class="number">0</span>],</span><br><span class="line">              <span class="string">'minradius'</span>: <span class="number">30</span>, <span class="string">'maxradius'</span>: <span class="number">90</span>,</span><br><span class="line">              <span class="string">'minmagnitude'</span>: <span class="number">5.5</span>, <span class="string">'maxmagnitude'</span>: <span class="number">6.5</span>&#125;</span><br><span class="line">    catalog = client.get_events(**kwargs)</span><br><span class="line">    catalog.write(catfile, <span class="string">'QUAKEML'</span>)</span><br><span class="line">catalog = read_events(catfile)</span><br><span class="line">fig = catalog.plot(label=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/2020/12/25/recfunc/download.png" alt="inventory"><br>
<img src="/2020/12/25/recfunc/2.png" alt="stations"><br>
然后，我们使用<code>iter_event_data</code>迭代器下载波形数据，并将其保存到<code>HDF5</code>文件中。 迭代器通过应用<code>rfstats</code>函数自动将必要的标头插入流中。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(datafile):</span><br><span class="line">    client = Client(<span class="string">'GFZ'</span>)</span><br><span class="line">    stream = RFStream()</span><br><span class="line">    <span class="keyword">with</span> tqdm() <span class="keyword">as</span> pbar:</span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> iter_event_data(catalog, inventory, client.get_waveforms, pbar=pbar):</span><br><span class="line">            stream.extend(s)</span><br><span class="line">    stream.write(datafile, <span class="string">'H5'</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/2020/12/25/recfunc/88events.png" alt="events"><br>
我们再次读取数据，并使用<code>IterMultipleComponents</code>对其进行遍历。 该迭代器为每个事件和台站返回一个三分量流。 我们过滤数据，相对于P波起始点进行修剪，计算接收函数并应用<code>Ps</code>偏移校正。 此后，绘制一个站的L分量和某些站的Q分量。 接收函数的L分量在0s处显示预期的峰值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data = read_rf(datafile, <span class="string">'H5'</span>)</span><br><span class="line">stream = RFStream()</span><br><span class="line"><span class="keyword">for</span> stream3c <span class="keyword">in</span> tqdm(IterMultipleComponents(data, <span class="string">'onset'</span>, <span class="number">3</span>)):</span><br><span class="line">    stream3c.filter(<span class="string">'bandpass'</span>, freqmin=<span class="number">0.5</span>, freqmax=<span class="number">2</span>)</span><br><span class="line">    stream3c.trim2(<span class="number">-25</span>, <span class="number">75</span>, <span class="string">'onset'</span>)</span><br><span class="line">    <span class="keyword">if</span> len(stream3c) != <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    stream3c.rf()</span><br><span class="line">    stream3c.moveout()</span><br><span class="line">    stream.extend(stream3c)</span><br><span class="line">stream.write(rffile, <span class="string">'H5'</span>)</span><br><span class="line">print(stream)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3273 Trace(s) in Stream:</span><br><span class="line"></span><br><span class="line">Prf CX.HMBCX..BHT | -25.0s - 75.0s onset:2010-01-27T17:52:02.949998Z | 20.0 Hz, 2001 samples | mag:5.8 dist:53.1 baz:92.8 slow:6.40 (Ps moveout)</span><br><span class="line">...</span><br><span class="line">(3271 other traces)</span><br><span class="line">...</span><br><span class="line">Prf CX.PSGCX..BHL | -25.0s - 75.0s onset:2010-12-31T16:39:31.150000Z | 20.0 Hz, 2001 samples | mag:5.5 dist:47.7 baz:70.2 slow:6.40 (Ps moveout)</span><br><span class="line"></span><br><span class="line">[Use &quot;print(Stream.__str__(extended&#x3D;True))&quot; to print all Traces]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">stream = read_rf(rffile, <span class="string">'H5'</span>)</span><br><span class="line">kw = &#123;<span class="string">'trim'</span>: (<span class="number">-5</span>, <span class="number">20</span>), <span class="string">'fillcolors'</span>: (<span class="string">'black'</span>, <span class="string">'gray'</span>), <span class="string">'trace_height'</span>: <span class="number">0.1</span>&#125;</span><br><span class="line">stream.select(component=<span class="string">'L'</span>, station=<span class="string">'PB01'</span>).sort([<span class="string">'back_azimuth'</span>]).plot_rf(**kw)</span><br><span class="line"><span class="keyword">for</span> sta <span class="keyword">in</span> (<span class="string">'PB01'</span>, <span class="string">'PB04'</span>):</span><br><span class="line">    stream.select(component=<span class="string">'Q'</span>, station=sta).sort([<span class="string">'back_azimuth'</span>]).plot_rf(**kw)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/2020/12/25/recfunc/PB01BHL.png" alt="PB01BHL"><br>
<img src="/2020/12/25/recfunc/PB01BHQ.png" alt="PB01BHQ"><br>
<img src="/2020/12/25/recfunc/PB04BHQ.png" alt="PB04BHQ"><br>
最后，我们通过在70 km的深度中穿入点经度来堆叠接收函数，并绘制剖面。 <code>get_profile_boxes</code>函数用于定义要叠加的区域。 方位角为90度，以定义东西走向。 使用<code>plot_profile_map</code>绘制域。 该剖面由配置剖面函数生成。 使用剖面函数而不是<code>RFStream.profile</code>方法可以显示进度条（对于大型数据集，也可以直接从光盘中feedRF数据）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">stream = read_rf(rffile, <span class="string">'H5'</span>)</span><br><span class="line">ppoints = stream.ppoints(<span class="number">70</span>)</span><br><span class="line">boxes = get_profile_boxes((<span class="number">-21.3</span>, <span class="number">-70.7</span>), <span class="number">90</span>, np.linspace(<span class="number">0</span>, <span class="number">180</span>, <span class="number">73</span>), width=<span class="number">530</span>)</span><br><span class="line">plt.figure(figsize=(<span class="number">10</span>, <span class="number">10</span>))</span><br><span class="line">plot_profile_map(boxes, inventory=inventory, ppoints=ppoints)</span><br><span class="line">pstream = profile(tqdm(stream), boxes)</span><br><span class="line">pstream.write(profilefile, <span class="string">'H5'</span>)</span><br><span class="line">plt.show()</span><br><span class="line">print(pstream)</span><br></pre></td></tr></table></figure>
<p><img src="/2020/12/25/recfunc/5.png" alt="pstream"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">213 Trace(s) in Stream:</span><br><span class="line"></span><br><span class="line">Prf profile (L) | -25.0s - 75.0s | 20.0 Hz, 2001 samples | pos:1.25km slow:6.40 (Ps moveout)</span><br><span class="line">...</span><br><span class="line">(211 other traces)</span><br><span class="line">...</span><br><span class="line">Prf profile (T) | -25.0s - 75.0s | 20.0 Hz, 2001 samples | pos:178.75km slow:6.40 (Ps moveout)</span><br><span class="line"></span><br><span class="line">[Use &quot;print(Stream.__str__(extended&#x3D;True))&quot; to print all Traces]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pstream = read_rf(profilefile)</span><br><span class="line">pstream.trim2(<span class="number">-5</span>, <span class="number">20</span>, <span class="string">'onset'</span>)</span><br><span class="line">pstream.select(channel=<span class="string">'??Q'</span>).normalize().plot_profile(scale=<span class="number">1.5</span>, top=<span class="string">'hist'</span>)</span><br><span class="line">plt.gcf().set_size_inches(<span class="number">15</span>, <span class="number">10</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/2020/12/25/recfunc/6.png" alt="pstream"></p>
]]></content>
      <categories>
        <category>obspy</category>
      </categories>
      <tags>
        <tag>天然地震</tag>
      </tags>
  </entry>
  <entry>
    <title>Centos安装后无法启动Windows问题</title>
    <url>/2020/08/30/system/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1>CentOS安装后Windows无法启动问题</h1>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root]$ wget -O /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-7.repo</span><br><span class="line">[root]$ yum update</span><br><span class="line">[root]$ yum install ntfs-3g</span><br><span class="line">[root]$ grub2-mkconfig -o /boot/grub2/grub.cfg</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>装机</category>
      </categories>
      <tags>
        <tag>装机</tag>
      </tags>
  </entry>
  <entry>
    <title>Tensorboard记录Loss变化</title>
    <url>/2020/10/14/tensorflow1.14.0_loss_summary/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1>利用Tensorboard记录Loss值</h1>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">运行环境：</span><br><span class="line">tensorflow==<span class="number">1.14</span><span class="number">.0</span></span><br><span class="line">keras==<span class="number">2.2</span><span class="number">.5</span></span><br></pre></td></tr></table></figure>
<h1>构建模型</h1>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">CNN = build_cnn()</span><br><span class="line"><span class="comment"># type(CNN) = keras.engine.training.Model</span></span><br></pre></td></tr></table></figure>
<h1>log记录函数</h1>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write_log</span><span class="params">(callback, names, logs, batch_no)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> name, value <span class="keyword">in</span> zip(names, logs):</span><br><span class="line">        summary = tf.Summary()</span><br><span class="line">        summary_value = summary.value.add()</span><br><span class="line">        summary_value.simple_value = value</span><br><span class="line">        summary_value.tag = name</span><br><span class="line">        callback.writer.add_summary(summary, batch_no)</span><br><span class="line">        callback.writer.flush()</span><br></pre></td></tr></table></figure>
<h1>创建Tensorboard记录</h1>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># log_path = './logs'</span></span><br><span class="line">callback = TensorBoard(log_path)</span><br><span class="line">callback.set_model(CNN)</span><br></pre></td></tr></table></figure>
<h1>在训练过程中记录Loss</h1>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">datasize = X.shape[<span class="number">0</span>]</span><br><span class="line">batches = datasize//batch_size</span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> range(epochs):</span><br><span class="line">	<span class="keyword">for</span> batch <span class="keyword">in</span> range(batches):</span><br><span class="line">		loss = CNN.train_on_batch(x, y)</span><br><span class="line">		write_log(callback, </span><br><span class="line">                  CNN.metrics_names,</span><br><span class="line">                  loss,</span><br><span class="line">                  epoch * batches + batch)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>tensorflow</category>
      </categories>
      <tags>
        <tag>tensorboard</tag>
      </tags>
  </entry>
  <entry>
    <title>tensorflow之scope使用</title>
    <url>/2020/07/12/tf_name_scope_variable_scope_new/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1>tensorflow中名称作用域和变量作用域</h1>
<p>名称作用域和变量作用域能让我们在<strong>tensorboard</strong>中更清晰得看到各类变量所处的命名空间以及输入、输出的流动方向。当神经网络架构较为复杂时，可以通过为网络不同块的变量和运算创建作用域的形式来使<strong>graph</strong>更整洁。(源码为官方代码，<strong>注释为翻译版</strong>，英文版请查看源码<strong>doc</strong>或者关注<a href="https://tensorflow.google.cn/api_docs/python/tf/compat/v1/variable_scope" target="_blank" rel="noopener">官方网站</a>)</p>
<h1>源码</h1>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Init signature:</span><br><span class="line">tf.variable_scope(</span><br><span class="line">    name_or_scope, <span class="comment"># 传入&lt;str&gt;或者scope</span></span><br><span class="line">    default_name=<span class="literal">None</span>, <span class="comment"># 若name_or_scope==None，则自动生成具有唯一标示的名称；</span></span><br><span class="line">    values=<span class="literal">None</span>, <span class="comment"># 需要用于op的Tensor列表</span></span><br><span class="line">    initializer=<span class="literal">None</span>, <span class="comment"># 该scope中变量默认初始化方式</span></span><br><span class="line">    regularizer=<span class="literal">None</span>, <span class="comment"># 该scope中变量默认正则化方式</span></span><br><span class="line">    caching_device=<span class="literal">None</span>, <span class="comment"># 该scope中变量默认缓存设备</span></span><br><span class="line">    partitioner=<span class="literal">None</span>, <span class="comment"># 该scope中变量的默认分区</span></span><br><span class="line">    custom_getter=<span class="literal">None</span>, <span class="comment"># 不知道干啥的</span></span><br><span class="line">    reuse=<span class="literal">None</span>, <span class="comment"># 是否重用，True,None or tf.AUTO_REUSE</span></span><br><span class="line">    dtype=<span class="literal">None</span>, <span class="comment"># 变量类型(默认为传入的变量类型或者从父scope继承)</span></span><br><span class="line">    use_resource=<span class="literal">None</span>, <span class="comment"># False: 所有变量均为均为常规变量。\\ True: 具有良定义语义学的experimental ResourceVariables</span></span><br><span class="line">    constraint=<span class="literal">None</span>, <span class="comment"># 在优化器更新变量之后，使用一个投影函数对输出进行变换。</span></span><br><span class="line">    auxiliary_name_scope=<span class="literal">True</span>, <span class="comment"># True:创建一个辅助name scope;该变量不具有继承属性，\\ 只有第一次创建时才有作用；所以应在重新进入已经创建好的scope时才使用。</span></span><br><span class="line">)</span><br><span class="line"><span class="comment"># 函数返回一个可以被capture和reuse的socpe。</span></span><br></pre></td></tr></table></figure>
<p>函数注释:</p>
<p>一个定义<code>vars</code>或<code>layers</code>生成<code>ops</code>的上下文管理器。</p>
<p>这一上下文管理器会确认（可选）<code>values</code>是否来自于同一<code>graph</code>，确保<code>graph</code>是默认<code>graph</code>，并且会<code>push</code>名称作用域(<code>name_scpoe</code>)和变量作用域(<code>variable_scope</code>)</p>
<p>如果<code>name_or_scope</code>不为<code>None</code>,则使用<code>as is</code>.如果<code>scope</code>为<code>None</code>,则使用<code>default_name</code>。此时，如果已经使用过相同的名字，则在其后添加<code>_N</code>表示第<strong>N</strong>个具有相同名称前缀的作用域或变量来使其具有唯一性。</p>
<p>在<code>variable_scope</code>中可以创建新的变量，也可以共享已经创建的变量，并且可以检查是否存在意外创建或共享的情况。</p>
<p>创建一个新的变量：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> tf.compat.v1.variable_scope(<span class="string">"foo"</span>):</span><br><span class="line">    <span class="keyword">with</span> tf.compat.v1.variable_scope(<span class="string">"bar"</span>):</span><br><span class="line">        v = tf.compat.v1.get_variable(<span class="string">"v"</span>, [<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">assert</span> v.name == <span class="string">"foo/bar/v:0"</span></span><br></pre></td></tr></table></figure>
<p>安全进入一个已经创建好的<code>variable scope</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> tf.compat.v1.variable_scope(<span class="string">"foo"</span>) <span class="keyword">as</span> vs:</span><br><span class="line">  <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新进入变量作用域</span></span><br><span class="line"><span class="keyword">with</span> tf.compat.v1.variable_scope(vs, auxiliary_name_scope=<span class="literal">False</span>) <span class="keyword">as</span> vs1:</span><br><span class="line">  <span class="comment"># 重建原始的名称作用域</span></span><br><span class="line">  <span class="keyword">with</span> tf.name_scope(vs1.original_name_scope):</span><br><span class="line">      v = tf.compat.v1.get_variable(<span class="string">"v"</span>, [<span class="number">1</span>])</span><br><span class="line">      <span class="keyword">assert</span> v.name == <span class="string">"foo/v:0"</span></span><br><span class="line">      c = tf.constant([<span class="number">1</span>], name=<span class="string">"c"</span>)</span><br><span class="line">      <span class="keyword">assert</span> c.name == <span class="string">"foo/c:0"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(v)</span><br><span class="line">&lt;tf.Variable <span class="string">'foo/v:0'</span> shape=(<span class="number">1</span>,) dtype=float32_ref&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(type(v))</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">tensorflow</span>.<span class="title">python</span>.<span class="title">ops</span>.<span class="title">variables</span>.<span class="title">RefVariable</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">print</span><span class="params">(c)</span></span></span><br><span class="line"><span class="class"><span class="title">Tensor</span><span class="params">(<span class="string">"foo/c:0"</span>, shape=<span class="params">(<span class="number">1</span>,)</span>, dtype=int32)</span></span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">print</span><span class="params">(type<span class="params">(c)</span>)</span></span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> '<span class="title">tensorflow</span>.<span class="title">python</span>.<span class="title">framework</span>.<span class="title">ops</span>.<span class="title">Tensor</span>'&gt;</span></span><br></pre></td></tr></table></figure>
<p>通过 <code>AUTO_REUSE</code>共享变量：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">  <span class="keyword">with</span> tf.compat.v1.variable_scope(<span class="string">"foo"</span>,</span><br><span class="line">  reuse=tf.compat.v1.AUTO_REUSE):</span><br><span class="line">    v = tf.compat.v1.get_variable(<span class="string">"v"</span>, [<span class="number">1</span>])</span><br><span class="line">  <span class="keyword">return</span> v</span><br><span class="line"></span><br><span class="line">v1 = foo()  <span class="comment"># 创建变量 v.</span></span><br><span class="line">v2 = foo()  <span class="comment"># 获取创建的 v，即v1.</span></span><br><span class="line"><span class="keyword">assert</span> v1 == v2</span><br><span class="line"><span class="keyword">assert</span> id(v1) == id(v2) </span><br><span class="line"><span class="comment"># 相当于v1和v2均指向相同的内存地址</span></span><br></pre></td></tr></table></figure>
<p>通过 <code>reuse=True</code>共享变量:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> tf.compat.v1.variable_scope(<span class="string">"foo"</span>):</span><br><span class="line">    v = tf.compat.v1.get_variable(<span class="string">"v"</span>, [<span class="number">1</span>])</span><br><span class="line"><span class="keyword">with</span> tf.compat.v1.variable_scope(<span class="string">"foo"</span>, reuse=<span class="literal">True</span>):</span><br><span class="line">    v1 = tf.compat.v1.get_variable(<span class="string">"v"</span>, [<span class="number">1</span>])</span><br><span class="line"><span class="keyword">assert</span> v1 == v</span><br><span class="line"><span class="keyword">assert</span> id(v1) == id(v)</span><br></pre></td></tr></table></figure>
<p>在当前<code>scope</code>内设置<code>reuse</code>:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 注意：必须要把scope.reuse_variables()放在已创建的变量之后以及重用之前。</span></span><br><span class="line"><span class="keyword">with</span> tf.compat.v1.variable_scope(<span class="string">"foo"</span>) <span class="keyword">as</span> scope:</span><br><span class="line">    v = tf.compat.v1.get_variable(<span class="string">"v"</span>, [<span class="number">1</span>])</span><br><span class="line">    scope.reuse_variables()</span><br><span class="line">    v1 = tf.compat.v1.get_variable(<span class="string">"v"</span>, [<span class="number">1</span>])</span><br><span class="line"><span class="keyword">assert</span> v1 == v</span><br></pre></td></tr></table></figure>
<p>为了避免变量的意外共享，当并未在<code>scope</code>中设置<code>reuse</code>而重复定义相同命名的变量时会抛出<code>ValueError</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> tf.compat.v1.variable_scope(<span class="string">"foo"</span>):</span><br><span class="line">    v = tf.compat.v1.get_variable(<span class="string">"v"</span>, [<span class="number">1</span>])</span><br><span class="line">    v1 = tf.compat.v1.get_variable(<span class="string">"v"</span>, [<span class="number">1</span>])</span><br><span class="line">    <span class="comment">#  Raises ValueError("... v already exists ...").</span></span><br></pre></td></tr></table></figure>
<p>同样地，当<code>reuse</code>为<code>True</code>时，如果第一次定义变量也会抛出<code>VauleError</code>(即没有可以用来重用的变量)：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> tf.compat.v1.variable_scope(<span class="string">"foo"</span>, reuse=<span class="literal">True</span>):</span><br><span class="line">    v = tf.compat.v1.get_variable(<span class="string">"v"</span>, [<span class="number">1</span>])</span><br><span class="line">    <span class="comment">#  Raises ValueError("... v does not exists ...").</span></span><br></pre></td></tr></table></figure>
<p><code>reuse</code>的继承属性：当打开一个<code>reusing</code>作用域时，其中的所有子作用域也将是<code>resuing</code>的。</p>
<p>多线程环境中的变量作用域说明：variable scope是线程的局部变量，所以一个线程的scope对于另一线程而言是不可见的。另外，当使用<code>default_name</code>，唯一的<code>scope</code>名称也只是相对于每一个线程而言的，如果多个线程使用了相同的名字，一个新的线程仍然能够创建相同的<code>scope</code></p>
<p>以下示例中，变量是被线程共享的(同一<code>graph</code>中)。严格来讲，只有当<code>resue</code>为<code>True</code>时，线程在创建其它线程已经创建过的同名变量时才会成功。</p>
<p>另外，每个线程的起始<code>scope</code>为空，所以如果想在其它线程中保留主线程<code>scope</code>中变量的名称前缀，需要capture主线程的scope并在其它线程中重新进入这一<code>scope</code>，例：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">main_thread_scope = variable_scope.get_variable_scope()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Thread's target function:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">thread_target_fn</span><span class="params">(captured_scope)</span>:</span></span><br><span class="line">  <span class="keyword">with</span> variable_scope.variable_scope(captured_scope):</span><br><span class="line">    <span class="comment"># .... regular code for this thread</span></span><br><span class="line">    </span><br><span class="line">thread = threading.Thread(target=thread_target_fn, args=(main_thread_scope,))</span><br></pre></td></tr></table></figure>
<h1>实例</h1>
<h2 id="variable-scope">variable_scope</h2>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">scope1 = <span class="string">"Test1"</span></span><br><span class="line"><span class="keyword">with</span> tf.variable_scope(scope1):</span><br><span class="line">    testA = tf.get_variable(<span class="string">"testA1"</span>, [<span class="number">3</span>, <span class="number">256</span>, <span class="number">256</span>])</span><br><span class="line">    testB = tf.get_variable(<span class="string">"testA2"</span>, [<span class="number">3</span>, <span class="number">256</span>, <span class="number">256</span>])</span><br><span class="line">    testC = tf.multiply(testA, testB, name = <span class="string">"Mul-testA12"</span>)</span><br><span class="line">    testD = tf.Variable([<span class="number">1</span>],name=<span class="string">"testD"</span>)</span><br><span class="line"><span class="comment"># testA: &lt;tf.Variable 'Test1/testA1:0' shape=(3, 256, 256) dtype=float32_ref&gt;</span></span><br><span class="line"><span class="comment"># testB: &lt;tf.Variable 'Test1/testA2:0' shape=(3, 256, 256) dtype=float32_ref&gt;</span></span><br><span class="line"><span class="comment"># testC: Tensor("Test1/Mul-testA12:0", shape=(3, 256, 256), dtype=float32)</span></span><br><span class="line"><span class="comment"># testD: &lt;tf.Variable 'Test1/testD:0' shape=(1,) dtype=int32_ref&gt;</span></span><br></pre></td></tr></table></figure>
<p>可以看到<code>variable_scope</code>能够同时影响到<code>tf.get_variable</code>以及<code>op</code>的命名，也就是说，变量域的作用范围内命名的变量，其前缀为变量域名。<br>
<img src="/2020/07/12/tf_name_scope_variable_scope_new/variablescope.png" alt="Tensorboard"></p>
<h2 id="name-scope">name_scope</h2>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">scope1 = <span class="string">"Test1"</span></span><br><span class="line"><span class="keyword">with</span> tf.name_scope(scope1):</span><br><span class="line">    testA = tf.get_variable(<span class="string">"testA1"</span>, [<span class="number">3</span>, <span class="number">256</span>, <span class="number">256</span>])</span><br><span class="line">    testB = tf.get_variable(<span class="string">"testA2"</span>, [<span class="number">3</span>, <span class="number">256</span>, <span class="number">256</span>])</span><br><span class="line">    testC = tf.multiply(testA, testB, name = <span class="string">"Mul-testA12"</span>)</span><br><span class="line">    testD = tf.Variable([<span class="number">1</span>],name=<span class="string">"testD"</span>)</span><br><span class="line"><span class="comment"># testA: &lt;tf.Variable 'testA1:0' shape=(3, 256, 256) dtype=float32_ref&gt;</span></span><br><span class="line"><span class="comment"># testB: &lt;tf.Variable 'testA2:0' shape=(3, 256, 256) dtype=float32_ref&gt;</span></span><br><span class="line"><span class="comment"># testC: Tensor("Test1/Mul-testAC:0", shape=(3, 256, 256), dtype=float32)</span></span><br><span class="line"><span class="comment"># testD: &lt;tf.Variable 'Test1/testD:0' shape=(1,) dtype=int32_ref&gt;</span></span><br></pre></td></tr></table></figure>
<p>而在<code>name_scope</code>中，其不会影响到由<code>tf.get_variable</code>得到的变量，只会作用于<code>op</code>运算得到的变量以及由<code>tf.Variable</code>得到的变量。<br>
<img src="/2020/07/12/tf_name_scope_variable_scope_new/namescope.png" alt="Tensorboard"></p>
]]></content>
      <categories>
        <category>Tensorflow</category>
      </categories>
      <tags>
        <tag>scope</tag>
      </tags>
  </entry>
  <entry>
    <title>NoisePy安装及简易教程</title>
    <url>/2020/12/27/NoisePy001/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1>NoisePy简易教程</h1>
<h4 id="翻译自GitHub">翻译自<a href="https://github.com/mdenolle/NoisePy" target="_blank" rel="noopener">GitHub</a></h4>
<p>NoisePy是一个Python软件包，旨在快速轻松地计算背景噪声互相关函数。 它提供了用于噪声监视和表面波色散分析的其他功能。</p>
<p>免责声明：此代码不应“按原样”使用，也不能像黑盒一样运行。 希望用户更改本地路径和参数。 如果有问题，请将其提交到github，其中包含要调试的脚本和错误消息等信息。</p>
<p>完整doc请参考 <a href="https://noise-python.readthedocs.io/en/latest/" target="_blank" rel="noopener">https://noise-python.readthedocs.io/en/latest/</a><br>
<img src="/2020/12/27/NoisePy001/logo.png" alt="logo"></p>
<h2 id="引用">引用</h2>
<p>如果您在文章中使用了代码，请引用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Jiang, C. and Denolle, M. &quot;NoisePy: a new high-performance python tool for seismic ambient noise seismology.&quot; Seismological Research Letter 91 (3): 1853–1866.</span><br></pre></td></tr></table></figure>
<h2 id="安装">安装</h2>
<p>NoisePy由python脚本组成，因此其安装方式十分灵活，这实际上是为了构建脚本和相关功能的依赖库。 我们建议使用conda和pip安装库，因为它们更方便。 下面是我们经过测试的命令行，这些命令行将创建一个运行NoisePy的python环境。 请注意，该测试是在MacOS上执行的，因此对于其他OS可能会略有不同。（假设主机已经安装了MPI，mpi4py包会用到）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda create -n noisepy -c conda-forge python=3.7 numpy=1.16.2 numba pandas pycwt jupyter mpi4py=3.0.1 obspy=1.1 pyasdf</span><br><span class="line">conda activate noisepy</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/mdenolle/NoisePy.git</span><br></pre></td></tr></table></figure>
<h2 id="功能">功能</h2>
<ul>
<li>根据obspy的<code>get_station</code>和<code>get_waveforms</code>的核心功能下载连续噪声数据</li>
<li>以ASDF格式保存地震数据，该数据可以方便地将元数据、波形数据和辅助数据组合到一个文件中（读/写ASDF文件的教程）</li>
<li>提供了高度的灵活性来处理存储在本地计算机上的混乱的SAC / miniSEED数据并将其转换为ASDF格式的数据，可以轻松地将其插入NoisePy</li>
<li>通过MPI并行运行功能，执行快速，简单的互相关(cross-correlation)</li>
<li>包括一系列监视功能，可使用一些最近开发的新方法来对结果互相关函数上的dv / v进行测量（有关更多详细信息，请参见我们的论文）</li>
</ul>
<h2 id="简易教程">简易教程</h2>
<h3 id="0A-使用S0A-download-ASDF-MPI-py下载地震噪声数据">0A. 使用<code>S0A_download_ASDF_MPI.py</code>下载地震噪声数据</h3>
<p>该脚本（位于<code>src</code>目录中）及其现有参数允许通过SCEC数据中心下载位于某个区域并在1/Jul/2016-2/Jul/2016 期间运行的所有可用宽频CI台站（BH？） 。</p>
<p>在脚本中，为所有可根据用户需要更改的输入参数提供了简短摘要。</p>
<p>在脚本的当前形式中，我们设置<code>inc_hours = 24</code>，下载一整天的连续噪声数据以及元信息，并将其存储在单个ASDF文件中。 为了增加最终互相关函数的信噪比（SNR）（更多详细信息，请参见Seats等，2012），我们将整天的序列分成了较小的段，每个<code>cc_len</code>长， 相邻段之间有部分重叠。 如果在下载过程中需要保存中间输出/操作时间，则可能需要将<code>flag</code>设置为<code>True</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python S0A_download_ASDF_MPI.py</span><br></pre></td></tr></table></figure>
<p>如果要使用多个内核（例如4个），请使用以下命令（使用mpi4py包）运行脚本。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mpirun -n 4 python S0A_download_ASDF_MPI.py</span><br></pre></td></tr></table></figure>
<p>从S0A输出的文件包括包含每日（24h）连续噪声数据的ASDF文件，在S0A脚本中记录所有使用的参数的参数文件以及所有电台信息的CSV文件（有关读取带有下载数据的ASDF文件的更多详细信息 可以在docs / src / ASDF.md中找到）。 可以使用src目录中名为plotting_modules的绘图模块显示存储在ASDF文件中的连续波形数据，如下所示。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> plotting_modules <span class="comment">#(cd to your source file directory first before loading this module)</span></span><br><span class="line">sfile = <span class="string">'/RAW_DATA/2016_07_01_00_00_00T2016_07_02_00_00_00.h5'</span></span><br><span class="line">plotting_modules.plot_waveform(sfile,<span class="string">'CI'</span>,<span class="string">'BLC'</span>,<span class="number">0.01</span>,<span class="number">0.4</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/2020/12/27/NoisePy001/waveform3.png" alt="waveform3"><br>
请注意，该脚本还提供了从现有台站列表下载数据的选项，其格式与输出的CSV文件相同。 在这种情况下，应该在<code>L53</code>将<code>down_list</code>设置为<code>True</code>。</p>
<p>实际上，下载速度取决于许多因素，例如目标数据的原始采样率，网络，托管该数据的数据中心以及要存储在计算机上的一般结构等。我们测试了许多评估其性能的参数，读者可参考我们的论文以获取更多详细信息（Jiang等人，2019）。</p>
<h3 id="0B-使用S0B-sacMSEED-to-ASDF-py处理本地SAC-缩小文件">0B. 使用<code>S0B_sacMSEED_to_ASDF.py</code>处理本地SAC /缩小文件</h3>
<p>如果要使用<code>NoisePy</code>处理存储在自己磁盘上的SAC /缩小格式的本地数据，则需要使用此脚本。 大多数变量与S0A的变量相同，因此应该很容易理解和更改。</p>
<p>在此脚本中，它将通过合并，去趋势，去斜，下采样然后进行修整来对数据进行预处理，然后再将其保存为ASDF格式以用于以后的<code>NoisePy</code>处理。 特别是，我们希望脚本能够处理非常混乱的数据，这意味着地震数据会被分解成小块，并且混乱的时间信息（例如重叠的时间）会被分解。 <strong>记住，当数据混乱时，将<code>L62</code>处的<code>messydata</code>设置为<code>True</code>！ （有关删除仪器响应的教程）</strong></p>
<h3 id="1-使用S1-fft-cc-MPI-py-执行互相关">1. 使用<code>S1_fft_cc_MPI.py</code> 执行互相关</h3>
<p>这是NoisePy的核心脚本，该脚本首先对所有噪声数据执行傅立叶变换，然后将它们加载到内存中，然后再进行进一步的互相关。</p>
<p>这意味着互相关是在频率域进行的。 在脚本中，我们提供了几种计算互相关的选项，包括<code>raw</code>，<code>coherency</code>和<code>deconv</code>（有关详细定义，请参见我们的论文*）。 我们在这里以<code>coherency</code>为例。</p>
<p>运行脚本后，它将创建一个名为<code>CCF</code>的新文件夹，在其中放置了包含不同工作站对之间所有互相关函数的新ASDF文件。 它还创建一个<code>fft_cc_data.txt</code>参数文件，该文件记录了此脚本中使用的所有有用参数。</p>
<p>一旦获得互相关文件，就可按以下方式在<code>plotting_modules</code>中调用<code>plot_substack_cc</code>函数来显示所有<strong>站对</strong>之间的每日时间变化。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> plotting_modules</span><br><span class="line">sfile = <span class="string">'/2016_07_01_00_00_00T2016_07_02_00_00_00.h5'</span></span><br><span class="line">plot_modules.plot_substack_cc(sfile,<span class="number">0.1</span>,<span class="number">0.2</span>,<span class="number">200</span>,<span class="literal">True</span>,<span class="string">'/Users/chengxin/Documents/SCAL/CCF/figures'</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/2020/12/27/NoisePy001/substack_cc_ZZ.png" alt="waveform3"></p>
<h3 id="2-使用S2-stacking-py叠加">2. 使用<code>S2_stacking.py</code>叠加</h3>
<p>该脚本用于叠加S1中所有台站对的互相关函数，并将它们保存到ASDF文件中以供将来分析（例如，时间变化和/或频散提取）。 特别地，叠加过程有两种选择，包括线性和相位加权堆叠（pws）。 通常，pws产生的波形具有高SNR，下面的快照显示了两种叠加方法的波形比较。 我们使用下面的命令来绘制动校正图。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> plotting_modules,glob</span><br><span class="line">sfiles = glob.glob(<span class="string">'/SCAL/STACK/*/*.h5'</span>)</span><br><span class="line">plot_modules.plot_all_moveout(sfiles,<span class="string">'Allstack_linear'</span><span class="number">0.1</span>,<span class="number">0.2</span>,<span class="string">'ZZ'</span>,<span class="number">1</span>,<span class="number">300</span>,<span class="literal">True</span>,<span class="string">'/SCAL/STACK'</span>) <span class="comment">#(move-out for linear stacking)</span></span><br><span class="line">plot_modules.plot_all_moveout(sfiles,<span class="string">'Allstack_pws'</span><span class="number">0.1</span>,<span class="number">0.2</span>,<span class="string">'ZZ'</span>,<span class="number">1</span>,<span class="number">300</span>,<span class="literal">True</span>,<span class="string">'/SCAL/STACK'</span>)    <span class="comment">#(move-out for pws)</span></span><br></pre></td></tr></table></figure>
<p><img src="/2020/12/27/NoisePy001/linear_stack1.png" alt="waveform3"><br>
<img src="/2020/12/27/NoisePy001/pws_stack1.png" alt="waveform3"><br>
无论如何，这里仅给出一个简单的示例，说明NoisePy可能如何工作！<br>
我们强烈建议您下载NoisePy软件包并自行探索！<br>
如果在运行代码期间有任何意见和/或建议，请不要犹豫通过电子邮件与我们联系，或在<a href="https://github.com/mdenolle/NoisePy" target="_blank" rel="noopener">此github页面</a>中创建issue！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Chengxin Jiang (chengxin_jiang@fas.harvard.edu)</span><br><span class="line">Marine Denolle (mdenolle@fas.harvard.edu).</span><br></pre></td></tr></table></figure>
<h3 id="参考文献">参考文献</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Seats, K. J., Jesse F. L., and German A. P. &quot;Improved ambient noise correlation functions using Welch′ s method.&quot; Geophysical Journal International 188, no. 2 (2012): 513-523.</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*Jiang, C. and Denolle, M. &quot;NoisePy: a new high-performance python tool for seismic ambient noise seismology.&quot; Seismological Research Letter 91, no. 3 (2020): 1853–1866..</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">** Yuan, C., Bryan, J. T., Jiang, C., Okubo, K., Clements, T. and Denolle, M. (2019). Comparing approaches to measuring time- and frequency-dependent seismic phase variations for coda wave interferometry. In AGU Fall Meeting 2019.</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>obspy</category>
      </categories>
      <tags>
        <tag>天然地震</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS下Anaconda及Tensorflow安装</title>
    <url>/2020/06/11/install_atk/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1>CentOS7下深度学习环境配置（Anaconda+Tensorflow+Keras）#</h1>
<h2 id="硬件信息查询">硬件信息查询</h2>
<p>笔者的CPU和GPU型号分别如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cat /proc/cpuinfo |grep name|cut -f2 -d:|uniq -c <span class="comment">#查看CPU型号</span></span><br><span class="line"> 12  Intel(R) Xeon(R) E-2286G CPU @ 4.00GHz</span><br><span class="line">$ lspci | grep -i nvidia 查看连接的GPU设备</span><br><span class="line">01:00.0 VGA compatible controller: NVIDIA Corporation TU102 [GeForce RTX 2080 Ti Rev. A] (rev a1)</span><br><span class="line">01:00.1 Audio device: NVIDIA Corporation TU102 High Definition Audio Controller (rev a1)</span><br><span class="line">01:00.2 USB controller: NVIDIA Corporation TU102 USB 3.1 Host Controller (rev a1)</span><br><span class="line">01:00.3 Serial bus controller [0c80]: NVIDIA Corporation TU102 USB Type-C UCSI Controller (rev a1)</span><br><span class="line"><span class="comment">#如果CUDA和驱动已经安装完成并且～/.bashrc也配置完成则可以通过 nvidia-smi 查询驱动及GPU信息。</span></span><br><span class="line">$ nvidia-smi <span class="comment">#输出GPU运行状态及驱动版本</span></span><br><span class="line">Tue Jun  9 11:30:14 2020       </span><br><span class="line">+-----------------------------------------------------------------------------+</span><br><span class="line">| NVIDIA-SMI 440.82       Driver Version: 440.82       CUDA Version: 10.2     |</span><br><span class="line">|-------------------------------+----------------------+----------------------+</span><br><span class="line">| GPU  Name        Persistence-M| Bus-Id        Disp.A | Volatile Uncorr. ECC |</span><br><span class="line">| Fan  Temp  Perf  Pwr:Usage/Cap|         Memory-Usage | GPU-Util  Compute M. |</span><br><span class="line">|===============================+======================+======================|</span><br><span class="line">|   0  GeForce RTX 208...  Off  | 00000000:01:00.0  On |                  N/A |</span><br><span class="line">| 66%   84C    P2   233W / 250W |  10969MiB / 11016MiB |     91%      Default |</span><br><span class="line">+-------------------------------+----------------------+----------------------+</span><br></pre></td></tr></table></figure>
<p>另外，对于 <strong>CUDA</strong> 和 <strong>cuDNN</strong> 版本的查询可通过以下方式进行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ nvcc --version <span class="comment">#查询cuda版本</span></span><br><span class="line">nvcc: NVIDIA (R) Cuda compiler driver</span><br><span class="line">Copyright (c) 2005-2018 NVIDIA Corporation</span><br><span class="line">Built on Sat_Aug_25_21:08:01_CDT_2018</span><br><span class="line">Cuda compilation tools, release 10.0, V10.0.130</span><br><span class="line"><span class="comment">#或者</span></span><br><span class="line">$ cat /usr/<span class="built_in">local</span>/cuda/version.txt</span><br><span class="line">CUDA Version 10.0.130</span><br><span class="line">$ cat /usr/<span class="built_in">local</span>/cuda/include/cudnn.h | grep CUDNN_MAJOR -A 2 <span class="comment">#查询cudnn版本</span></span><br><span class="line"><span class="comment">#define CUDNN_MAJOR 7</span></span><br><span class="line"><span class="comment">#define CUDNN_MINOR 6</span></span><br><span class="line"><span class="comment">#define CUDNN_PATCHLEVEL 5</span></span><br><span class="line">--</span><br><span class="line"><span class="comment">#define CUDNN_VERSION (CUDNN_MAJOR * 1000 + CUDNN_MINOR * 100 + CUDNN_PATCHLEVEL)</span></span><br><span class="line"><span class="comment">#include "driver_types.h"</span></span><br></pre></td></tr></table></figure>
<h2 id="Anaconda-安装">Anaconda 安装</h2>
<p>64位Linux的 <strong>Anacoda</strong> 安装包可以到<a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/" target="_blank" rel="noopener">清华源</a>上下载，笔者下载安装的是5.3.1版本（<a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/Anaconda3-5.3.1-Linux-x86_64.sh" target="_blank" rel="noopener">下载地址</a>），文件格式为 <strong>.sh</strong>，安装包下载完成后，我们进入到下载目录中，打开 <strong>terminal</strong> 并输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ bash Anaconda3-5.3.1-Linux-x86_64.sh -u <span class="comment"># -u可自定义安装目录</span></span><br><span class="line"><span class="comment">#进入安装后敲回车,直到出现界面并输入yes继续安装或者no退出安装:</span></span><br><span class="line">$ Please answer <span class="string">'yes'</span> or <span class="string">'no'</span>:<span class="string">'</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; yes</span></span><br><span class="line"><span class="string">Anaconda3 will now be installed into this location:</span></span><br><span class="line"><span class="string">/当前将要安装的目录</span></span><br><span class="line"><span class="string">  - Press ENTER to confirm the location</span></span><br><span class="line"><span class="string">  - Press CTRL-C to abort the installation</span></span><br><span class="line"><span class="string">  - Or specify a different location below</span></span><br><span class="line"><span class="string">[/home/wangsw/anaconda3] &gt;&gt;&gt; /此处输入你需要安装的目录</span></span><br><span class="line"><span class="string">#部分目录需要其它用户或者root权限，确认之后之后将会完成安装，最后会提示是否需要将Anaconda路径写入环境变量（推荐自动写入）以及是否需要使用VSCode（根据个人需要）：</span></span><br><span class="line"><span class="string">$ Do you wish the installer to initialize Anaconda3</span></span><br><span class="line"><span class="string">in your /root/.bashrc ? [yes|no]</span></span><br><span class="line"><span class="string">[no] &gt;&gt;&gt; no</span></span><br><span class="line"><span class="string">$ Do you wish to proceed with the installation of Microsoft VSCode? [yes|no]</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; no</span></span><br><span class="line"><span class="string">#此时安装已经完成。</span></span><br></pre></td></tr></table></figure>
<h2 id="conda-环境创建">conda 环境创建</h2>
<p>然后我们开始配置 <strong>conda</strong> 环境，不同 <strong>conda</strong> 环境可以安装不同 <strong>python</strong> 版本以及 <strong>tensorflow</strong> 等版本，其相当于一个容器，可用于不同需求的生产环境。为了加速 <strong>conda</strong> 环境配置过程，与安装完系统后进行相同的操作：更新下载源（可使用清华源、中科大源等）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ conda config --show <span class="comment">#输入后找到 channels 属性可查看已有下载源，若没有镜像源则执行以下命令</span></span><br><span class="line">$ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/</span><br><span class="line">$ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span><br><span class="line">$ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/</span><br><span class="line">$ conda config --<span class="built_in">set</span> show_channel_urls yes <span class="comment">#该命令可允许下载时显示源地址</span></span><br><span class="line">$ conda clean -i <span class="comment">#清除索引缓存，保证用的是镜像站提供的索引。</span></span><br><span class="line">$ conda config --show <span class="comment">#查看是否源地址是否更新完成</span></span><br></pre></td></tr></table></figure>
<p>更新完源之后我们建立深度学习环境，首先创建一个特定 <strong>python</strong> 版本的 <strong>conda</strong> 环境：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ conda create -n env_name python=3.x <span class="comment">#env_name处输入自己想要建立的环境名称，x处填写需要的python版本，笔者为了保证原有代码的可移植性，使用python3.6版本</span></span><br><span class="line">  Solving environment: \ <span class="comment">#环境配置中，耐心等待即可</span></span><br><span class="line">  <span class="comment">## Package Plan ##</span></span><br><span class="line">  environment location: /xxxxxx/Anaconda/envs/env_name</span><br><span class="line">  added / updated specs: </span><br><span class="line">    - python=3.6</span><br><span class="line"> </span><br><span class="line">The following packages will be downloaded:</span><br><span class="line">    package                    |            build</span><br><span class="line">    ---------------------------|-----------------</span><br><span class="line">    certifi-2020.4.5.2         |   py36h9f0ad1d_0         152 KB  https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge</span><br><span class="line">    ld_impl_linux-64-2.34      |       h53a641e_5         616 KB  https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge</span><br><span class="line">    ca-certificates-2020.4.5.2 |       hecda079_0         147 KB  https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge</span><br><span class="line">    ------------------------------------------------------------</span><br><span class="line">                                           Total:         914 KB</span><br><span class="line"></span><br><span class="line">The following NEW packages will be INSTALLED:</span><br><span class="line"></span><br><span class="line">    _libgcc_mutex:    0.1-conda_forge              https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge</span><br><span class="line">    _openmp_mutex:    4.5-0_gnu                    https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge</span><br><span class="line">    ca-certificates:  2020.4.5.2-hecda079_0        https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge</span><br><span class="line">    certifi:          2020.4.5.2-py36h9f0ad1d_0    https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge</span><br><span class="line">    ld_impl_linux-64: 2.34-h53a641e_5              https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge</span><br><span class="line">    libffi:           3.2.1-he1b5a44_1007          https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge</span><br><span class="line">    libgcc-ng:        9.2.0-h24d8f2e_2             https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge</span><br><span class="line">    libgomp:          9.2.0-h24d8f2e_2             https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge</span><br><span class="line">    libstdcxx-ng:     9.2.0-hdf63c60_2             https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge</span><br><span class="line">    ncurses:          6.1-hf484d3e_1002            https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge</span><br><span class="line">    openssl:          1.1.1g-h516909a_0            https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge</span><br><span class="line">    pip:              20.1.1-py_1                  https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge</span><br><span class="line">    python:           3.6.10-h8356626_1011_cpython https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge</span><br><span class="line">    python_abi:       3.6-1_cp36m                  https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge</span><br><span class="line">    readline:         8.0-hf8c457e_0               https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge</span><br><span class="line">    setuptools:       47.1.1-py36h9f0ad1d_0        https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge</span><br><span class="line">    sqlite:           3.30.1-hcee41ef_0            https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge</span><br><span class="line">    tk:               8.6.10-hed695b0_0            https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge</span><br><span class="line">    wheel:            0.34.2-py_1                  https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge</span><br><span class="line">    xz:               5.2.5-h516909a_0             https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge</span><br><span class="line">    zlib:             1.2.11-h516909a_1006         https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge</span><br><span class="line"></span><br><span class="line">Proceed ([y]/n)? <span class="comment">#输入y即可，可以看到安装包均从上文中配置的地址中下载</span></span><br><span class="line"></span><br><span class="line">Downloading and Extracting Packages</span><br><span class="line">ca-certificates-2020 | 147 KB    | <span class="comment">##################################### | 100% </span></span><br><span class="line">certifi-2020.4.5.2   | 152 KB    | <span class="comment">##################################### | 100% </span></span><br><span class="line">ld_impl_linux-64-2.3 | 616 KB    | <span class="comment">##################################### | 100% </span></span><br><span class="line">Preparing transaction: <span class="keyword">done</span></span><br><span class="line">Verifying transaction: <span class="keyword">done</span></span><br><span class="line">Executing transaction: <span class="keyword">done</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># To activate this environment, use:</span></span><br><span class="line"><span class="comment"># &gt; source activate env_name</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># To deactivate an active environment, use:</span></span><br><span class="line"><span class="comment"># &gt; source deactivate</span></span><br><span class="line"><span class="comment">#</span></span><br></pre></td></tr></table></figure>
<p>安装完成后，我们可以通过 <code>$ source activate env_name </code>来打开创建好的环境，<code>pip list</code>可查看当前环境下已经安装的轮子，<code>pip show [package_name]</code>可以查看轮子的版本等信息（输入时去掉中括号）。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(env_name)[root]$ pip list <span class="comment">#查看已安装轮子</span></span><br><span class="line">Package    Version</span><br><span class="line">---------- -------------------</span><br><span class="line">certifi    2020.4.5.2</span><br><span class="line">pip        20.1.1</span><br><span class="line">setuptools 47.1.1.post20200529</span><br><span class="line">wheel      0.34.2</span><br><span class="line">(env_name)[root]$ pip show certifi <span class="comment">#查看轮子信息</span></span><br><span class="line">Name: certifi</span><br><span class="line">Version: 2020.4.5.2</span><br><span class="line">Summary: Python package <span class="keyword">for</span> providing Mozilla<span class="string">'s CA Bundle.</span></span><br><span class="line"><span class="string">Home-page: https://certifiio.readthedocs.io/en/latest/</span></span><br><span class="line"><span class="string">Author: Kenneth Reitz</span></span><br><span class="line"><span class="string">Author-email: me@kennethreitz.com</span></span><br><span class="line"><span class="string">License: MPL-2.0</span></span><br><span class="line"><span class="string">Location: /..../Anaconda/envs/test/lib/python3.6/site-packages</span></span><br><span class="line"><span class="string">Requires: </span></span><br><span class="line"><span class="string">Required-by:</span></span><br></pre></td></tr></table></figure>
<p>同样的，为了加速 <strong>conda</strong> 环境内 <strong>pip</strong> 下载的速度我们首先更换下载源：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(env_name)[root]$ pip config <span class="built_in">set</span> global.index-url https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line">Writing to /..../.config/pip/pip.conf</span><br></pre></td></tr></table></figure>
<p>之后，可通过 <code>$pip install package</code> 的命令下载和安装轮子了（如果没有配置下载源的话，可以通过<code>$ pip install package -i https://pypi.tuna.tsinghua.edu.cn/simple</code>的方式临时使用 <strong>url</strong> 下载）。需要注意的是，该环境下安装的包只能在环境内使用，这也允许我们能够使用多个版本的生产环境，只需要<code>$ source activate env_name</code>即可。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#笔者使用的生产环境之一为：</span></span><br><span class="line">(env_name)[root]$ pip install tensorflow-gpu==1.14.0</span><br><span class="line">(env_name)[root]$ pip install keras==2.2.5</span><br><span class="line">(env_name)[root]$ pip install numpy==1.16.0</span><br><span class="line">(env_name)[root]$ <span class="built_in">source</span> deactivate <span class="comment">#退出已打开的环境env_name</span></span><br></pre></td></tr></table></figure>
<h2 id="conda-常用命令">conda 常用命令</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ conda --version <span class="comment">#查看conda版本</span></span><br><span class="line">$ conda creat -n your_env_name python==3.x <span class="comment">#创建python版本为3.x的conda环境</span></span><br><span class="line">$ conda remove --name your_env_name --all <span class="comment">#删除已创建环境</span></span><br><span class="line">$ conda create --name new_env --<span class="built_in">clone</span> old_env <span class="comment">#创建新conda环境new_env并将old_env环境复制到前者中</span></span><br><span class="line">$ <span class="built_in">source</span> activate your_env_name <span class="comment">#激活已创建环境</span></span><br><span class="line">$ <span class="built_in">source</span> deactivate <span class="comment">#退出当前窗口中已激活环境</span></span><br><span class="line">$ conda info -e  <span class="comment">#查询已安装环境</span></span><br><span class="line">$ conda install --name your_env_name package_name <span class="comment">#在指定环境your_env_name中安装package_name包（例如conda install my_env tensorflow-gpu==2.0.0）</span></span><br><span class="line">$ conda update conda <span class="comment">#（不推荐）将conda更新至最新版本，但也会更新其它相关包</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>装机</category>
      </categories>
      <tags>
        <tag>深度学习环境配置</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS下CUDA及cuDNN安装</title>
    <url>/2020/06/10/install_cudacudnn/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1>工作站CentOS-7下CUDA驱动及cuDNN安装</h1>
<h2 id="安装包选择及下载">安装包选择及下载</h2>
<ul>
<li><strong>Nvidia驱动下载：</strong> 一般不使用 <strong>CUDA</strong> 安装包中的驱动程序，而是到<a href="https://www.nvidia.cn/Download/index.aspx?lang=cn" target="_blank" rel="noopener">官方网站</a>根据 GPU 型号下载对应驱动，这里我们选择与 <strong>RTX2080Ti</strong> 对应的<a href="http://cn.download.nvidia.com/XFree86/Linux-x86_64/440.82/NVIDIA-Linux-x86_64-440.82.run" target="_blank" rel="noopener">440.82-Linux 64-bit</a>版本，笔者首先安装的驱动，然后才装的 <strong>CUDA-10.0</strong> ，理论上二者先后顺序没有强制性。若先装 <strong>CUDA</strong> 的话记住<strong>不要不要不要不要安装自带的驱动程序</strong>，否则<strong>可能会出现重启后黑屏无法进入系统等问题</strong>。<strong>Ubuntu</strong> 中一般能够通过命令行操作删除驱动和 <strong>CUDA</strong>，但在 <strong>CentOS</strong> 系统中可能会导致无法进入终端命令行字符界面，完全黑屏时最粗暴的处理办法就是重装系统，<strong>grub</strong> 中的操作方式笔者没有研究过。当然了，如果先装驱动程序后装 <strong>CUDA</strong> ，自带的驱动自然也是不需要安装的。</li>
<li><strong>CUDA Toolkit</strong> 下载：版本根据实际需要进行选择，笔者最开始接触的GPU并行编程语言的时候就已经是 <strong>v10.0</strong> 了(现在最新版本为 <strong><a href="https://developer.nvidia.com/cuda-downloads?target_os=Linux" target="_blank" rel="noopener">CUDA11</a></strong>)，本机器上安装的 <strong><a href="https://developer.nvidia.com/compute/cuda/10.0/Prod/local_installers/cuda-repo-rhel7-10-0-local-10.0.130-410.48-1.0-1.x86_64" target="_blank" rel="noopener">CUDA_10.0.130</a></strong>（<a href="https://developer.nvidia.com/cuda-toolkit-archive" target="_blank" rel="noopener">历史版本 <strong>CUDA</strong> 下载地址</a>）</li>
<li><strong>cuDNN下载</strong>：下载 <strong>cuDNN</strong> 前要先注册一个 <strong>Nvidia</strong> 账户，忘记密码的话通过官方渠道申请修改密码可能会遇到无法收到邮件的问题，这一问题暂时没有好的解决办法；如果没有账户的话直接注册一个即可，（注册账户的邮件能收到，修改密码的经常收不到，同时我们注意到官方开通了微信或者QQ登陆方式，但是我打不开。。。），<strong>cuDNN</strong> 版本与 <strong>CUDA</strong> 版本要对应上，这里笔者使用的是与 <strong>CUDA10.0</strong>对应的 <strong>cuDNN7</strong> (cudnn-10.0-linux-x64-v7.6.5.32，没有链接，刚改了密码又忘了登不上去了= =)。</li>
</ul>
<table>
<thead>
<tr>
<th>CUDA Toolkit</th>
<th>Linuxx86_64驱动版本</th>
<th>Windowsx86_64驱动版本</th>
</tr>
</thead>
<tbody>
<tr>
<td>CUDA 10.2.89</td>
<td>&gt;= 440.33</td>
<td>&gt;= 441.22</td>
</tr>
<tr>
<td>CUDA 10.1 (10.1.105 general release, and updates)</td>
<td>&gt;= 418.39</td>
<td>&gt;= 418.96</td>
</tr>
<tr>
<td>CUDA 10.0.130</td>
<td>&gt;= 410.48</td>
<td>&gt;= 411.31</td>
</tr>
<tr>
<td>CUDA 9.2 (9.2.148 Update 1)</td>
<td>&gt;= 396.37</td>
<td>&gt;= 398.26</td>
</tr>
<tr>
<td>CUDA 9.2 (9.2.88)</td>
<td>&gt;= 396.26</td>
<td>&gt;= 397.44</td>
</tr>
<tr>
<td>CUDA 9.1 (9.1.85)</td>
<td>&gt;= 390.46</td>
<td>&gt;= 391.29</td>
</tr>
<tr>
<td>CUDA 9.0 (9.0.76)</td>
<td>&gt;= 384.81</td>
<td>&gt;= 385.54</td>
</tr>
<tr>
<td>CUDA 8.0 (8.0.61 GA2)</td>
<td>&gt;= 375.26</td>
<td>&gt;= 376.51</td>
</tr>
<tr>
<td>CUDA 8.0 (8.0.44)</td>
<td>&gt;= 367.48</td>
<td>&gt;= 369.30</td>
</tr>
</tbody>
</table>
<h2 id="安装过程">安装过程</h2>
<p>在准备好以下三个文件后就可以开始安装了（最好先把它们都下载下来放到U盘里，做好多次重装系统的准备）</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cuda_10.0.130_410.48_linux.run <span class="comment">#CUDA Toolkit</span></span><br><span class="line">$ cudnn-10.0-linux-x64-v7.6.5.32.tgz <span class="comment">#cuDNN for CUDA10</span></span><br><span class="line">$ NVIDIA-Linux-x86_64-440.82.run <span class="comment">#Nvidia-driver for RTX2080Ti</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>Nvidia 驱动及CUDA安装</strong></li>
</ul>
<p>首先查看是否开启了默认的 <strong>nouveau</strong> 驱动，如果输入<code>lsmod | grep nouveau</code> 没有任何提示的话则已经关闭了该驱动，若有提示，则需要首先禁用该驱动:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root]$ cp /etc/modprobe.d/blacklist.conf /etc/modprobe.d/blacklist.conf.back <span class="comment">#备份原有黑名单(如果提示没有此文件的话可以在该目录下创建一个新的同名文件，然后再进行后续操作)</span></span><br><span class="line">[root]$ <span class="built_in">echo</span> -e <span class="string">"blacklist nouveau\noptions nouveau modeset=0"</span> &gt; /etc/modprobe.d/blacklist.conf <span class="comment">#禁用nouveau驱动</span></span><br><span class="line">[root]$ mv /boot/initramfs-$(uname -r).img /boot/initramfs-$(uname -r).img.back <span class="comment">#备份initramfs</span></span><br><span class="line">[root]$ dracut /boot/initramfs-$(uname -r).img $(uname -r) --force <span class="comment">#重建initramfs</span></span><br><span class="line">[root]$ init 6 <span class="comment">#重启</span></span><br><span class="line">[root]$ <span class="built_in">cd</span> /../../ <span class="comment">#切换到驱动所在目录</span></span><br><span class="line">[root]$ sh ./NVIDIA-Linux-x86_64-440.82.run <span class="comment">#执行安装过程(安装如果卡在Verifying archive integrity... Error in check sums 00000000 000000,重新到官网上选择自己显卡型号的驱动下载再次安装即可)</span></span><br><span class="line">[root]$ nvidia-smi <span class="comment">#查看驱动是否安装成功，若顺利输出GPU信息则成功，或者切换到Toolkit的Samples中编译并运行带着的例子，显示Result=PASS则能够顺利运行CUDA程序。</span></span><br><span class="line">[root]$ sh ./cuda_10.0.130_410.48_linux.run <span class="comment">#安装CUDA Toolkit，记住不要安装里面带着的驱动</span></span><br><span class="line">[root]$ reboot <span class="comment">#安装完成重启，顺利进入图形界面～</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>cuDNN</strong>安装</li>
</ul>
<p>话不多说直接上代码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root]$ <span class="built_in">cd</span> /../../ <span class="comment">#切换到cuDNN安装包所在目录</span></span><br><span class="line">[root]$ tar -xzvf cudnn-10.0-linux-x64-v7.6.5.32.tgz <span class="comment">#解压cudnn到当前文件夹</span></span><br><span class="line">[root]$ cp cuda/include/cudnn.h /usr/<span class="built_in">local</span>/cuda-10.0/include/</span><br><span class="line">[root]$ cp cuda/lib64/libcudnn* /usr/<span class="built_in">local</span>/cuda/lib64/</span><br><span class="line">[root]$ chmod a+r /usr/<span class="built_in">local</span>/cuda-10.0/include/cudnn.h /usr/<span class="built_in">local</span>/cuda/lib64/libcudnn*</span><br><span class="line"><span class="comment"># 系统环境下解决：以下两步为解决tensorflow运行中找不到链接文件的问题，如果CUDA版本不同请自主更改系统路径</span></span><br><span class="line">[root]$ cp /usr/<span class="built_in">local</span>/cuda-10.0/lib64/libcublas.so.10.0 /usr/<span class="built_in">local</span>/lib/libcublas.so.10.0 &amp;&amp; sudo ldconfig</span><br><span class="line">[root]$ cp /usr/<span class="built_in">local</span>/cuda-10.0/lib64/libcufft.so.10.0 /usr/<span class="built_in">local</span>/lib/libcufft.so.10.0 &amp;&amp; sudo ldconfig</span><br><span class="line"><span class="comment"># Conda环境下解决：</span></span><br><span class="line">[root]$ conda install cudatoolkit=10.0 -c https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/linux-64/ <span class="comment"># 解决思路：在conda环境中重新安装cudatoolkit和cudnn</span></span><br><span class="line">[root]$ conda install cudnn==7.6.5 -c https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/linux-64/ <span class="comment"># </span></span><br><span class="line">[username]$ vim ~/.bashrc <span class="comment">#个人账户下CUDA相关环境变量的配置</span></span><br><span class="line"><span class="comment">#--------------------------------------------------#</span></span><br><span class="line">CUDA_HOME=/usr/<span class="built_in">local</span>/cuda-10.0</span><br><span class="line">PATH=<span class="variable">$PATH</span>:/usr/<span class="built_in">local</span>/cuda-10.0/bin</span><br><span class="line">LD_LIBRARY_PATH=/usr/<span class="built_in">local</span>/cuda-10.0/lib64</span><br><span class="line"><span class="built_in">export</span> CUDA_HOME PATH LD_LIBRARY_PATH</span><br><span class="line"><span class="comment">#--------------------------------------------------#</span></span><br><span class="line">[username]$ <span class="built_in">source</span> ~/.bashrc <span class="comment">#配置完成后立即更新环境变量</span></span><br></pre></td></tr></table></figure>
<ul>
<li>查看是否安装成功</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root]$ nvcc --version <span class="comment">#查看编译器及CUDA版本</span></span><br><span class="line">[root]$ nvidia-smi <span class="comment">#查看GPU信息、驱动版本</span></span><br><span class="line">[root]$ cat /usr/<span class="built_in">local</span>/cuda/include/cudnn.h | grep CUDNN_MAJOR -A 2 <span class="comment">#查看cuDNN版本</span></span><br></pre></td></tr></table></figure>
<h2 id="进阶设置">进阶设置</h2>
<h3 id="1-安装温度监控器">1.  安装温度监控器</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root]$ yum install lm_sensors <span class="comment">#下载安装lm_sensors插件</span></span><br><span class="line">[root]$ /usr/sbin/sensors-detect <span class="comment">#运行sensors-detect配置程序</span></span><br><span class="line">[notroot]$ sensors <span class="comment">#查看已允许检测设备的当前状态</span></span><br></pre></td></tr></table></figure>
<h3 id="2-手动控制-GPU-风扇转速">2. 手动控制 <strong>GPU</strong> 风扇转速</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root]$ cp /etc/X11/xorg.conf /etc/X11/xorg.conf.back <span class="comment">#备份原有xorg配置文件</span></span><br><span class="line">[root]$ vim xorg.conf</span><br><span class="line"><span class="comment">#-----------File Start--------------#</span></span><br><span class="line">Section <span class="string">"Device"</span></span><br><span class="line">       Identifier  <span class="string">"Videocard0"</span></span><br><span class="line">       Driver      <span class="string">"nvidia"</span></span><br><span class="line">       Option <span class="string">"Coolbits"</span> <span class="string">"4"</span> <span class="comment">#增加该行内容后重启，可在Applications-other-Nvidia X Server Settings-GPU-Thermal Settings</span></span><br><span class="line">EndSection</span><br><span class="line"><span class="comment">#-----------File End--------------#</span></span><br><span class="line">[root]$ nvidia-settings -a <span class="string">"[gpu:0]/GPUFanControlState=0"</span> <span class="comment">#恢复GPU转速随温度控制</span></span><br></pre></td></tr></table></figure>
<h3 id="3-常用-GPU-相关命令">3. 常用 GPU 相关命令</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ nvidia-smi -L <span class="comment">#列出所有可使用的GPU设备</span></span><br><span class="line">$ nvidia-smi -l <span class="comment">#与nvidia-smi功能相同但带有自动刷新功能（不清空输出缓存区）</span></span><br><span class="line">$ nvidia-smi -q <span class="comment">#查看所有GPU设备信息</span></span><br><span class="line">$ nvidia-smi –pm 0/1 <span class="comment">#设置持久模式：0/DISABLED,1/ENABLED</span></span><br><span class="line">$ nvidia-smi –e 0/1 <span class="comment">#切换ECC支持：0/DISABLED, 1/ENABLED</span></span><br><span class="line">$ nvidia-smi –p 0/1 <span class="comment">#重置ECC错误计数：0/VOLATILE, 1/AGGREGATE</span></span><br><span class="line">$ nvidia-smi –c <span class="comment">#设置计算应用模式：0/DEFAULT,1/EXCLUSIVE_PROCESS,2/PROHIBITED</span></span><br><span class="line">$ nvidia-smi –r <span class="comment">#GPU复位</span></span><br><span class="line">$ nvidia-smi –vm <span class="comment">#设置GPU虚拟化模式</span></span><br><span class="line">$ nvidia-smi –ac xxx,xxx <span class="comment">#设置GPU运行的工作频率。e.g. nvidia-smi –ac2000,800</span></span><br><span class="line">$ nvidia-smi –rac <span class="comment">#0/1 将时钟频率重置为默认值</span></span><br><span class="line">$ nvidia-smi –acp <span class="comment">#切换-ac和-rac的权限要求，0/UNRESTRICTED, 1/RESTRICTED</span></span><br><span class="line">$ nvidia-smi –pl <span class="comment">#指定最大电源管理限制（瓦特）</span></span><br><span class="line">$ nvidia-smi –am 0/1 <span class="comment">#启用或禁用计数模式，0/DISABLED,1/ENABLED</span></span><br><span class="line">$ nvidia-smi –caa <span class="comment">#清除缓冲区中的所有已记录PID，0/DISABLED,1/ENABLED</span></span><br></pre></td></tr></table></figure>
<h3 id="4-动态监控">4. 动态监控</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#实际上，可以使用watch命令实现动态监控(不需要root权限)</span></span><br><span class="line">$ watch -n 1 sensors <span class="comment"># 1表示每隔一秒刷新sensors</span></span><br><span class="line">$ watch -n 1 nvidia-smi <span class="comment">#同理可动态监控GPU运行状态，以判断Tensorfow是否正确使用了GPU运行</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>装机</category>
      </categories>
      <tags>
        <tag>CUDA及cuDNN下载与安装</tag>
      </tags>
  </entry>
  <entry>
    <title>OBSpy天然地震I</title>
    <url>/2020/09/02/obspy1/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1>天然地震</h1>
<h2 id="地震数据中Channel描述">地震数据中Channel描述</h2>
<table>
<thead>
<tr>
<th>Channel</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>EHZ/EHN/EHE</td>
<td>Short Period 100 sps</td>
</tr>
<tr>
<td>BHZ/BHN/BHE</td>
<td>Broad Band 20 sps</td>
</tr>
<tr>
<td>LHZ/LHN/LHE</td>
<td>Long Period 1 sps</td>
</tr>
<tr>
<td>VHZ/VHN/VHE</td>
<td>Very Long Period 0.1 sps</td>
</tr>
<tr>
<td>BCI</td>
<td>Broad Band Calibration Signal</td>
</tr>
<tr>
<td>ECI</td>
<td>Short Period Cal</td>
</tr>
<tr>
<td>LOG</td>
<td>Console Log</td>
</tr>
<tr>
<td>ACE</td>
<td>Administrative Clock Error</td>
</tr>
<tr>
<td>LCQ</td>
<td>1hz Clock Quality</td>
</tr>
<tr>
<td>OCF</td>
<td>Opaque Configuration File</td>
</tr>
</tbody>
</table>
<h2 id="天然地震数据处理包obspy教程">天然地震数据处理包obspy教程</h2>
<p><a href="https://krischer.github.io/seismo_live_build/html/ObsPy/07_Basic_Processing_Exercise_solution_wrapper.html" target="_blank" rel="noopener">obspy教程，以Tohoku-Oki:2011-03-11日本大地震为例</a></p>
<h3 id="台站数据访问方法">台站数据访问方法</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> obspy</span><br><span class="line"><span class="keyword">from</span> obspy.clients.fdsn <span class="keyword">import</span> Client</span><br><span class="line"></span><br><span class="line">c_event = Client(<span class="string">"IRIS"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Event time.</span></span><br><span class="line">event_time = obspy.UTCDateTime(<span class="string">"2011-03-11T05:46:23.2"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Get the event information. The temporal and magnitude constraints make it unique</span></span><br><span class="line">cat = c_event.get_events(starttime=event_time - <span class="number">10</span>, endtime=event_time + <span class="number">10</span>,</span><br><span class="line">                         minmagnitude=<span class="number">9</span>)</span><br><span class="line">cat.plot()</span><br><span class="line">c = Client(<span class="string">"IRIS"</span>)</span><br><span class="line"><span class="comment"># Download station information at the response level!</span></span><br><span class="line">inv = c.get_stations(network=<span class="string">"II"</span>, station=<span class="string">"TLY"</span>, location=<span class="string">"*"</span>, channel=<span class="string">"BH?"</span>,</span><br><span class="line">                     starttime=event_time - <span class="number">60</span>, endtime=event_time + <span class="number">3600</span>,</span><br><span class="line">                     level=<span class="string">"response"</span>)</span><br><span class="line">inv.plot()</span><br><span class="line"><span class="comment"># Download 3 component waveforms.</span></span><br><span class="line"><span class="comment"># The unit of startime and endtime is seconds.</span></span><br><span class="line">st = c.get_waveforms(network=<span class="string">"II"</span>, station=<span class="string">"TLY"</span>, location=<span class="string">"*"</span>,</span><br><span class="line">                     channel=<span class="string">"BH?"</span>, starttime=event_time - <span class="number">60</span>,</span><br><span class="line">                     endtime=event_time + <span class="number">3600</span>)</span><br><span class="line"><span class="comment"># Build-in plot method</span></span><br><span class="line">st[<span class="number">0</span>].plot()</span><br><span class="line"><span class="comment"># Get the data</span></span><br><span class="line">traces = st[<span class="number">0</span>].data</span><br></pre></td></tr></table></figure>
<p>以上代码中，<code>cat</code>、<code>inv</code>和<code>st</code>的<code>plot</code>方法分别绘制了地震事件、台站位置信息以及波形信息。<br>
<img src="/2020/09/02/obspy1/cat.png" alt="cat"><br>
<img src="/2020/09/02/obspy1/inv.png" alt="inv"><br>
<img src="/2020/09/02/obspy1/trace.png" alt="trace"></p>
<h3 id="利用MassDownloader下载数据">利用MassDownloader下载数据</h3>
<p><a href="https://docs.obspy.org/packages/autogen/obspy.clients.fdsn.mass_downloader.html" target="_blank" rel="noopener">台站数据下载教程(obspy.clients.fdsn.mass_downloader)</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> obspy</span><br><span class="line"><span class="keyword">from</span> obspy.clients.fdsn.mass_downloader <span class="keyword">import</span> CircularDomain, \</span><br><span class="line">    Restrictions, MassDownloader</span><br><span class="line"></span><br><span class="line">origin_time = obspy.UTCDateTime(<span class="number">2011</span>, <span class="number">3</span>, <span class="number">11</span>, <span class="number">5</span>, <span class="number">47</span>, <span class="number">32</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Circular domain around the epicenter. This will download all data between</span></span><br><span class="line"><span class="comment"># 70 and 90 degrees distance from the epicenter. This module also offers</span></span><br><span class="line"><span class="comment"># rectangular and global domains. More complex domains can be defined by</span></span><br><span class="line"><span class="comment"># inheriting from the Domain class.</span></span><br><span class="line">domain = CircularDomain(latitude=<span class="number">37.52</span>, longitude=<span class="number">143.04</span>,</span><br><span class="line">                        minradius=<span class="number">70.0</span>, maxradius=<span class="number">90.0</span>)</span><br><span class="line"></span><br><span class="line">restrictions = Restrictions(</span><br><span class="line">    <span class="comment"># Get data from 5 minutes before the event to one hour after the</span></span><br><span class="line">    <span class="comment"># event. This defines the temporal bounds of the waveform data.</span></span><br><span class="line">    starttime=origin_time - <span class="number">5</span> * <span class="number">60</span>,</span><br><span class="line">    endtime=origin_time + <span class="number">3600</span>,</span><br><span class="line">    <span class="comment"># You might not want to deal with gaps in the data. If this setting is</span></span><br><span class="line">    <span class="comment"># True, any trace with a gap/overlap will be discarded.</span></span><br><span class="line">    reject_channels_with_gaps=<span class="literal">True</span>,</span><br><span class="line">    <span class="comment"># And you might only want waveforms that have data for at least 95 % of</span></span><br><span class="line">    <span class="comment"># the requested time span. Any trace that is shorter than 95 % of the</span></span><br><span class="line">    <span class="comment"># desired total duration will be discarded.</span></span><br><span class="line">    minimum_length=<span class="number">0.95</span>,</span><br><span class="line">    <span class="comment"># No two stations should be closer than 10 km to each other. This is</span></span><br><span class="line">    <span class="comment"># useful to for example filter out stations that are part of different</span></span><br><span class="line">    <span class="comment"># networks but at the same physical station. Settings this option to</span></span><br><span class="line">    <span class="comment"># zero or None will disable that filtering.</span></span><br><span class="line">    minimum_interstation_distance_in_m=<span class="number">10E3</span>,</span><br><span class="line">    <span class="comment"># Only HH or BH channels. If a station has HH channels, those will be</span></span><br><span class="line">    <span class="comment"># downloaded, otherwise the BH. Nothing will be downloaded if it has</span></span><br><span class="line">    <span class="comment"># neither. You can add more/less patterns if you like.</span></span><br><span class="line">    channel_priorities=[<span class="string">"HH[ZNE]"</span>, <span class="string">"BH[ZNE]"</span>],</span><br><span class="line">    <span class="comment"># Location codes are arbitrary and there is no rule as to which</span></span><br><span class="line">    <span class="comment"># location is best. Same logic as for the previous setting.</span></span><br><span class="line">    location_priorities=[<span class="string">""</span>, <span class="string">"00"</span>, <span class="string">"10"</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># No specified providers will result in all known ones being queried.</span></span><br><span class="line">mdl = MassDownloader()</span><br><span class="line"><span class="comment"># The data will be downloaded to the ``./waveforms/`` and ``./stations/``</span></span><br><span class="line"><span class="comment"># folders with automatically chosen file names.</span></span><br><span class="line">mdl.download(domain, restrictions, mseed_storage=<span class="string">"waveforms"</span>,</span><br><span class="line">             stationxml_storage=<span class="string">"stations"</span>)</span><br></pre></td></tr></table></figure>
<p>以上代码会将时间<code>origin_time</code>之前5分钟、之后1小时以内，区域范围为圆形的<code>domain</code>（以经纬度以及环形区域为限定）的数据下载到当前目录下的<code>./waveform</code>文件夹中，台站数据则存储在<code>./stations</code>中。</p>
<h3 id="本地文件读取-以-mseed为例-及显示">本地文件读取(以.mseed为例)及显示</h3>
<p>演示三通道数据读取与显示</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> obspy</span><br><span class="line"><span class="keyword">from</span> obspy.core <span class="keyword">import</span> read</span><br><span class="line">path = <span class="string">r'./waveforms/'</span></span><br><span class="line">tc = read(path+<span class="string">'AG.HHAR.00.HHE__20110311T054232Z__20110311T064732Z.mseed'</span>)</span><br><span class="line">tc += read(path+<span class="string">'AG.HHAR.00.HHN__20110311T054232Z__20110311T064732Z.mseed'</span>)</span><br><span class="line">tc += read(path+<span class="string">'AG.HHAR.00.HHZ__20110311T054232Z__20110311T064732Z.mseed'</span>)</span><br><span class="line">print(tc)</span><br><span class="line"><span class="comment"># Save plot to file</span></span><br><span class="line">tc.plot(outfile=<span class="string">'test.png'</span>)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span> Trace(s) <span class="keyword">in</span> Stream:</span><br><span class="line">AG.HHAR<span class="number">.00</span>.HHE | <span class="number">2011</span><span class="number">-03</span><span class="number">-11</span>T05:<span class="number">42</span>:<span class="number">32.000000</span>Z - <span class="number">2011</span><span class="number">-03</span><span class="number">-11</span>T06:<span class="number">47</span>:<span class="number">32.000000</span>Z | <span class="number">100.0</span> Hz, <span class="number">390001</span> samples</span><br><span class="line">AG.HHAR<span class="number">.00</span>.HHN | <span class="number">2011</span><span class="number">-03</span><span class="number">-11</span>T05:<span class="number">42</span>:<span class="number">32.000000</span>Z - <span class="number">2011</span><span class="number">-03</span><span class="number">-11</span>T06:<span class="number">47</span>:<span class="number">32.000000</span>Z | <span class="number">100.0</span> Hz, <span class="number">390001</span> samples</span><br><span class="line">AG.HHAR<span class="number">.00</span>.HHZ | <span class="number">2011</span><span class="number">-03</span><span class="number">-11</span>T05:<span class="number">42</span>:<span class="number">32.000000</span>Z - <span class="number">2011</span><span class="number">-03</span><span class="number">-11</span>T06:<span class="number">47</span>:<span class="number">32.000000</span>Z | <span class="number">100.0</span> Hz, <span class="number">390001</span> samples</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">当流中的Traces过多时，print(stream)只会打印部分Trace，此时可通过print(stream.__str__(extended=True))来打印流中的所有Trace。</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>
<p>基础绘图:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Basic plotting</span></span><br><span class="line">tc.plot()</span><br></pre></td></tr></table></figure>
<p><img src="/2020/09/02/obspy1/tc.png" alt="tc"></p>
<p>自定义绘图:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Customized Plots</span></span><br><span class="line">dt = tc[<span class="number">0</span>].stats.starttime</span><br><span class="line">tc.plot(color=<span class="string">'red'</span>, number_of_ticks=<span class="number">7</span>,</span><br><span class="line">       tick_rotation=<span class="number">5</span>, tick_format=<span class="string">'%I:%M %p'</span>,</span><br><span class="line">       starttime=dt + <span class="number">60</span>*<span class="number">60</span>, endtime=dt + <span class="number">60</span>*<span class="number">60</span> + <span class="number">120</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/2020/09/02/obspy1/tc_customized.png" alt="tc"></p>
<p>使用Matplotlib进行自定义绘图：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Custom Plotting using Matplotlib</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">fig = plt.figure()</span><br><span class="line">ax = fig.add_subplot(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">ax.plot(tc[<span class="number">0</span>].times(<span class="string">"matplotlib"</span>), tc[<span class="number">0</span>].data, <span class="string">"b-"</span>)</span><br><span class="line">ax.xaxis_date()</span><br><span class="line">fig.autofmt_xdate()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/2020/09/02/obspy1/tc_customized_mat.png" alt="tc"></p>
<p>按小时绘制一整天道记录(文件中必须含有整天的数据)：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tc = read(path+<span class="string">'BW.ALTM..EHE__20120101T000000Z__20120102T000000Z.mseed'</span>)</span><br><span class="line">tc.plot(type=<span class="string">'dayplot'</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/2020/09/02/obspy1/tc_day.png" alt="tc"></p>
<p>plot中显示地震事件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> obspy <span class="keyword">import</span> read</span><br><span class="line">st = read(<span class="string">"./BW.ALTM..EHE__20121207T000000Z__20121208T000000Z.mseed"</span>)</span><br><span class="line"><span class="comment">#st.filter("lowpass", freq=0.1, corners=2)</span></span><br><span class="line">st.plot(type=<span class="string">"dayplot"</span>, interval=<span class="number">60</span>, right_vertical_labels=<span class="literal">False</span>,</span><br><span class="line">        vertical_scaling_range=<span class="number">5e3</span>, one_tick_per_line=<span class="literal">True</span>,</span><br><span class="line">        color=[<span class="string">'k'</span>, <span class="string">'r'</span>, <span class="string">'b'</span>, <span class="string">'g'</span>], show_y_UTC_label=<span class="literal">False</span>,</span><br><span class="line">        events=&#123;<span class="string">'min_magnitude'</span>: <span class="number">6.5</span>&#125;)</span><br></pre></td></tr></table></figure>
<p><img src="/2020/09/02/obspy1/japan20121207.png" alt="tc"></p>
<h2 id="地震台站Google地图及信息查询"><a href="https://www.fdsn.org/networks/detail/II/" target="_blank" rel="noopener">地震台站Google地图</a>及信息查询</h2>
<h3 id="Network-Codes">Network Codes</h3>
<p>地震网络编码查询：<a href="https://www.fdsn.org/networks/?initial=1" target="_blank" rel="noopener">https://www.fdsn.org/networks/?initial=1</a></p>
<h3 id="Global-Seismograph-Network-IRIS-IDA">Global Seismograph Network - IRIS/IDA</h3>
<h4 id="FDSN-Network-Information">FDSN Network Information</h4>
<table>
<thead>
<tr>
<th>FDSN code</th>
<th>II</th>
<th>Network name</th>
<th>Global Seismograph Network - IRIS/IDA (GSN)</th>
</tr>
</thead>
<tbody>
<tr>
<td>Start year</td>
<td>1986</td>
<td>Operated by</td>
<td>Scripps Institution of Oceanography (SIO)</td>
</tr>
<tr>
<td>End year</td>
<td>-</td>
<td>Deployment region</td>
<td>Global</td>
</tr>
<tr>
<td>Network Website</td>
<td><a href="http://ida.ucsd.edu/" target="_blank" rel="noopener">http://ida.ucsd.edu/</a></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h4 id="Stations-in-this-Network">Stations in this Network</h4>
<table>
<thead>
<tr>
<th>Station Code</th>
<th>Station Name</th>
<th>Latitude</th>
<th>Longitude</th>
<th>Data Center(s)</th>
</tr>
</thead>
<tbody>
<tr>
<td>AAK</td>
<td>Ala Archa, Kyrgyzstan</td>
<td>42.6375</td>
<td>74.4942</td>
<td>IRISDMC</td>
</tr>
<tr>
<td>ABKT</td>
<td>Alibek, Turkmenistan</td>
<td>37.9304</td>
<td>58.1189</td>
<td>IRISDMC</td>
</tr>
<tr>
<td>ABPO</td>
<td>Ambohimpanompo, Madagascar</td>
<td>-19.018</td>
<td>47.229</td>
<td>IRISDMC</td>
</tr>
<tr>
<td>ALE</td>
<td>Alert, NU, Canada</td>
<td>82.5033</td>
<td>-62.35</td>
<td>IRISDMC</td>
</tr>
<tr>
<td>ARTI</td>
<td>Arti, Russia</td>
<td>56.3879</td>
<td>58.3849</td>
<td>IRISDMC</td>
</tr>
<tr>
<td>ARU</td>
<td>Arti, Russia</td>
<td>56.4302</td>
<td>58.5625</td>
<td>IRISDMC</td>
</tr>
<tr>
<td>ASCN</td>
<td>Butt Crater, Ascension Island</td>
<td>-7.9327</td>
<td>-14.3601</td>
<td>IRISDMC</td>
</tr>
<tr>
<td>BFO</td>
<td>Black Forest Observatory, Schiltach, Germany</td>
<td>48.3301</td>
<td>8.3296</td>
<td>IRISDMC</td>
</tr>
<tr>
<td>BORG</td>
<td>Borgarfjordur, Asbjarnarstadir, Iceland</td>
<td>64.7474</td>
<td>-21.3268</td>
<td>IRISDMC</td>
</tr>
<tr>
<td>BORK</td>
<td>Burabay, Kazakhstan</td>
<td>53.0461</td>
<td>70.3184</td>
<td>IRISDMC</td>
</tr>
<tr>
<td>BRVK</td>
<td>Borovoye, Kazakhstan</td>
<td>53.0581</td>
<td>70.2828</td>
<td>IRISDMC</td>
</tr>
<tr>
<td>CMLA</td>
<td>Cha de Macela, Sao Miguel Island, Azores</td>
<td>37.7637</td>
<td>-25.5243</td>
<td>IRISDMC</td>
</tr>
<tr>
<td>COCO</td>
<td>West Island, Cocos (Keeling) Islands</td>
<td>-12.1901</td>
<td>96.8349</td>
<td>IRISDMC</td>
</tr>
<tr>
<td>DGAR</td>
<td>Diego Garcia, Chagos Islands, Indian Ocean</td>
<td>-7.4121</td>
<td>72.4525</td>
<td>IRISDMC</td>
</tr>
<tr>
<td>EFI</td>
<td>Mount Kent, East Falkland Island</td>
<td>-51.6753</td>
<td>-58.0637</td>
<td>IRISDMC</td>
</tr>
<tr>
<td>ERM</td>
<td>Erimo, Hokkaido Island, Japan</td>
<td>42.015</td>
<td>143.1572</td>
<td>IRISDMC</td>
</tr>
<tr>
<td>ESK</td>
<td>Eskdalemuir, Scotland, UK</td>
<td>55.3167</td>
<td>-3.205</td>
<td>IRISDMC</td>
</tr>
<tr>
<td>FFC</td>
<td>Flin Flon, Canada</td>
<td>54.725</td>
<td>-101.9783</td>
<td>IRISDMC</td>
</tr>
<tr>
<td>GAR</td>
<td>Garm, Tajikistan</td>
<td>39.0052</td>
<td>70.3328</td>
<td>IRISDMC</td>
</tr>
<tr>
<td>HOPE</td>
<td>Hope Point, South Georgia Island</td>
<td>-54.2836</td>
<td>-36.4879</td>
<td>IRISDMC</td>
</tr>
<tr>
<td>IASL</td>
<td>Albuquerque Seismological Laboratory, N.Mex.</td>
<td>34.946201</td>
<td>-106.456703</td>
<td>IRISDMC</td>
</tr>
<tr>
<td>IBFO</td>
<td>Black Forest Observatory, Schiltach, Germany</td>
<td>48.331902</td>
<td>8.3311</td>
<td>IRISDMC</td>
</tr>
<tr>
<td>JTS</td>
<td>Las Juntas de Abangares, Costa Rica</td>
<td>10.2908</td>
<td>-84.9525</td>
<td>IRISDMC</td>
</tr>
<tr>
<td>KAPI</td>
<td>Kappang, Sulawesi, Indonesia</td>
<td>-5.0142</td>
<td>119.7517</td>
<td>IRISDMC</td>
</tr>
<tr>
<td>KDAK</td>
<td>Kodiak Island, Alaska, USA</td>
<td>57.7828</td>
<td>-152.5835</td>
<td>IRISDMC</td>
</tr>
<tr>
<td>KIV</td>
<td>Kislovodsk, Russia</td>
<td>43.9562</td>
<td>42.6888</td>
<td>IRISDMC</td>
</tr>
<tr>
<td>KURK</td>
<td>Kurchatov, Kazakhstan</td>
<td>50.7154</td>
<td>78.6202</td>
<td>IRISDMC</td>
</tr>
<tr>
<td>KWAJ</td>
<td>Kwajalein Atoll, Pacific Ocean</td>
<td>8.8019</td>
<td>167.613</td>
<td>IRISDMC</td>
</tr>
<tr>
<td>KWJN</td>
<td>Gagan, Kwajalein Atoll, Marshall Islands</td>
<td>9.2873</td>
<td>167.5369</td>
<td>IRISDMC</td>
</tr>
<tr>
<td>LVZ</td>
<td>Lovozero, Russia</td>
<td>67.8979</td>
<td>34.6514</td>
<td>IRISDMC</td>
</tr>
<tr>
<td>MBAR</td>
<td>Mbarara, Uganda</td>
<td>-0.6019</td>
<td>30.7382</td>
<td>IRISDMC</td>
</tr>
<tr>
<td>MSEY</td>
<td>Mahe, Seychelles</td>
<td>-4.6737</td>
<td>55.4792</td>
<td>IRISDMC</td>
</tr>
<tr>
<td>MSVF</td>
<td>Monasavu, Fiji</td>
<td>-17.7448</td>
<td>178.0528</td>
<td>IRISDMC</td>
</tr>
<tr>
<td>NIL</td>
<td>Nilore, Pakistan</td>
<td>33.6506</td>
<td>73.2686</td>
<td>IRISDMC</td>
</tr>
<tr>
<td>NNA</td>
<td>Nana, Peru</td>
<td>-11.9875</td>
<td>-76.8422</td>
<td>IRISDMC</td>
</tr>
<tr>
<td>NRIL</td>
<td>Norilsk, Russia</td>
<td>69.5049</td>
<td>88.4414</td>
<td>IRISDMC</td>
</tr>
<tr>
<td>NVS</td>
<td>Novosibirsk, Russia</td>
<td>54.8404</td>
<td>83.2346</td>
<td>IRISDMC</td>
</tr>
<tr>
<td>OBN</td>
<td>Obninsk, Russia</td>
<td>55.1146</td>
<td>36.5674</td>
<td>IRISDMC</td>
</tr>
<tr>
<td>PALK</td>
<td>Pallekele, Sri Lanka</td>
<td>7.2728</td>
<td>80.7022</td>
<td>IRISDMC</td>
</tr>
<tr>
<td>PFO</td>
<td>Pinon Flat, California, USA</td>
<td>33.6092</td>
<td>-116.4553</td>
<td>IRISDMC</td>
</tr>
<tr>
<td>RAYN</td>
<td>Ar Rayn, Saudi Arabia</td>
<td>23.5225</td>
<td>45.5032</td>
<td>IRISDMC</td>
</tr>
<tr>
<td>RPN</td>
<td>Rapanui, Easter Island, Chile</td>
<td>-27.1267</td>
<td>-109.3344</td>
<td>IRISDMC</td>
</tr>
<tr>
<td>SACV</td>
<td>Santiago Island, Cape Verde</td>
<td>14.9702</td>
<td>-23.6085</td>
<td>IRISDMC</td>
</tr>
<tr>
<td>SHEL</td>
<td>Horse Pasture, St. Helena Island</td>
<td>-15.9594</td>
<td>-5.7455</td>
<td>IRISDMC</td>
</tr>
<tr>
<td>SIMI</td>
<td>Simiganj, Tajikistan</td>
<td>38.6585</td>
<td>69.0083</td>
<td>IRISDMC</td>
</tr>
<tr>
<td>SUR</td>
<td>Sutherland, South Africa</td>
<td>-32.3797</td>
<td>20.8117</td>
<td>IRISDMC</td>
</tr>
<tr>
<td>TAU</td>
<td>Hobart, Tasmania, Australia</td>
<td>-42.9099</td>
<td>147.3204</td>
<td>IRISDMC</td>
</tr>
<tr>
<td>TLY</td>
<td>Talaya, Russia</td>
<td>51.6807</td>
<td>103.6438</td>
<td>IRISDMC</td>
</tr>
<tr>
<td>UOSS</td>
<td>Univ. of Sharjah, Sharjah, United Arab Emirates</td>
<td>24.9453</td>
<td>56.2042</td>
<td>IRISDMC</td>
</tr>
<tr>
<td>WRAB</td>
<td>Tennant Creek, NT, Australia</td>
<td>-19.9336</td>
<td>134.36</td>
<td>IRISDMC</td>
</tr>
<tr>
<td>XBFO</td>
<td>Black Forest Observatory, Schiltach, Germany</td>
<td>48.3301</td>
<td>8.3296</td>
<td>IRISDMC</td>
</tr>
<tr>
<td>XPF</td>
<td>Pinon Flat, California, USA</td>
<td>33.6092</td>
<td>-116.4533</td>
<td>IRISDMC</td>
</tr>
<tr>
<td>XPFO</td>
<td>Pinon Flat, California, USA</td>
<td>33.6107</td>
<td>-116.4555</td>
<td>IRISDMC</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>obspy</category>
      </categories>
      <tags>
        <tag>天然地震</tag>
      </tags>
  </entry>
  <entry>
    <title>styleGAN源码解读之network.py(二)</title>
    <url>/2020/07/13/styleGAN-network2/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1>styleGAN—<a href="http://network.py" target="_blank" rel="noopener">network.py</a></h1>
<h1>源码</h1>
<p>以下为network.py中Network类run方法的最后一部分。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Network</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self,</span></span></span><br><span class="line"><span class="function"><span class="params">        *in_arrays: Tuple[Union[np.ndarray, None], ...],</span></span></span><br><span class="line"><span class="function"><span class="params">        input_transform: dict = None,</span></span></span><br><span class="line"><span class="function"><span class="params">        output_transform: dict = None,</span></span></span><br><span class="line"><span class="function"><span class="params">        return_as_list: bool = False,</span></span></span><br><span class="line"><span class="function"><span class="params">        print_progress: bool = False,</span></span></span><br><span class="line"><span class="function"><span class="params">        minibatch_size: int = None,</span></span></span><br><span class="line"><span class="function"><span class="params">        num_gpus: int = <span class="number">1</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        assume_frozen: bool = False,</span></span></span><br><span class="line"><span class="function"><span class="params">        **dynamic_kwargs)</span> -&gt; Union[np.ndarray, Tuple[np.ndarray, ...], List[np.ndarray]]:</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">assert</span> len(in_arrays) == self.num_inputs</span><br><span class="line">   <span class="keyword">assert</span> <span class="keyword">not</span> all(arr <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">for</span> arr <span class="keyword">in</span> in_arrays)</span><br><span class="line">   <span class="keyword">assert</span> input_transform <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> util.is_top_level_function(input_transform[<span class="string">"func"</span>])</span><br><span class="line">   <span class="keyword">assert</span> output_transform <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> util.is_top_level_function(output_transform[<span class="string">"func"</span>])</span><br><span class="line">   output_transform, dynamic_kwargs = _handle_legacy_output_transforms(output_transform, dynamic_kwargs)</span><br><span class="line">   num_items = in_arrays[<span class="number">0</span>].shape[<span class="number">0</span>]</span><br><span class="line">   <span class="keyword">if</span> minibatch_size <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">       minibatch_size = num_items</span><br><span class="line"></span><br><span class="line">   <span class="comment"># Construct unique hash key from all arguments that affect the TensorFlow graph.</span></span><br><span class="line">   略</span><br><span class="line">   <span class="comment"># Build graph.</span></span><br><span class="line">   略</span><br><span class="line">   <span class="comment"># Run minibatches.</span></span><br><span class="line">   in_expr, out_expr = self._run_cache[key]</span><br><span class="line">   out_arrays = [np.empty([num_items] + tfutil.shape_to_list(expr.shape)[<span class="number">1</span>:], expr.dtype.name) <span class="keyword">for</span> expr <span class="keyword">in</span> out_expr]</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> mb_begin <span class="keyword">in</span> range(<span class="number">0</span>, num_items, minibatch_size):</span><br><span class="line">       <span class="keyword">if</span> print_progress:</span><br><span class="line">           print(<span class="string">"\r%d / %d"</span> % (mb_begin, num_items), end=<span class="string">""</span>)</span><br><span class="line"></span><br><span class="line">       mb_end = min(mb_begin + minibatch_size, num_items)</span><br><span class="line">       mb_num = mb_end - mb_begin</span><br><span class="line">       mb_in = [src[mb_begin : mb_end] <span class="keyword">if</span> src <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">else</span> np.zeros([mb_num] + shape[<span class="number">1</span>:]) <span class="keyword">for</span> src, shape <span class="keyword">in</span> zip(in_arrays, self.input_shapes)]</span><br><span class="line">       mb_out = tf.get_default_session().run(out_expr, dict(zip(in_expr, mb_in)))</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> dst, src <span class="keyword">in</span> zip(out_arrays, mb_out):</span><br><span class="line">           dst[mb_begin: mb_end] = src</span><br><span class="line"></span><br><span class="line">   <span class="comment"># Done.</span></span><br><span class="line">   <span class="keyword">if</span> print_progress:</span><br><span class="line">       print(<span class="string">"\r%d / %d"</span> % (num_items, num_items))</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> <span class="keyword">not</span> return_as_list:</span><br><span class="line">       out_arrays = out_arrays[<span class="number">0</span>] <span class="keyword">if</span> len(out_arrays) == <span class="number">1</span> <span class="keyword">else</span> tuple(out_arrays)</span><br><span class="line">   <span class="keyword">return</span> out_arrays</span><br><span class="line"><span class="comment">##依赖函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shape_to_list</span><span class="params">(shape: Iterable[tf.Dimension])</span> -&gt; List[Union[int, <span class="keyword">None</span>]]:</span> <span class="comment">#位于dnnlib/tflib</span></span><br><span class="line">    <span class="string">"""将TFshape转换为列表."""</span></span><br><span class="line">    <span class="keyword">return</span> [dim.value <span class="keyword">for</span> dim <span class="keyword">in</span> shape]</span><br></pre></td></tr></table></figure>
<h2 id="Run-minibatches">Run minibatches</h2>
<p><code>in_expr, out_expr</code>是两个<strong>list</strong>，由于<code>out_arrays</code>是以<code>out_expr</code>为模板创建的，所以它的<strong>shape</strong>为<code>[1, 1024, 1024, 3]</code>：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 运行pretrained.py时得到以下结果</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(in_expr)</span><br><span class="line">[&lt;tf.Tensor <span class="string">'Gs/_Run/latents_in:0'</span> shape=&lt;unknown&gt; dtype=float32&gt;, &lt;tf.Tensor <span class="string">'Gs/_Run/labels_in:0'</span> shape=&lt;unknown&gt; dtype=float32&gt;]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(out_expr)</span><br><span class="line">[&lt;tf.Tensor 'Gs/_Run/concat:0' shape=(?, 1024, 1024, 3) dtype=uint8&gt;]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(tfutil.shape_to_list(expr.shape)[<span class="number">1</span>:])</span><br><span class="line">[<span class="number">1024</span>, <span class="number">1024</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(num_items)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print([num_items] + tfutil.shape_to_list(expr.shape)[<span class="number">1</span>:])</span><br><span class="line">[<span class="number">1</span>, <span class="number">1024</span>, <span class="number">1024</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>
<p>对<code>Graph</code>中数据流以及作者所定义的<code>scope</code>感兴趣的可以进行以下操作(生成的<code>graph</code>非常清晰，可读性很强，值得学习。)</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">输出默认Grpah中op以及变量、Tensor等的名字(一般由name_scope或者variable_scope定义)到txt文件；输出Graph到Tensorboard，在终端</span></span><br><span class="line"><span class="string">中使用“tensorboard --logdir ./logpath”打开。</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'./graph_names.txt'</span>,<span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    sep=<span class="string">'\n'</span></span><br><span class="line">    test_names = [n.name <span class="keyword">for</span> n <span class="keyword">in</span> tf.get_default_graph().as_graph_def().node]</span><br><span class="line">    f.write(sep.join(test_names))</span><br><span class="line">    summary_writer = tf.summary.FileWriter(<span class="string">"log"</span>,tf.get_default_graph())</span><br></pre></td></tr></table></figure>
<p>接下来的<code>for</code>循环中，<strong>minibatch</strong>为<code>run</code>接收的一个参数，若其为<code>None</code>，则<br>
<code>minibatch_size = num_items</code>，而<code>num_items = in_arrays[0].shape[0]</code>，所以当<strong>minibatch</strong>为<code>None</code>时。<code>pretrained.py</code>执行过程中，这一<code>for</code>循环只执行一次，并且<code>mb_end</code>和<code>mb_num</code>均为<strong>1</strong>，所以<code>mb_in</code>是一个包含<code>(1,512)</code>和<code>(1,0)</code>两个<code>np.darray</code>的<code>list</code>，实质上<code>mb_in[0]==in_arrays[0]</code>(可用代码<code>(a==b).all()</code>判断两个数组是否完全相同)。<br>
<code>mb_out = tf.get_default_session().run()</code>为真正的预测过程，<code>mb_out</code>即为预测结果。接着，将<code>src(mb_out)</code>中的数据复制到<code>dst</code>中。</p>
<p>最后判断是否需要将输出以<code>list</code>的形式返回。至此，<code>run</code>函数成功返回，实质上整个run中最关键的一句是<code>tf.get_default_session().run()</code>，它获取了默认会话的<code>op</code>和数据流，并将<code>in_expr</code>和<code>mb_in</code><strong>feed</strong>给网络。</p>
<p>注：<code>tf.Tensor</code>的尺寸可以通过<code>for dim in tf.Tensor.shape: print(dim.value)</code>来获取，<code>batches</code>的<code>？</code>实际上为<code>None</code>。</p>
<h1>get_output_for</h1>
<p><code>get_output_for</code>为类<code>Network</code>中的另一个方法</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_output_for</span><span class="params">(self, *in_expr: TfExpression, return_as_list: bool = False, **dynamic_kwargs)</span> -&gt; Union[TfExpression, List[TfExpression]]:</span></span><br><span class="line">    <span class="string">"""Construct TensorFlow expression(s) for the output(s) of this network, given the input expression(s)."""</span></span><br><span class="line">    <span class="keyword">assert</span> len(in_expr) == self.num_inputs</span><br><span class="line">    <span class="keyword">assert</span> <span class="keyword">not</span> all(expr <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">for</span> expr <span class="keyword">in</span> in_expr)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Finalize build func kwargs.</span></span><br><span class="line">    build_kwargs = dict(self.static_kwargs)</span><br><span class="line">    build_kwargs.update(dynamic_kwargs)</span><br><span class="line">    build_kwargs[<span class="string">"is_template_graph"</span>] = <span class="literal">False</span></span><br><span class="line">    build_kwargs[<span class="string">"components"</span>] = self.components</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Build TensorFlow graph to evaluate the network.</span></span><br><span class="line">    <span class="keyword">with</span> tfutil.absolute_variable_scope(self.scope, reuse=<span class="literal">True</span>), tf.name_scope(self.name):</span><br><span class="line">        <span class="keyword">assert</span> tf.get_variable_scope().name == self.scope</span><br><span class="line">        valid_inputs = [expr <span class="keyword">for</span> expr <span class="keyword">in</span> in_expr <span class="keyword">if</span> expr <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>]</span><br><span class="line">        final_inputs = []</span><br><span class="line">        <span class="keyword">for</span> expr, name, shape <span class="keyword">in</span> zip(in_expr, self.input_names, self.input_shapes):</span><br><span class="line">            <span class="keyword">if</span> expr <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                expr = tf.identity(expr, name=name)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                expr = tf.zeros([tf.shape(valid_inputs[<span class="number">0</span>])[<span class="number">0</span>]] + shape[<span class="number">1</span>:], name=name)</span><br><span class="line">            final_inputs.append(expr)</span><br><span class="line">        out_expr = self._build_func(*final_inputs, **build_kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Propagate input shapes back to the user-specified expressions.</span></span><br><span class="line">    <span class="keyword">for</span> expr, final <span class="keyword">in</span> zip(in_expr, final_inputs):</span><br><span class="line">        <span class="keyword">if</span> isinstance(expr, tf.Tensor):</span><br><span class="line">            expr.set_shape(final.shape)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Express outputs in the desired format.</span></span><br><span class="line">    <span class="keyword">assert</span> tfutil.is_tf_expression(out_expr) <span class="keyword">or</span> isinstance(out_expr, tuple)</span><br><span class="line">    <span class="keyword">if</span> return_as_list:</span><br><span class="line">        out_expr = [out_expr] <span class="keyword">if</span> tfutil.is_tf_expression(out_expr) <span class="keyword">else</span> list(out_expr)</span><br><span class="line">    <span class="keyword">return</span> out_expr</span><br><span class="line"><span class="comment">## 以上函数涉及到的其它模块</span></span><br><span class="line">TfExpression = Union[tf.Tensor, tf.Variable, tf.Operation]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_tf_expression</span><span class="params">(x: Any)</span> -&gt; bool:</span></span><br><span class="line">    <span class="keyword">return</span> isinstance(x, (tf.Tensor, tf.Variable, tf.Operation))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">absolute_variable_scope</span><span class="params">(scope: str, **kwargs)</span> -&gt; tf.variable_scope:</span></span><br><span class="line">    <span class="keyword">return</span> tf.variable_scope(tf.VariableScope(name=scope, **kwargs), auxiliary_name_scope=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>
<p><code>TfExpression</code>被定义为有效的<strong>TF</strong>表达，它是一个<code>typing.Union</code>，其中包括了<code>tf.Tensor</code>, <code>tf.Variable</code>, <code>tf.Operation</code>。然后我们看一下字典的<code>update</code>方法：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = &#123;<span class="string">'1'</span>: <span class="number">11</span>,<span class="string">'2'</span>: <span class="number">22</span>,<span class="string">'3'</span>: <span class="number">33</span>,&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = &#123;<span class="string">'2'</span>: <span class="number">33</span>,<span class="string">'4'</span>: <span class="number">44</span>,<span class="string">'5'</span>: <span class="number">55</span>,<span class="string">'6'</span>: <span class="number">66</span>,&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.update(b)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(a)</span><br><span class="line">&#123;<span class="string">'1'</span>: <span class="number">11</span>, <span class="string">'2'</span>: <span class="number">33</span>, <span class="string">'3'</span>: <span class="number">33</span>, <span class="string">'4'</span>: <span class="number">44</span>, <span class="string">'5'</span>: <span class="number">55</span>, <span class="string">'6'</span>: <span class="number">66</span>&#125;</span><br><span class="line"><span class="comment"># 将字典b添加到a中，若有重复的key则用前者的value覆盖后者。</span></span><br></pre></td></tr></table></figure>
<p>关于<code>scope</code>的使用可以参考<a href="https://blog.geophyai.com/2020/07/12/tf_name_scope_variable_scope_new/">tensorflow之scope使用</a>，它能够控制变量名称的作用域，并且实现变量的重用，在神经网络比较复杂的情况下应用能够使<code>Tensorboard</code>绘制的<code>graph</code>更清晰，便于我们进行<strong>debug</strong>。</p>
<p>首先， <code>assert</code>语句获取了当前的变量作用域并判断其是否与<code>self.scope</code>相同，然后从<code>in_expr</code>中取出不为<code>None</code>的值<code>expr</code>作为有效输入存储在列表<code>valid_inputs</code>中。接下来改变了变量作用域，这里使用的<code>tf.identity</code>非常重要，它将变量、节点和<code>graph</code>流程计算联系在一起；运行<code>pretrained.py</code>时，第一次调用<code>get_output_for</code>会将<code>G/latents_in</code>和<code>G/labels_in</code>映射到<code>G/G_mapping/latents_in</code>和<code>G/G_mapping/labels_in</code>，即改变了变量的作用域。另外，由于设置了<code>reuse=True</code>，所以<code>valid_inputs</code>会重用<code>in_expr</code>变量。我们通过一个简单的示例来看一下这些操作所产生的效果：</p>
<h1>发生了什么</h1>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 仿照源码生成相同的scope和变量</span></span><br><span class="line"><span class="keyword">from</span> tensorflow.python.framework.tensor_shape <span class="keyword">import</span> unknown_shape</span><br><span class="line"><span class="keyword">with</span> tf.device(<span class="string">'/gpu:0'</span>):</span><br><span class="line">    <span class="keyword">with</span> tf.name_scope(<span class="string">"G"</span>):</span><br><span class="line">        in_expr=[tf.placeholder(float, shape = unknown_shape(), name = <span class="string">"latents_in"</span>), </span><br><span class="line">                 tf.placeholder(float, shape = unknown_shape(), name = <span class="string">"labels_in"</span>)]<span class="comment">#与源码相同，创建一个包含两个未知shapeTensor的列表</span></span><br><span class="line">        input_shapes=[[<span class="literal">None</span>, <span class="number">512</span>], [<span class="literal">None</span>, <span class="number">0</span>]]</span><br><span class="line">        input_names = [<span class="string">'latents_in'</span>, <span class="string">'labels_in'</span>]</span><br><span class="line">        scope = <span class="string">'G_mapping'</span></span><br><span class="line">        name = <span class="string">'G_mapping'</span></span><br><span class="line">        <span class="keyword">with</span> absolute_variable_scope(scope, reuse=<span class="literal">True</span>), tf.name_scope(name):</span><br><span class="line">         <span class="comment"># reuse: 设置变量重用，当多次调用此函数时，若变量已经存在则不占用新的内存，而是将其指向同名变量的内存地址</span></span><br><span class="line">            <span class="keyword">assert</span> tf.get_variable_scope().name == scope</span><br><span class="line">            valid_inputs = [expr <span class="keyword">for</span> expr <span class="keyword">in</span> in_expr <span class="keyword">if</span> expr <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>]</span><br><span class="line">            <span class="keyword">assert</span> id(valid_inputs[<span class="number">0</span>]) == id(in_expr[<span class="number">0</span>])</span><br><span class="line">            <span class="comment"># python会重用它认为完全相同的两个变量，因此valid_inputs和in_expr</span></span><br><span class="line">            <span class="comment"># 指向了同一内存地址</span></span><br><span class="line">            final_inputs = []</span><br><span class="line">            <span class="keyword">for</span> expr, name, shape <span class="keyword">in</span> zip(in_expr, input_names, input_shapes):</span><br><span class="line">                <span class="keyword">if</span> expr <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                    print(<span class="string">'\033[31;47m before:\033[0m'</span>, name, expr)</span><br><span class="line">                    expr = tf.identity(expr, name=name)</span><br><span class="line">                    print(<span class="string">'\033[31;47m after:\033[0m'</span>, name, expr)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    expr = tf.zeros([tf.shape(valid_inputs[<span class="number">0</span>])[<span class="number">0</span>]] + shape[<span class="number">1</span>:], name=name)</span><br><span class="line">                final_inputs.append(expr)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">final_inpus: [&lt;tf.Tensor 'G/G_mapping/latents_in:0' shape=&lt;unknown&gt; dtype=float32&gt;, </span></span><br><span class="line"><span class="string">&lt;tf.Tensor 'G/G_mapping/labels_in:0' shape=&lt;unknown&gt; dtype=float32&gt;]</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>
<p><img src="/2020/07/13/styleGAN-network2/flow.png" alt="Tensorboard"></p>
<h1>tf.identity</h1>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Signature: tf.identity(input, name=None)</span></span><br><span class="line"><span class="string">Docstring:</span></span><br><span class="line"><span class="string">返回与输入具有相同尺寸以及上下文的张量。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Args:</span></span><br><span class="line"><span class="string">  input: Tensor.</span></span><br><span class="line"><span class="string">  name: op的名字.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Returns:</span></span><br><span class="line"><span class="string">  返回与输入具有相同类型的Tensor。</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">x = tf.Variable(<span class="number">0.0</span>, name = <span class="string">'x'</span>)</span><br><span class="line">plus = tf.assign_add(x, <span class="number">1</span>, name = <span class="string">'plus'</span>) <span class="comment"># 对'x'加1</span></span><br><span class="line"><span class="keyword">with</span> tf.control_dependencies([plus]):</span><br><span class="line">    y = tf.identity(x, name = <span class="string">'y'</span>) <span class="comment"># y的更新将依赖于op plus</span></span><br><span class="line">init = tf.global_variables_initializer()</span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    init.run()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">        print(sess.run(y), sess.run(x))</span><br><span class="line"><span class="comment"># [OUTPUT]:</span></span><br><span class="line"><span class="number">1.0</span> <span class="number">1.0</span></span><br><span class="line"><span class="number">2.0</span> <span class="number">2.0</span></span><br><span class="line"><span class="number">3.0</span> <span class="number">3.0</span></span><br></pre></td></tr></table></figure>
<p>以上函数中定义了一个作用在<code>x</code>上的<code>op</code>，它能够实现对变量<code>plus</code>和<code>x</code>的自增运算，<code>tf.control_dependencies([plus])</code>语境中的代码会在<code>plus</code>执行之后(即自增运算后)才执行，也就是<code>sess.run(y)</code>的运行会依赖于<code>plus</code>。<br>
<img src="/2020/07/13/styleGAN-network2/tfidentity.png" alt="Tensorboard"></p>
<h1>_build_func</h1>
<p>这里的<code>_build_func</code>即为<code>G_mapping</code>,<code>G_synthesis</code>或者<code>G_style</code>函数，源码位于<code>training/networks_stylegan.py</code>中，数据流动如下所示：<br>
<code>set_shape</code>可以改变<code>placeholder</code>的尺寸：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>test = tf.placeholder(float, shape = unknown_shape(), name = <span class="string">"Test"</span>)</span><br><span class="line"><span class="comment"># test.get_shape()= &lt;unknown&gt;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>test.set_shape([<span class="number">3</span>, <span class="number">512</span>, <span class="number">512</span>])</span><br><span class="line"><span class="comment"># 这实际上涉及到张量流中动态形状和静态形状的概念，张量在graph图的流动过程中</span></span><br><span class="line"><span class="comment"># 形状是可能发生变化的</span></span><br><span class="line"><span class="comment"># 只有当变量存在至少一个维度不确定(为None或?)时才可以使用set_shape</span></span><br><span class="line"><span class="comment"># test.get_shape()= (3, 512, 512) 修改一次后不可再用set_shape改变形状</span></span><br></pre></td></tr></table></figure>
<p>expr.set_shape(final.shape)即将输入的没有形状(unknown)的张量设置为期望形状<code>[final.shape for final in final_inputs]</code>。</p>
<h1>Return</h1>
<p><code>return out_expr</code>返回生成的高分辨率图像。</p>
]]></content>
      <categories>
        <category>GAN</category>
      </categories>
      <tags>
        <tag>styleGAN</tag>
      </tags>
  </entry>
  <entry>
    <title>styleGAN源码解读之network.py(一)</title>
    <url>/2020/07/11/styleGAN-network1/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1><a href="http://styleGAN---network.py" target="_blank" rel="noopener">styleGAN---network.py</a></h1>
<h1>源码</h1>
<p>源码文件位于<code>dnnlib/tflib</code>中过长，将近<strong>600</strong>行，这里只放出<strong>Network</strong>类中部分函数，当存在函数调用关系时再给出相应的源码及其解读。(在代码的复制粘贴过程中源代码格式遭到破坏(排版出现问题)，请勿直接复制以下代码，如有需要请下载<a href="https://github.com/NVlabs/stylegan" target="_blank" rel="noopener">源代码&lt;Github项目链接&gt;</a>。另外，文中对run方法的测试均是通过调用pretrained.py后得到的结果,在运行不同配置train.py时得到的结果可能会略有差异，一般体现在minibatch大小上。)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">﻿<span class="comment"># Copyright (c) 2019, NVIDIA CORPORATION. All rights reserved.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># This work is licensed under the Creative Commons Attribution-NonCommercial</span></span><br><span class="line"><span class="comment"># 4.0 International License. To view a copy of this license, visit</span></span><br><span class="line"><span class="comment"># http://creativecommons.org/licenses/by-nc/4.0/ or send a letter to</span></span><br><span class="line"><span class="comment"># Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Network</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self,</span></span></span><br><span class="line"><span class="function"><span class="params">        *in_arrays: Tuple[Union[np.ndarray, None], ...],</span></span></span><br><span class="line"><span class="function"><span class="params">        input_transform: dict = None,</span></span></span><br><span class="line"><span class="function"><span class="params">        output_transform: dict = None,</span></span></span><br><span class="line"><span class="function"><span class="params">        return_as_list: bool = False,</span></span></span><br><span class="line"><span class="function"><span class="params">        print_progress: bool = False,</span></span></span><br><span class="line"><span class="function"><span class="params">        minibatch_size: int = None,</span></span></span><br><span class="line"><span class="function"><span class="params">        num_gpus: int = <span class="number">1</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        assume_frozen: bool = False,</span></span></span><br><span class="line"><span class="function"><span class="params">        **dynamic_kwargs)</span> -&gt; Union[np.ndarray, Tuple[np.ndarray, ...], List[np.ndarray]]:</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">assert</span> len(in_arrays) == self.num_inputs</span><br><span class="line">   <span class="keyword">assert</span> <span class="keyword">not</span> all(arr <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">for</span> arr <span class="keyword">in</span> in_arrays)</span><br><span class="line">   <span class="keyword">assert</span> input_transform <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> util.is_top_level_function(input_transform[<span class="string">"func"</span>])</span><br><span class="line">   <span class="keyword">assert</span> output_transform <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> util.is_top_level_function(output_transform[<span class="string">"func"</span>])</span><br><span class="line">   output_transform, dynamic_kwargs = _handle_legacy_output_transforms(output_transform, dynamic_kwargs)</span><br><span class="line">   num_items = in_arrays[<span class="number">0</span>].shape[<span class="number">0</span>]</span><br><span class="line">   <span class="keyword">if</span> minibatch_size <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">       minibatch_size = num_items</span><br><span class="line"></span><br><span class="line">   <span class="comment"># Construct unique hash key from all arguments that affect the TensorFlow graph.</span></span><br><span class="line">   key = dict(input_transform=input_transform, output_transform=output_transform, num_gpus=num_gpus, assume_frozen=assume_frozen, dynamic_kwargs=dynamic_kwargs)</span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">unwind_key</span><span class="params">(obj)</span>:</span></span><br><span class="line">       <span class="keyword">if</span> isinstance(obj, dict):</span><br><span class="line">           <span class="keyword">return</span> [(key, unwind_key(value)) <span class="keyword">for</span> key, value <span class="keyword">in</span> sorted(obj.items())]</span><br><span class="line">       <span class="keyword">if</span> callable(obj):</span><br><span class="line">           <span class="keyword">return</span> util.get_top_level_function_name(obj)</span><br><span class="line">       <span class="keyword">return</span> obj</span><br><span class="line">   key = repr(unwind_key(key))</span><br><span class="line"></span><br><span class="line">   <span class="comment"># Build graph.</span></span><br><span class="line">   <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> self._run_cache:</span><br><span class="line">       <span class="keyword">with</span> tfutil.absolute_name_scope(self.scope + <span class="string">"/_Run"</span>), tf.control_dependencies(<span class="literal">None</span>):</span><br><span class="line">           <span class="keyword">with</span> tf.device(<span class="string">"/cpu:0"</span>):</span><br><span class="line">               in_expr = [tf.placeholder(tf.float32, name=name) <span class="keyword">for</span> name <span class="keyword">in</span> self.input_names]</span><br><span class="line">               in_split = list(zip(*[tf.split(x, num_gpus) <span class="keyword">for</span> x <span class="keyword">in</span> in_expr]))</span><br><span class="line"></span><br><span class="line">           out_split = []</span><br><span class="line">           <span class="keyword">for</span> gpu <span class="keyword">in</span> range(num_gpus):</span><br><span class="line">               <span class="keyword">with</span> tf.device(<span class="string">"/gpu:%d"</span> % gpu):</span><br><span class="line">                   net_gpu = self.clone() <span class="keyword">if</span> assume_frozen <span class="keyword">else</span> self</span><br><span class="line">                   in_gpu = in_split[gpu]</span><br><span class="line"></span><br><span class="line">                   <span class="keyword">if</span> input_transform <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                       in_kwargs = dict(input_transform)</span><br><span class="line">                       in_gpu = in_kwargs.pop(<span class="string">"func"</span>)(*in_gpu, **in_kwargs)</span><br><span class="line">                       in_gpu = [in_gpu] <span class="keyword">if</span> tfutil.is_tf_expression(in_gpu) <span class="keyword">else</span> list(in_gpu)</span><br><span class="line"></span><br><span class="line">                   <span class="keyword">assert</span> len(in_gpu) == self.num_inputs</span><br><span class="line">                   out_gpu = net_gpu.get_output_for(*in_gpu, return_as_list=<span class="literal">True</span>, **dynamic_kwargs)</span><br><span class="line"></span><br><span class="line">                   <span class="keyword">if</span> output_transform <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                       out_kwargs = dict(output_transform)</span><br><span class="line">                       out_gpu = out_kwargs.pop(<span class="string">"func"</span>)(*out_gpu, **out_kwargs)</span><br><span class="line">                       out_gpu = [out_gpu] <span class="keyword">if</span> tfutil.is_tf_expression(out_gpu) <span class="keyword">else</span> list(out_gpu)</span><br><span class="line"></span><br><span class="line">                   <span class="keyword">assert</span> len(out_gpu) == self.num_outputs</span><br><span class="line">                   out_split.append(out_gpu)</span><br><span class="line"></span><br><span class="line">           <span class="keyword">with</span> tf.device(<span class="string">"/cpu:0"</span>):</span><br><span class="line">               out_expr = [tf.concat(outputs, axis=<span class="number">0</span>) <span class="keyword">for</span> outputs <span class="keyword">in</span> zip(*out_split)]</span><br><span class="line">               self._run_cache[key] = in_expr, out_expr</span><br><span class="line"></span><br><span class="line">   <span class="comment"># Run minibatches.</span></span><br><span class="line">   略</span><br><span class="line">   <span class="comment"># Done.</span></span><br><span class="line">   略</span><br><span class="line">   <span class="keyword">return</span> out_arrays</span><br></pre></td></tr></table></figure>
<h1>代码微调</h1>
<p>如果你的机器环境为单节点单卡，请把以上函数中注释<code>#Build graph</code>以下的所有 <code>with tf.device()</code>设置为你的<strong>GPU</strong>，例如<code>with tf.device(&quot;/gpu:0&quot;)</code>(若只有一张显卡，其对应的设备号为<strong>0</strong>)，以下代码可以查看当前环境下可以使用的<strong>CPU/GPU</strong>设备号：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> tensorflow.python.client <span class="keyword">import</span> device_lib</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(device_lib.list_local_devices())</span><br></pre></td></tr></table></figure>
<h1>代码逐行分析</h1>
<h2 id="assert">assert</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assert</span> len(in_arrays) == self.num_inputs</span><br><span class="line"><span class="keyword">assert</span> <span class="keyword">not</span> all(arr <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">for</span> arr <span class="keyword">in</span> in_arrays)</span><br><span class="line"><span class="keyword">assert</span> input_transform <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> util.is_top_level_function(input_transform[<span class="string">"func"</span>])</span><br><span class="line"><span class="keyword">assert</span> output_transform <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> util.is_top_level_function(output_transform[<span class="string">"func"</span>])</span><br></pre></td></tr></table></figure>
<p>我们首先看一下<code>assert</code>以及<code>all</code>，<code>not all</code>的用法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># exampe1--assert</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">assert</span> <span class="number">0</span>,<span class="string">'请检查输入'</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">AssertionError: 请检查输入</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">assert</span> <span class="number">1</span>,<span class="string">'pass'</span> <span class="comment"># 无输出</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">assert</span> <span class="literal">True</span> <span class="keyword">or</span> <span class="literal">False</span> <span class="comment"># 无输出</span></span><br><span class="line"><span class="comment"># example2--all, not all</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Signature: all(iterable, /)</span></span><br><span class="line"><span class="string">Docstring:</span></span><br><span class="line"><span class="string">若可迭代变量iterable中所有的值均为True，则all(iterable)返回True。</span></span><br><span class="line"><span class="string">若iterable为空，也返回True。</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>all([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>all([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">not</span> all([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>这里，第一行的<code>assert len(in_arrays) == self.num_inputs</code>首先判断输入是否与期望输入长度相等，<strong>in_arrays</strong>为<code>tuple</code>，<code> len(in_arrays)=self.num_inputs=2</code>，<strong>in_arrays[0]</strong> 是一个<strong>size</strong>为<code>(1,512)</code>的<code>np.array</code>，<strong>n_array[1]</strong> 为<strong>Nonetype</strong>。<br>
第二行的<code>assert not all(arr is None for arr in in_arrays)</code>将对元组<strong>in_arrays</strong>中的元素进行判断，若所有元素均为<strong>Nonetype</strong>则抛出<code>AssertionError</code>。<br>
第三和第四行分别对字典<strong>input_transform</strong>以及<strong>output_transform</strong>进行判断，若其为空或者并没有加载到内存中，则抛出<code>AssertionError</code>。</p>
<h2 id="is-top-level-function">is_top_level_function</h2>
<p><strong>or</strong>之后的函数原型为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_top_level_function</span><span class="params">(obj: Any)</span> -&gt; bool:</span></span><br><span class="line">    <span class="keyword">return</span> callable(obj) <span class="keyword">and</span> obj.__name__ <span class="keyword">in</span> sys.modules[obj.__module__].__dict__</span><br></pre></td></tr></table></figure>
<p><code>is_top_level_function</code>用来判断obj是否为顶层函数，即是否是由<strong>def</strong>所定义，然后确认该函数是否已经读取到内存中。<code>sys.modules</code>是一个字典，加载到内存的模块将会以字典的形式存储在其中(第一次导入时自动记录所导入的模块为字典，第二导入则直接从字典中取出相应的键值)。(callable的应用可以查看<a href="https://www.runoob.com/python/python-func-callable.html" target="_blank" rel="noopener">链接</a>， 它用于检查一个对象是否是可调用的)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Father</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="string">"sdfsfdfs"</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line"><span class="meta">... </span>        self.name=name</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">print</span> ( <span class="string">"name: %s"</span> %( self.name) )</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">getName</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> <span class="string">'Father '</span> + self.name</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.modules[Father.__module__].__dict__</span><br><span class="line">&#123;<span class="string">'__name__'</span>: <span class="string">'__main__'</span>,</span><br><span class="line"> <span class="string">'__doc__'</span>: <span class="literal">None</span>,</span><br><span class="line"> <span class="string">'__package__'</span>: <span class="literal">None</span>,</span><br><span class="line"> '__loader__': &lt;class '_frozen_importlib.BuiltinImporter'&gt;, </span><br><span class="line"> <span class="string">'__spec__'</span>: <span class="literal">None</span>, <span class="string">'__annotations__'</span>: &#123;&#125;,</span><br><span class="line"> <span class="string">'__builtins__'</span>: &lt;module <span class="string">'builtins'</span> (built-<span class="keyword">in</span>)&gt;,</span><br><span class="line"> <span class="string">'sys'</span>: &lt;module <span class="string">'sys'</span> (built-<span class="keyword">in</span>)&gt;, </span><br><span class="line"> <span class="string">'Father'</span>: &lt;<span class="class"><span class="keyword">class</span> '<span class="title">__main__</span>.<span class="title">Father</span>'&gt;&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="handle-legacy-output-transforms">_handle_legacy_output_transforms</h2>
<p>**dynamic_kwargs 所接收的动态参数将会被存储为字典，所以<strong>output_transform</strong> 和<strong>dynamic_kwargs</strong>是两个字典，在运行pretrained.py时，二者的<strong>key</strong>和<strong>value</strong>分别为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(output_transform)</span><br><span class="line">&#123;<span class="string">'func'</span>: &lt;function convert_images_to_uint8 at <span class="number">0x7f7dd9468378</span>&gt;, <span class="string">'nchw_to_nhwc'</span>: <span class="literal">True</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(dynamic_kwargs)</span><br><span class="line">&#123;<span class="string">'truncation_psi'</span>: <span class="number">0.7</span>, <span class="string">'randomize_noise'</span>: <span class="literal">True</span>&#125;</span><br></pre></td></tr></table></figure>
<p>即分别为在<strong>Gs.run</strong>中输入的<code>(truncation_psi=0.7, randomize_noise=True, output_transform=fmt)</code></p>
<h2 id="args-和-kwargs">*args 和 **kwargs</h2>
<p>*args 和 **kwargs常用于获取函数的额外参数，通过以下的小例子我们可以清楚看出二者的区别：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">args_and_kwargs</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">    print(type(args))</span><br><span class="line">    print(args)</span><br><span class="line">    print(type(kwargs))</span><br><span class="line">    print(kwargs)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>args_and_kwargs(<span class="number">6</span>, <span class="number">8</span>, <span class="string">'im args'</span>, num1 = <span class="number">6</span>, num2 = <span class="number">8</span>, strnum = <span class="string">'im kwargs'</span>)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">tuple</span>'&gt;</span></span><br><span class="line"><span class="class"><span class="params">(<span class="number">6</span>, <span class="number">8</span>, <span class="string">'im args'</span>)</span></span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> '<span class="title">dict</span>'&gt;</span></span><br><span class="line">&#123;'num1': 6, 'num2': 8, 'strnum': 'im kwargs'&#125;</span><br></pre></td></tr></table></figure>
<h2 id="handle-legacy-output-transforms-2">_handle_legacy_output_transforms</h2>
<p>该函数对<strong>output_transform</strong>, <strong>dynamic_kwargs</strong>两字典中的值进行判断，这里我们只看运行<strong><a href="http://pretrained.py" target="_blank" rel="noopener">pretrained.py</a></strong>时该函数的内部调用情况：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">_print_legacy_warning = <span class="literal">True</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_handle_legacy_output_transforms</span><span class="params">(output_transform, dynamic_kwargs)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> _print_legacy_warning</span><br><span class="line">    legacy_kwargs = [<span class="string">"out_mul"</span>, <span class="string">"out_add"</span>, <span class="string">"out_shrink"</span>, <span class="string">"out_dtype"</span>]</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> any(kwarg <span class="keyword">in</span> dynamic_kwargs <span class="keyword">for</span> kwarg <span class="keyword">in</span> legacy_kwargs):</span><br><span class="line">        <span class="keyword">return</span> output_transform, dynamic_kwargs</span><br></pre></td></tr></table></figure>
<p>首先，<code>any</code>的用法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Signature: any(iterable, /)</span></span><br><span class="line"><span class="string">Docstring:</span></span><br><span class="line"><span class="string">若可迭代变量iterable中的任一元素为True，则返回True。</span></span><br><span class="line"><span class="string">若iterable为空，则返回False</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>test = [<span class="literal">True</span>, <span class="literal">False</span>, <span class="literal">False</span>, <span class="literal">False</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>any(test)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">not</span> any(test)</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p>所以当 <strong>dynamic_kwargs</strong>与<strong>legacy_kwargs</strong>交集为空时，则原样返回。在刚开始看到类似<strong>kwarg in dynamic_kwargs for kwarg in legacy_kwargs</strong>的代码时可能会感到困惑，我们举一个简单的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = [<span class="number">3</span>, <span class="number">4</span> ,<span class="number">5</span> ,<span class="number">6</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = [a <span class="keyword">in</span> b <span class="keyword">for</span> a <span class="keyword">in</span> c]</span><br><span class="line">[<span class="literal">True</span>, <span class="literal">True</span>, <span class="literal">False</span>, <span class="literal">False</span>]</span><br><span class="line"><span class="comment"># d等价于下列算法中的k</span></span><br><span class="line">k=[]</span><br><span class="line"><span class="keyword">for</span> a <span class="keyword">in</span> c:</span><br><span class="line">    <span class="keyword">if</span> a <span class="keyword">in</span> b:</span><br><span class="line">        k.append(<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">	k.append(<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>
<p>接下来的<code>num_items = in_arrays[0].shape[0]</code>是对获取输入<strong>latent</strong>矢量的个数(每个长度为<strong>512</strong>)。</p>
<h2 id="key">key</h2>
<p>将<strong>input_transform</strong>、<strong>output_transform</strong>、<strong>num_gpus</strong>、<strong>assume_frozen</strong>、<strong>dynamic_kwargs</strong>包装为字典，其中第一、二、五位的键值为字典，即字典中的字典。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">unwind_key</span><span class="params">(obj)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> isinstance(obj, dict):</span><br><span class="line">        <span class="keyword">return</span> [(key, unwind_key(value)) <span class="keyword">for</span> key, value <span class="keyword">in</span> sorted(obj.items())]</span><br><span class="line">    <span class="keyword">if</span> callable(obj):</span><br><span class="line">        <span class="keyword">return</span> util.get_top_level_function_name(obj)</span><br><span class="line">    <span class="keyword">return</span> obj</span><br></pre></td></tr></table></figure>
<p>接着，作者定了<code>unwind_key</code>用于“解压”字典或者函数<strong>module</strong>，这里我们先介绍第一种情况，即<strong>obj</strong>为字典：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">test = &#123;<span class="string">'k1'</span>: <span class="number">11</span>,<span class="string">'k2'</span>: <span class="number">22</span>,</span><br><span class="line">       <span class="string">'k3'</span>: &#123;<span class="string">'k1ink3'</span>: <span class="string">'value13'</span>,<span class="string">'k2ink3'</span>: <span class="string">'value23'</span>,&#125;&#125;</span><br><span class="line"><span class="comment"># 这里我们定义一个test字典，其中k1、k2和k3位于一级字典中，k1ink3和k2ink3位于k3的二级字典中</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(test)</span><br><span class="line">&#123;<span class="string">'k1'</span>: <span class="number">11</span>, <span class="string">'k2'</span>: <span class="number">22</span>, <span class="string">'k3'</span>: &#123;<span class="string">'k1ink3'</span>: <span class="string">'value13'</span>, <span class="string">'k2ink3'</span>: <span class="string">'value23'</span>&#125;&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(unwind_key(test))</span><br><span class="line">[(<span class="string">'k1'</span>, <span class="number">11</span>), (<span class="string">'k2'</span>, <span class="number">22</span>), (<span class="string">'k3'</span>, [(<span class="string">'k1ink3'</span>, <span class="string">'value13'</span>), (<span class="string">'k2ink3'</span>, <span class="string">'value23'</span>)])]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>repr(unwind_key(test))</span><br><span class="line">[(<span class="string">'k1'</span>, <span class="number">11</span>), (<span class="string">'k2'</span>, <span class="number">22</span>), (<span class="string">'k3'</span>, [(<span class="string">'k1ink3'</span>, <span class="string">'value13'</span>), (<span class="string">'k2ink3'</span>, <span class="string">'value23'</span>)])]</span><br></pre></td></tr></table></figure>
<p><code>unwind_key(test)</code>会把字典<strong>test</strong>转换为<code>list</code>，而<code>repr(unwind_key(test))</code>则将<code>unwind_key(test)</code>转换成了<code>str</code>。</p>
<h2 id="tfutil-absolute-name-scope">tfutil.absolute_name_scope</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ？</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">absolute_name_scope</span><span class="params">(scope: str)</span> -&gt; tf.name_scope:</span></span><br><span class="line">    <span class="string">"""强制进入特定scope."""</span></span><br><span class="line">    <span class="keyword">return</span> tf.name_scope(scope + <span class="string">"/"</span>)</span><br></pre></td></tr></table></figure>
<p>tfutil.absolute_name_scope(self.scope + “/_Run”)创建了一个参数命名空间，在这个语境下，所有的参数名将变为<code>“%s/_Run/variable_name”%(self.scope)</code>的形式，即变为了<code>Gs/_Run/xxx/xxx</code>的形式。</p>
<p>注：在<strong><a href="http://tfutil.py" target="_blank" rel="noopener">tfutil.py</a></strong>的<code>_sanitize_tf_config</code>函数中添加<code>cfg[&quot;log_device_placement&quot;]             = True</code>即可输出所有变量的位置(<strong>CPU/GPU</strong>)。</p>
<h2 id="tf-control-dependencies-control-inputs">tf.control_dependencies(control_inputs)</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>tf.control_dependencies(control_inputs)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Signature: tf.control_dependencies(control_inputs)</span></span><br><span class="line"><span class="string">Docstring:</span></span><br><span class="line"><span class="string">Wrapper for `Graph.control_dependencies()` using the default graph.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">See `tf.Graph.control_dependencies`</span></span><br><span class="line"><span class="string">for more details.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">当动态图机制启用时，会自动调用list`control_inputs`中的可执行对象。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Args:</span></span><br><span class="line"><span class="string">  control_inputs: op或者Tensor的列表，context中的内容会在control_inputs执行完成后才执行。也可以为‘None’来清空控制依赖</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Returns:</span></span><br><span class="line"><span class="string"> 返回一个上下文管理器。</span></span><br><span class="line"><span class="string"> """</span></span><br></pre></td></tr></table></figure>
<h2 id="in-expr-和-in-split">in_expr 和 in_split</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> tf.device(<span class="string">"/gpu:0"</span>):</span><br><span class="line">    in_expr = [tf.placeholder(tf.float32, name=name) <span class="keyword">for</span> name <span class="keyword">in</span> self.input_names]</span><br><span class="line">    in_split = list(zip(*[tf.split(x, num_gpus) <span class="keyword">for</span> x <span class="keyword">in</span> in_expr]))</span><br></pre></td></tr></table></figure>
<p>这里我做了修改，把所有变量操作都放到<strong>GPU</strong>上运行。<br>
<code>in_expr</code>是一个长度为<strong>len(input_names)</strong> 的列表，其中的每一个变量都是类型为<code>tf.float32</code>，名称为<strong>self.input_names[i]</strong> 的<code>tf.Tensor</code>。<br>
<code>in_split</code>是将<code>in_expr</code>沿<strong>minibatch</strong>方向划分为<strong>num_gpus</strong>个<code>tf.Tensor</code></p>
<h2 id="多GPU环境的graph构建">多GPU环境的graph构建</h2>
<p><code>for gpu in range(num_gpus): with tf.device(&quot;/gpu:%d&quot; % gpu):</code>即在每个GPU上执行该上下文，若只用了单卡，<code>for</code>循环不起作用且在<code>&quot;/gpu:0&quot;</code>上执行。net_gpu = <code>self.clone() if assume_frozen else self</code>，当<strong>assume_frozen</strong>为<code>False</code>时将返回实例本身（默认），当其为<code>True</code>时会调用<code>self.clone()</code>,我们做一个简单的测试：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 这里我们以源代码为模板，构造以下函数</span></span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.cpu_count = multiprocessing.cpu_count()</span><br><span class="line">        print(<span class="string">"本机共有%d个CPU。"</span>%(self.cpu_count))</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clone</span><span class="params">(self, name: str = None)</span>:</span></span><br><span class="line">        new = object.__new__(User)</span><br><span class="line">        <span class="keyword">return</span> new</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self,)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> cpu <span class="keyword">in</span> range(self.cpu_count):</span><br><span class="line">            <span class="keyword">with</span> tf.device(<span class="string">"/cpu:%d"</span>%cpu):</span><br><span class="line">                net_gpu = self.clone() <span class="keyword">if</span> <span class="literal">True</span> <span class="keyword">else</span> self</span><br><span class="line">                print(<span class="string">'/cpu:%d/%s'</span>%(cpu,str(net_gpu)))</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>test = User(<span class="string">"Test"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>test.run()</span><br><span class="line">本机共有<span class="number">12</span>个CPU。</span><br><span class="line">/cpu:<span class="number">0</span>/&lt;__main__.User object at <span class="number">0x7f4c3ceaf630</span>&gt;</span><br><span class="line">/cpu:<span class="number">1</span>/&lt;__main__.User object at <span class="number">0x7f4c3ceaf550</span>&gt;</span><br><span class="line">/cpu:<span class="number">2</span>/&lt;__main__.User object at <span class="number">0x7f4c3ceaf710</span>&gt;</span><br><span class="line">/cpu:<span class="number">3</span>/&lt;__main__.User object at <span class="number">0x7f4c3ceaf588</span>&gt;</span><br><span class="line">/cpu:<span class="number">4</span>/&lt;__main__.User object at <span class="number">0x7f4c3ceaf748</span>&gt;</span><br><span class="line">/cpu:<span class="number">5</span>/&lt;__main__.User object at <span class="number">0x7f4c3ceaf7f0</span>&gt;</span><br><span class="line">/cpu:<span class="number">6</span>/&lt;__main__.User object at <span class="number">0x7f4c3ceafa90</span>&gt;</span><br><span class="line">/cpu:<span class="number">7</span>/&lt;__main__.User object at <span class="number">0x7f4c3ceaf828</span>&gt;</span><br><span class="line">/cpu:<span class="number">8</span>/&lt;__main__.User object at <span class="number">0x7f4c3ceaf7b8</span>&gt;</span><br><span class="line">/cpu:<span class="number">9</span>/&lt;__main__.User object at <span class="number">0x7f4c3ceaf780</span>&gt;</span><br><span class="line">/cpu:<span class="number">10</span>/&lt;__main__.User object at <span class="number">0x7f4c3ce82278</span>&gt;</span><br><span class="line">/cpu:<span class="number">11</span>/&lt;__main__.User object at <span class="number">0x7f4c3ce825f8</span>&gt;</span><br></pre></td></tr></table></figure>
<p><code>in_gpu = in_split[gpu]</code>是从分割后的元组<code>in_split</code>中按照设备号来访问其中的<code>tf.Tensor</code>，也就是将整个<strong>miniBatch</strong>均匀分配到各个<strong>GPU</strong>上。<code>if input_transform is not None:</code>判断是否需要对输入做变换，<code>in_kwargs = dict(input_transform)</code>将<code>input_transform</code>存放到字典<code>in_kwargs</code>中，实质上<code>input_transform</code>也为字典，这里可能是为了避免后续的<code>pop</code>操作将<code>input_transform</code>中的值删除。对输入做完预处理之后，若<code>in_gpu</code>为<code>tf.Tensor</code>、<code>tf.Variable</code>或者<code>tf.Operation</code>中的某一个，则返回<code>[in_gpu]</code>，否则返回<code>list(in_gpu)</code>。</p>
<p><code>net_gpu.get_output_for</code>的返回值<strong>out_gpu</strong>为<code>&lt;tf.Tensor 'Gs/_Run/Gs/images_out:0' shape=(?, 3, 1024, 1024) dtype=float32&gt;</code>，由于篇幅原因我们将这一函数单独放在另一篇文章中讲解。</p>
<p>接下来的<code>output_transform</code>板块与上文中提到的<code>input_transform</code>所执行的操作比较相似，其是对输出<strong>out_gpu</strong>做了后续的处理，在运行<strong><a href="http://pretrained.py" target="_blank" rel="noopener">pretrained.py</a></strong>时，<code>run</code>函数并没有执行<code>if input_transform</code>后面的代码，因为输入中并没有给出任何关于对输入信息进行转换的关键词或列表，但是需要将输出转换为<strong>unit8</strong>，即<code>output_transform = {'func': &lt;function convert_images_to_uint8 at 0x7f9f38697378&gt;,'nchw_to_nhwc':True} </code>代码如下：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">convert_images_to_uint8</span><span class="params">(images, drange=[<span class="number">-1</span>,<span class="number">1</span>], nchw_to_nhwc=False, shrink=<span class="number">1</span>)</span>:</span></span><br><span class="line">    <span class="string">"""根据输入的动态范围drange，将一个minibatch的图像从float32类型转换为unit8。可以作为Network.run()中的输出转换使用</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    images = tf.cast(images, tf.float32)</span><br><span class="line">    <span class="keyword">if</span> shrink &gt; <span class="number">1</span>:</span><br><span class="line">        ksize = [<span class="number">1</span>, <span class="number">1</span>, shrink, shrink]</span><br><span class="line">        images = tf.nn.avg_pool(images,ksize=ksize,strides=ksize,padding=<span class="string">"VALID"</span>,data_format=<span class="string">"NWHC"</span>)</span><br><span class="line">    <span class="keyword">if</span> nchw_to_nhwc:</span><br><span class="line">        images = tf.transpose(images, [<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>])</span><br><span class="line">    scale = <span class="number">255</span> / (drange[<span class="number">1</span>] - drange[<span class="number">0</span>])</span><br><span class="line">    images = images * scale + (<span class="number">0.5</span> - drange[<span class="number">0</span>] * scale)</span><br><span class="line">    <span class="keyword">return</span> tf.saturate_cast(images, tf.uint8)</span><br></pre></td></tr></table></figure>
<p>我们来看一下上面代码块中出现的几个常用函数，首先看一下<code>tf.cast</code>以及<code>tf.saturate_cast</code>的区别：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Signature: tf.saturate_cast(value, dtype, name=None)</span></span><br><span class="line"><span class="string">Docstring:</span></span><br><span class="line"><span class="string">将value安全地转换为dtype类型，不进行任何缩放。当转换可能会出现泄露(overflow或 underflow)问题时,会首先将数据clamp到合适范围之内。</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="comment">#例如,我们要把一个float32转换为uint8类型：</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = tf.constant([<span class="number">-1</span>, <span class="number">256</span>], dtype=tf.float32)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x1 = tf.saturate_cast(x, tf.uint8)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x2 = tf.cast(x, tf.uint8)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">        dx1, dx2 = sess.run([x1, x2])</span><br><span class="line">        print(<span class="string">'tf.saturate_cast:'</span>,dx1)</span><br><span class="line">        print(<span class="string">'tf.cast:'</span>,dx2)</span><br><span class="line">tf.saturate_cast: [<span class="number">0</span> <span class="number">255</span>]</span><br><span class="line">tf.cast: [<span class="number">0</span> <span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<p>然后，<code>out_split.append(out_gpu)</code>将每个<strong>GPU</strong>得到的结果<code>out_gpu</code>添加到表<code>out_split</code>中，由<code>tf.concat(outputs, axis=0)</code>将所有结果沿<strong>minibatch</strong>方向连接，最后转化为<code>list</code>赋值给<code>out_expr</code>。</p>
]]></content>
      <categories>
        <category>GAN</category>
      </categories>
      <tags>
        <tag>styleGAN</tag>
      </tags>
  </entry>
  <entry>
    <title>styleGAN源码解读之pretrained-example.py</title>
    <url>/2020/07/07/styleGAN-pretrained-example/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1><a href="http://styleGAN---pretrained-example.py" target="_blank" rel="noopener">styleGAN---pretrained-example.py</a></h1>
<p>此代码使用预训练的styleGAN模型<a href="https://pan.baidu.com/s/15eBihbZvLZ42aToLy5iKlQ" target="_blank" rel="noopener">karras2019stylegan-ffhq-1024x1024.pkl(百度网盘，密码1q60)</a>生成器生成单张随机人脸图像。(如有需要请下载<a href="https://github.com/NVlabs/stylegan" target="_blank" rel="noopener">源代码&lt;Github项目链接&gt;</a>)</p>
<h1>源码</h1>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> PIL.Image</span><br><span class="line"><span class="keyword">import</span> dnnlib</span><br><span class="line"><span class="keyword">import</span> dnnlib.tflib <span class="keyword">as</span> tflib</span><br><span class="line"><span class="keyword">import</span> config</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># Initialize TensorFlow.</span></span><br><span class="line">    tflib.init_tf()</span><br><span class="line">    <span class="comment"># Load pre-trained network.</span></span><br><span class="line">    url = <span class="string">'https://drive.google.com/uc?id=1MEGjdvVpUsu1jB4zrXZN7Y4kBBOzizDQ'</span> <span class="comment"># karras2019stylegan-ffhq-1024x1024.pkl</span></span><br><span class="line">    <span class="keyword">with</span> dnnlib.util.open_url(url, cache_dir=config.cache_dir) <span class="keyword">as</span> f:</span><br><span class="line">        _G, _D, Gs = pickle.load(f)</span><br><span class="line">        <span class="comment"># _G = Instantaneous snapshot of the generator. Mainly useful for resuming a previous training run.</span></span><br><span class="line">        <span class="comment"># _D = Instantaneous snapshot of the discriminator. Mainly useful for resuming a previous training run.</span></span><br><span class="line">        <span class="comment"># Gs = Long-term average of the generator. Yields higher-quality results than the instantaneous snapshot.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Print network details.</span></span><br><span class="line">    <span class="comment">#Gs.print_layers()</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Pick latent vector.</span></span><br><span class="line">    rnd = np.random.RandomState(<span class="number">5</span>)</span><br><span class="line">    latents = rnd.randn(<span class="number">1</span>, Gs.input_shape[<span class="number">1</span>])</span><br><span class="line">    <span class="comment"># Generate image.</span></span><br><span class="line">    fmt = dict(func=tflib.convert_images_to_uint8, nchw_to_nhwc=<span class="literal">True</span>)</span><br><span class="line">    images = Gs.run(latents, <span class="literal">None</span>, truncation_psi=<span class="number">0.7</span>, randomize_noise=<span class="literal">True</span>, output_transform=fmt)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Save image.</span></span><br><span class="line">    os.makedirs(config.result_dir, exist_ok=<span class="literal">True</span>)</span><br><span class="line">    png_filename = os.path.join(config.result_dir, <span class="string">'example.png'</span>)</span><br><span class="line">    PIL.Image.fromarray(images[<span class="number">0</span>], <span class="string">'RGB'</span>).save(png_filename)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<h1>微调预训练模型路径后的代码</h1>
<p>由于代码中所使用的预训练模型存储在GoogleDrive上可能无法通过代码下载，因此我们提前下载下来并从本地读取。这里修改代码为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#这段代码运行在styleGAN根目录下的./ipynb/sytle_test.ipynb中</span></span><br><span class="line"><span class="keyword">import</span> os <span class="comment">#module 'os' from '/xxx/Anaconda/envs/xxx/lib/python3.6/os.py'</span></span><br><span class="line"><span class="keyword">import</span> pickle <span class="comment"># module 'pickle' from '/xxx/Anaconda/envs/xxx/lib/python3.x/pickle.py'</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np <span class="comment">#略</span></span><br><span class="line"><span class="keyword">import</span> PIL.Image <span class="comment">#略</span></span><br><span class="line"><span class="keyword">import</span> dnnlib <span class="comment"># ./dnnlib</span></span><br><span class="line"><span class="keyword">import</span> dnnlib.tflib <span class="keyword">as</span> tflib <span class="comment"># module 'dnnlib.tflib' from '../dnnlib/tflib/__init__.py'</span></span><br><span class="line"><span class="keyword">import</span> config <span class="comment"># &lt;module 'config' from '../config.py'&gt;</span></span><br><span class="line"><span class="keyword">import</span> sys <span class="comment"># module 'sys' (built-in)</span></span><br><span class="line"><span class="comment">#输入print(module_name)可查看其文件位置()</span></span><br><span class="line"><span class="comment">#例如</span></span><br><span class="line"><span class="comment">#print(dnnlib)</span></span><br><span class="line"><span class="comment">#&lt;module 'dnnlib' from '../dnnlib/__init__.py'&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 初始化Tensorflow.</span></span><br><span class="line">    tflib.init_tf()</span><br><span class="line">    <span class="comment"># 加载pkl文件，重构对象并导入预训练模型</span></span><br><span class="line">    url = <span class="string">r'/xxx/xxx/xxx/karras2019stylegan-ffhq-1024x1024.pkl'</span></span><br><span class="line">    <span class="keyword">with</span> open(url, <span class="string">'rb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        _G, _D, Gs = pickle.load(f)</span><br><span class="line">        <span class="comment"># _G = Instantaneous snapshot of the generator. Mainly useful for resuming a previous training run.</span></span><br><span class="line">        <span class="comment"># _D = Instantaneous snapshot of the discriminator. Mainly useful for resuming a previous training run.</span></span><br><span class="line">        <span class="comment"># Gs = Long-term average of the generator. Yields higher-quality results than the instantaneous snapshot.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 打印Gs网络架构，相当于tf中的.summary()，函数原型位于network.py中，是作者自定义的函数。</span></span><br><span class="line">    Gs.print_layers()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 随机生成latent.</span></span><br><span class="line">    rnd = np.random.RandomState(<span class="number">5</span>)</span><br><span class="line">    latents = rnd.randn(<span class="number">1</span>, Gs.input_shape[<span class="number">1</span>])</span><br><span class="line">    <span class="comment"># 生成图像.</span></span><br><span class="line">    fmt = dict(func=tflib.convert_images_to_uint8, nchw_to_nhwc=<span class="literal">True</span>)</span><br><span class="line">    images = Gs.run(latents, <span class="literal">None</span>, truncation_psi=<span class="number">0.7</span>, randomize_noise=<span class="literal">True</span>, output_transform=fmt)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 保存图像.</span></span><br><span class="line">    os.makedirs(config.result_dir, exist_ok=<span class="literal">True</span>)</span><br><span class="line">    png_filename = os.path.join(config.result_dir, <span class="string">'example.png'</span>)</span><br><span class="line">    PIL.Image.fromarray(images[<span class="number">0</span>], <span class="string">'RGB'</span>).save(png_filename)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<h1>函数逐行分析</h1>
<h2 id="tflib-init-tf">tflib.init_tf()</h2>
<p><strong>main</strong>函数中第一句<code>tflib.init_tf()</code>函数用于初始化<strong>tensorflow</strong>，此函数位于<strong>dnnlib/tflib/tfutil.py</strong>中,<code>init_tf()</code>所依赖的其它函数有<code>_sanitize_tf_config</code>和<code>create_session</code>,这两个函数同样位于此文件中。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 本机环境为tenforlow-gpu1.14.0,运行源代码过程中经常提示版本相关的warning</span></span><br><span class="line"><span class="comment"># 所以这里使用tensorflow.compat.v1来运行</span></span><br><span class="line"><span class="keyword">import</span> tensorflow.compat.v1 <span class="keyword">as</span> tf</span><br><span class="line"><span class="comment">#--- 初始化TF</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">init_tf</span><span class="params">(config_dict: dict = None)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">    <span class="string">"""Initialize TensorFlow session using good default settings."""</span></span><br><span class="line">    <span class="comment"># 如果已创建Seccion则退出该函数.</span></span><br><span class="line">    <span class="keyword">if</span> tf.get_default_session() <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment"># 调用_sanitize_tf_config</span></span><br><span class="line">    <span class="comment"># 设置配置字典和随机种子.</span></span><br><span class="line">    cfg = _sanitize_tf_config(config_dict)</span><br><span class="line">    np_random_seed = cfg[<span class="string">"rnd.np_random_seed"</span>]</span><br><span class="line">    <span class="keyword">if</span> np_random_seed <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        np.random.seed(np_random_seed)</span><br><span class="line">    tf_random_seed = cfg[<span class="string">"rnd.tf_random_seed"</span>]</span><br><span class="line">    <span class="keyword">if</span> tf_random_seed == <span class="string">"auto"</span>:</span><br><span class="line">        tf_random_seed = np.random.randint(<span class="number">1</span> &lt;&lt; <span class="number">31</span>)</span><br><span class="line">    <span class="keyword">if</span> tf_random_seed <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        tf.set_random_seed(tf_random_seed)</span><br><span class="line">	</span><br><span class="line">    <span class="comment"># 设置TF环境变量.</span></span><br><span class="line">    <span class="keyword">for</span> key, value <span class="keyword">in</span> list(cfg.items()):</span><br><span class="line">        fields = key.split(<span class="string">"."</span>)</span><br><span class="line">        <span class="keyword">if</span> fields[<span class="number">0</span>] == <span class="string">"env"</span>:</span><br><span class="line">            <span class="keyword">assert</span> len(fields) == <span class="number">2</span></span><br><span class="line">            os.environ[fields[<span class="number">1</span>]] = str(value)</span><br><span class="line">            </span><br><span class="line">	<span class="comment"># 调用create_session</span></span><br><span class="line">    <span class="comment"># 创建TF会话.</span></span><br><span class="line">    create_session(cfg, force_as_default=<span class="literal">True</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment">#--- 设置配置信息</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_sanitize_tf_config</span><span class="params">(config_dict: dict = None)</span> -&gt; dict:</span></span><br><span class="line">    <span class="comment"># Defaults.</span></span><br><span class="line">    cfg = dict()</span><br><span class="line">    cfg[<span class="string">"rnd.np_random_seed"</span>]               = <span class="literal">None</span>      <span class="comment"># Random seed for NumPy. None = keep as is.</span></span><br><span class="line">    cfg[<span class="string">"rnd.tf_random_seed"</span>]               = <span class="string">"auto"</span>    <span class="comment"># Random seed for TensorFlow. 'auto' = derive from NumPy random state. None = keep as is.</span></span><br><span class="line">    cfg[<span class="string">"env.TF_CPP_MIN_LOG_LEVEL"</span>]         = <span class="string">"1"</span>       <span class="comment"># 0 = Print all available debug info from TensorFlow. 1 = Print warnings and errors, but disable debug info.</span></span><br><span class="line">    cfg[<span class="string">"graph_options.place_pruned_graph"</span>] = <span class="literal">True</span>      <span class="comment"># False = Check that all ops are available on the designated device. True = Skip the check for ops that are not used.</span></span><br><span class="line">    cfg[<span class="string">"gpu_options.allow_growth"</span>]         = <span class="literal">True</span>      <span class="comment"># False = Allocate all GPU memory at the beginning. True = Allocate only as much GPU memory as needed.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># User overrides.</span></span><br><span class="line">    <span class="keyword">if</span> config_dict <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        cfg.update(config_dict)</span><br><span class="line">    <span class="keyword">return</span> cfg</span><br><span class="line">    </span><br><span class="line"><span class="comment">#--- 根据配置信息创建会话</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_session</span><span class="params">(config_dict: dict = None, force_as_default: bool = False)</span> -&gt; tf.Session:</span></span><br><span class="line">    <span class="comment"># """根据config_dict创建tf.Session."""</span></span><br><span class="line">    <span class="comment"># 设置TF配置属性.</span></span><br><span class="line">    cfg = _sanitize_tf_config(config_dict)</span><br><span class="line">    config_proto = tf.ConfigProto()</span><br><span class="line">    <span class="keyword">for</span> key, value <span class="keyword">in</span> cfg.items():</span><br><span class="line">        fields = key.split(<span class="string">"."</span>)</span><br><span class="line">        <span class="keyword">if</span> fields[<span class="number">0</span>] <span class="keyword">not</span> <span class="keyword">in</span> [<span class="string">"rnd"</span>, <span class="string">"env"</span>]:</span><br><span class="line">            obj = config_proto</span><br><span class="line">            <span class="keyword">for</span> field <span class="keyword">in</span> fields[:<span class="number">-1</span>]:</span><br><span class="line">                obj = getattr(obj, field)</span><br><span class="line">            setattr(obj, fields[<span class="number">-1</span>], value)</span><br><span class="line">    <span class="comment"># 创建会话.</span></span><br><span class="line">    session = tf.Session(config=config_proto)</span><br><span class="line">    <span class="keyword">if</span> force_as_default:</span><br><span class="line">        <span class="comment"># pylint: disable=protected-access</span></span><br><span class="line">        <span class="comment"># 将自己设置为default session</span></span><br><span class="line">        session._default_session = session.as_default()</span><br><span class="line">        session._default_session.enforce_nesting = <span class="literal">False</span></span><br><span class="line">        session._default_session.__enter__() <span class="comment"># pylint: disable=no-member</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> session</span><br></pre></td></tr></table></figure>
<p>以上函数中，<code>def init_tf(config_dict:dict=None)-&gt;None</code>定义了名为<strong>init_tf</strong>的函数：该函数接受名为<strong>config_dict</strong>的变量，<code>config_dict:dict=None</code>表示<strong>config_dict</strong>的期望类型为字典以及初始值为<strong>None</strong>；其中的冒号<code>:</code>是一种<strong>Type Annotation</strong>，其用于提示变量的类型为<code>dict</code>；<code>-&gt;</code>用于注释函数的返回类型为<strong>None</strong>。</p>
<p><code>if tf.get_default_session() is not None: return</code>用于获取当前会话(Session)，如果会话不为空则退出<code>init_tf</code>，若未创建会话则执行后续代码。</p>
<p><code>cfg=_sanitize_tf_config(config_dict)</code>调用了<code>_sanitize_tf_config</code>函数，此函数中创建了一个参数字典，我们可以通过以下方式打印其中的值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> zip(cfg.keys(), cfg.values()):</span><br><span class="line">        print(key, <span class="string">':'</span>, value)</span><br><span class="line"><span class="comment">###--------结果如下--------###</span></span><br><span class="line">rnd.np_random_seed : <span class="literal">None</span></span><br><span class="line">rnd.tf_random_seed : auto</span><br><span class="line">env.TF_CPP_MIN_LOG_LEVEL : <span class="number">1</span></span><br><span class="line">graph_options.place_pruned_graph : <span class="literal">True</span></span><br><span class="line">gpu_options.allow_growth : <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>在函数<code>_sanitize_tf_config</code>中，首先创建了名为<strong>cfg</strong>的字典:该字典中包含上个代码框中的默认<strong>key</strong>及其<strong>value</strong>，当该函数的输入变量<strong>config_dict</strong>不为空时则执行<code>cfg.update(config_dict)</code>将新的字典添加到<strong>cfg</strong>中，最后返回字典<strong>cfg</strong>。</p>
<p><strong>np_random_seed</strong>默认为<strong>None</strong> 。当<strong>tf_random_seed</strong>为**‘auto’<strong>（默认状态）时，执行<code>tf_random_seed=np.random.randint(1 &lt;&lt; 31)</code>，即生成一个小于</strong>1&lt;&lt;31=2147483648<strong>的值并赋给</strong>tf_random_seed**，若为其它非**'auto’<strong>及非</strong>None**值，则将其作为种子输入到<code>tf.set_random_seed()</code>中。</p>
<p>接下来的代码 <code>key.split(&quot;.&quot;)</code>以&quot;<strong>.</strong>&quot;分割了字典中的<strong>key</strong>并找到名为&quot;<strong>env</strong>&quot;的项，后续操作等价于<code>os.environ['TF_CPP_MIN_LOG_LEVEL']=’1‘</code>。即，将<strong>tf</strong>的<strong>log</strong>输出级别设置为1。</p>
<p><code>create_session(cfg,force_as_default=True)</code>将创建的配置信息以字典变量方式传入函数<strong>create_session</strong>并强制设置当前会话为默认会话。</p>
<p><code>obj=getattr(obj,field)</code>获取了<strong>obj</strong>的<strong>graph_options</strong>和<strong>gpu_options</strong>属性并分别设置其中的<strong>place_pruned_graph</strong>和<strong>allow_growth</strong>为<strong>True</strong>.</p>
<h2 id="Gs-print-layers">Gs.print_layers()</h2>
<p>回到主函数中,<code>Gs.print_layers()</code>结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">G                               Params    OutputShape          WeightShape     </span><br><span class="line">---                             ---       ---                  ---             </span><br><span class="line">latents_in                      -         (?, 512)             -               </span><br><span class="line">labels_in                       -         (?, 0)               -               </span><br><span class="line">lod                             -         ()                   -               </span><br><span class="line">dlatent_avg                     -         (<span class="number">512</span>,)               -               </span><br><span class="line">G_mapping/latents_in            -         (?, 512)             -               </span><br><span class="line">G_mapping/labels_in             -         (?, 0)               -               </span><br><span class="line">G_mapping/PixelNorm             -         (?, 512)             -               </span><br><span class="line">G_mapping/Dense0                262656    (?, 512)             (512, 512)      </span><br><span class="line">G_mapping/Dense1                262656    (?, 512)             (512, 512)      </span><br><span class="line">G_mapping/Dense2                262656    (?, 512)             (512, 512)      </span><br><span class="line">G_mapping/Dense3                262656    (?, 512)             (512, 512)      </span><br><span class="line">G_mapping/Dense4                262656    (?, 512)             (512, 512)      </span><br><span class="line">G_mapping/Dense5                262656    (?, 512)             (512, 512)      </span><br><span class="line">G_mapping/Dense6                262656    (?, 512)             (512, 512)      </span><br><span class="line">G_mapping/Dense7                262656    (?, 512)             (512, 512)      </span><br><span class="line">G_mapping/Broadcast             -         (?, 18, 512)         -               </span><br><span class="line">G_mapping/dlatents_out          -         (?, 18, 512)         -               </span><br><span class="line">Truncation                      -         (?, 18, 512)         -               </span><br><span class="line">G_synthesis/dlatents_in         -         (?, 18, 512)         -               </span><br><span class="line">G_synthesis/4x4/Const           534528    (?, 512, 4, 4)       (512,)          </span><br><span class="line">G_synthesis/4x4/Conv            2885632   (?, 512, 4, 4)       (3, 3, 512, 512)</span><br><span class="line">G_synthesis/ToRGB_lod8          1539      (?, 3, 4, 4)         (1, 1, 512, 3)  </span><br><span class="line">G_synthesis/8x8/Conv0_up        2885632   (?, 512, 8, 8)       (3, 3, 512, 512)</span><br><span class="line">G_synthesis/8x8/Conv1           2885632   (?, 512, 8, 8)       (3, 3, 512, 512)</span><br><span class="line">G_synthesis/ToRGB_lod7          1539      (?, 3, 8, 8)         (1, 1, 512, 3)  </span><br><span class="line">G_synthesis/Upscale2D           -         (?, 3, 8, 8)         -               </span><br><span class="line">G_synthesis/Grow_lod7           -         (?, 3, 8, 8)         -               </span><br><span class="line">G_synthesis/16x16/Conv0_up      2885632   (?, 512, 16, 16)     (3, 3, 512, 512)</span><br><span class="line">G_synthesis/16x16/Conv1         2885632   (?, 512, 16, 16)     (3, 3, 512, 512)</span><br><span class="line">G_synthesis/ToRGB_lod6          1539      (?, 3, 16, 16)       (1, 1, 512, 3)  </span><br><span class="line">G_synthesis/Upscale2D_1         -         (?, 3, 16, 16)       -               </span><br><span class="line">G_synthesis/Grow_lod6           -         (?, 3, 16, 16)       -               </span><br><span class="line">G_synthesis/32x32/Conv0_up      2885632   (?, 512, 32, 32)     (3, 3, 512, 512)</span><br><span class="line">G_synthesis/32x32/Conv1         2885632   (?, 512, 32, 32)     (3, 3, 512, 512)</span><br><span class="line">G_synthesis/ToRGB_lod5          1539      (?, 3, 32, 32)       (1, 1, 512, 3)  </span><br><span class="line">G_synthesis/Upscale2D_2         -         (?, 3, 32, 32)       -               </span><br><span class="line">G_synthesis/Grow_lod5           -         (?, 3, 32, 32)       -               </span><br><span class="line">G_synthesis/64x64/Conv0_up      1442816   (?, 256, 64, 64)     (3, 3, 512, 256)</span><br><span class="line">G_synthesis/64x64/Conv1         852992    (?, 256, 64, 64)     (3, 3, 256, 256)</span><br><span class="line">G_synthesis/ToRGB_lod4          771       (?, 3, 64, 64)       (1, 1, 256, 3)  </span><br><span class="line">G_synthesis/Upscale2D_3         -         (?, 3, 64, 64)       -               </span><br><span class="line">G_synthesis/Grow_lod4           -         (?, 3, 64, 64)       -               </span><br><span class="line">G_synthesis/128x128/Conv0_up    426496    (?, 128, 128, 128)   (3, 3, 256, 128)</span><br><span class="line">G_synthesis/128x128/Conv1       279040    (?, 128, 128, 128)   (3, 3, 128, 128)</span><br><span class="line">G_synthesis/ToRGB_lod3          387       (?, 3, 128, 128)     (1, 1, 128, 3)  </span><br><span class="line">G_synthesis/Upscale2D_4         -         (?, 3, 128, 128)     -               </span><br><span class="line">G_synthesis/Grow_lod3           -         (?, 3, 128, 128)     -               </span><br><span class="line">G_synthesis/256x256/Conv0_up    139520    (?, 64, 256, 256)    (3, 3, 128, 64) </span><br><span class="line">G_synthesis/256x256/Conv1       102656    (?, 64, 256, 256)    (3, 3, 64, 64)  </span><br><span class="line">G_synthesis/ToRGB_lod2          195       (?, 3, 256, 256)     (1, 1, 64, 3)   </span><br><span class="line">G_synthesis/Upscale2D_5         -         (?, 3, 256, 256)     -               </span><br><span class="line">G_synthesis/Grow_lod2           -         (?, 3, 256, 256)     -               </span><br><span class="line">G_synthesis/512x512/Conv0_up    51328     (?, 32, 512, 512)    (3, 3, 64, 32)  </span><br><span class="line">G_synthesis/512x512/Conv1       42112     (?, 32, 512, 512)    (3, 3, 32, 32)  </span><br><span class="line">G_synthesis/ToRGB_lod1          99        (?, 3, 512, 512)     (1, 1, 32, 3)   </span><br><span class="line">G_synthesis/Upscale2D_6         -         (?, 3, 512, 512)     -               </span><br><span class="line">G_synthesis/Grow_lod1           -         (?, 3, 512, 512)     -               </span><br><span class="line">G_synthesis/1024x1024/Conv0_up  21056     (?, 16, 1024, 1024)  (3, 3, 32, 16)  </span><br><span class="line">G_synthesis/1024x1024/Conv1     18752     (?, 16, 1024, 1024)  (3, 3, 16, 16)  </span><br><span class="line">G_synthesis/ToRGB_lod0          51        (?, 3, 1024, 1024)   (1, 1, 16, 3)   </span><br><span class="line">G_synthesis/Upscale2D_7         -         (?, 3, 1024, 1024)   -               </span><br><span class="line">G_synthesis/Grow_lod0           -         (?, 3, 1024, 1024)   -               </span><br><span class="line">G_synthesis/images_out          -         (?, 3, 1024, 1024)   -               </span><br><span class="line">G_synthesis/lod                 -         ()                   -               </span><br><span class="line">G_synthesis/noise0              -         (<span class="number">1</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">4</span>)         -               </span><br><span class="line">G_synthesis/noise1              -         (<span class="number">1</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">4</span>)         -               </span><br><span class="line">G_synthesis/noise2              -         (<span class="number">1</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">8</span>)         -               </span><br><span class="line">G_synthesis/noise3              -         (<span class="number">1</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">8</span>)         -               </span><br><span class="line">G_synthesis/noise4              -         (<span class="number">1</span>, <span class="number">1</span>, <span class="number">16</span>, <span class="number">16</span>)       -               </span><br><span class="line">G_synthesis/noise5              -         (<span class="number">1</span>, <span class="number">1</span>, <span class="number">16</span>, <span class="number">16</span>)       -               </span><br><span class="line">G_synthesis/noise6              -         (<span class="number">1</span>, <span class="number">1</span>, <span class="number">32</span>, <span class="number">32</span>)       -               </span><br><span class="line">G_synthesis/noise7              -         (<span class="number">1</span>, <span class="number">1</span>, <span class="number">32</span>, <span class="number">32</span>)       -               </span><br><span class="line">G_synthesis/noise8              -         (<span class="number">1</span>, <span class="number">1</span>, <span class="number">64</span>, <span class="number">64</span>)       -               </span><br><span class="line">G_synthesis/noise9              -         (<span class="number">1</span>, <span class="number">1</span>, <span class="number">64</span>, <span class="number">64</span>)       -               </span><br><span class="line">G_synthesis/noise10             -         (<span class="number">1</span>, <span class="number">1</span>, <span class="number">128</span>, <span class="number">128</span>)     -               </span><br><span class="line">G_synthesis/noise11             -         (<span class="number">1</span>, <span class="number">1</span>, <span class="number">128</span>, <span class="number">128</span>)     -               </span><br><span class="line">G_synthesis/noise12             -         (<span class="number">1</span>, <span class="number">1</span>, <span class="number">256</span>, <span class="number">256</span>)     -               </span><br><span class="line">G_synthesis/noise13             -         (<span class="number">1</span>, <span class="number">1</span>, <span class="number">256</span>, <span class="number">256</span>)     -               </span><br><span class="line">G_synthesis/noise14             -         (<span class="number">1</span>, <span class="number">1</span>, <span class="number">512</span>, <span class="number">512</span>)     -               </span><br><span class="line">G_synthesis/noise15             -         (<span class="number">1</span>, <span class="number">1</span>, <span class="number">512</span>, <span class="number">512</span>)     -               </span><br><span class="line">G_synthesis/noise16             -         (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1024</span>, <span class="number">1024</span>)   -               </span><br><span class="line">G_synthesis/noise17             -         (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1024</span>, <span class="number">1024</span>)   -               </span><br><span class="line">images_out                      -         (?, 3, 1024, 1024)   -               </span><br><span class="line">---                             ---       ---                  ---             </span><br><span class="line">Total                           <span class="number">26219627</span></span><br></pre></td></tr></table></figure>
<h2 id="np-random-RandomState">np.random.RandomState</h2>
<p>代码<code>rnd = np.random.RandomState(seed)</code>基于<strong>Mesenne Twister</strong>算法生成伪随机数:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">       rnd = np.random.RandomState(<span class="literal">None</span>)</span><br><span class="line">       print(rnd.randint(<span class="number">1</span>, <span class="number">10</span>, <span class="number">5</span>))</span><br><span class="line">[output]::</span><br><span class="line">[<span class="number">7</span> <span class="number">6</span> <span class="number">7</span> <span class="number">5</span> <span class="number">6</span>]</span><br><span class="line">[<span class="number">7</span> <span class="number">4</span> <span class="number">5</span> <span class="number">3</span> <span class="number">9</span>]</span><br><span class="line">[<span class="number">1</span> <span class="number">7</span> <span class="number">9</span> <span class="number">3</span> <span class="number">6</span>]</span><br><span class="line">[<span class="number">5</span> <span class="number">3</span> <span class="number">3</span> <span class="number">1</span> <span class="number">3</span>]</span><br><span class="line">[<span class="number">9</span> <span class="number">3</span> <span class="number">5</span> <span class="number">2</span> <span class="number">9</span>]</span><br><span class="line">&gt;&gt;&gt;<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">       rnd = np.random.RandomState(<span class="number">1</span>)</span><br><span class="line">       print(rnd.randint(<span class="number">1</span>, <span class="number">10</span>, <span class="number">5</span>))</span><br><span class="line">[output]::</span><br><span class="line">[<span class="number">6</span> <span class="number">9</span> <span class="number">6</span> <span class="number">1</span> <span class="number">1</span>]</span><br><span class="line">[<span class="number">6</span> <span class="number">9</span> <span class="number">6</span> <span class="number">1</span> <span class="number">1</span>]</span><br><span class="line">[<span class="number">6</span> <span class="number">9</span> <span class="number">6</span> <span class="number">1</span> <span class="number">1</span>]</span><br><span class="line">[<span class="number">6</span> <span class="number">9</span> <span class="number">6</span> <span class="number">1</span> <span class="number">1</span>]</span><br><span class="line">[<span class="number">6</span> <span class="number">9</span> <span class="number">6</span> <span class="number">1</span> <span class="number">1</span>]</span><br><span class="line">&gt;&gt;&gt;rnd = np.random.RandomState(<span class="number">1</span>)</span><br><span class="line">   <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">       print(rnd.randint(<span class="number">1</span>, <span class="number">10</span>, <span class="number">5</span>))</span><br><span class="line">[output]::</span><br><span class="line">[<span class="number">6</span> <span class="number">9</span> <span class="number">6</span> <span class="number">1</span> <span class="number">1</span>]</span><br><span class="line">[<span class="number">2</span> <span class="number">8</span> <span class="number">7</span> <span class="number">3</span> <span class="number">5</span>]</span><br><span class="line">[<span class="number">6</span> <span class="number">3</span> <span class="number">5</span> <span class="number">3</span> <span class="number">5</span>]</span><br><span class="line">[<span class="number">8</span> <span class="number">8</span> <span class="number">2</span> <span class="number">8</span> <span class="number">1</span>]</span><br><span class="line">[<span class="number">7</span> <span class="number">8</span> <span class="number">7</span> <span class="number">2</span> <span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p><code>latents = rnd.randn(1, Gs.input_shape[1])</code>生成一个(1, 512)的随机向量。<br>
<code>fmt=dict(func=tflib.convert_images_to_uint8,nchw_to_nhwc=True)</code>将函数<code>tflib.convert_images_to_uint8</code>以及<strong>bool</strong>值<code>nchw_to_nhwc=True</code>打包成字典<strong>fmt</strong>。</p>
<h2 id="tflib-convert-images-to-uint8">tflib.convert_images_to_uint8</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""将数据类型为float32的minibatch图像转换为uint8.以及调整数据格式.</span></span><br><span class="line"><span class="string">可以用来对Network.run()的输出做转换处理."""</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">convert_images_to_uint8</span><span class="params">(images, drange=[<span class="number">-1</span>,<span class="number">1</span>], nchw_to_nhwc=False, shrink=<span class="number">1</span>)</span>:</span></span><br><span class="line">    images = tf.cast(images, tf.float32)</span><br><span class="line">    <span class="keyword">if</span> shrink &gt; <span class="number">1</span>:</span><br><span class="line">        ksize = [<span class="number">1</span>, <span class="number">1</span>, shrink, shrink]</span><br><span class="line">        images = tf.nn.avg_pool(images, ksize=ksize, strides=ksize, padding=<span class="string">"VALID"</span>, data_format=<span class="string">"NCHW"</span>)</span><br><span class="line">    <span class="keyword">if</span> nchw_to_nhwc:</span><br><span class="line">        images = tf.transpose(images, [<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>])</span><br><span class="line">    scale = <span class="number">255</span> / (drange[<span class="number">1</span>] - drange[<span class="number">0</span>]) <span class="comment"># scale = 127.5</span></span><br><span class="line">    images = images * scale + (<span class="number">0.5</span> - drange[<span class="number">0</span>] * scale)</span><br><span class="line">    <span class="keyword">return</span> tf.saturate_cast(images, tf.uint8)</span><br></pre></td></tr></table></figure>
<p>**“NHWC”**模式下，批次数据的排列顺序为[batch, height, width, channels]（TF的默认设置）<br>
<strong>“NCHW”<strong>模式下，批次数据的排列顺序为[batch, channels, height, width]<br>
<strong>NHWC</strong>和</strong>NCHW</strong>的解读可参照<a href="https://blog.csdn.net/weixin_41847115/article/details/83794551#commentBox" target="_blank" rel="noopener">深度学习(4):NCHW和NHWC</a>，后续个人将完善这部分的学习。</p>
<h2 id="Gs-run">Gs.run</h2>
<p><code>images=Gs.run(latents,None,truncation_psi=0.7,randomize_noise=True,output_transform=fmt)</code>调用<strong>dnnlib/tflib/network.py</strong>中<strong>Network</strong>类的<strong>run</strong>。关于<strong><a href="http://network.py" target="_blank" rel="noopener">network.py</a></strong>的解读将放在其它文章中。</p>
<h2 id="os-makedirs-os-path-join">os.makedirs &amp; os.path.join</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">os.makedirs(config.result_dir, exist_ok=<span class="literal">True</span>)</span><br><span class="line">png_filename = os.path.join(config.result_dir,<span class="string">'example.png'</span>)</span><br></pre></td></tr></table></figure>
<p><code>os.makedirs(config.result_dir, exist_ok=True)</code>会根据<strong>config.result_dir</strong>提供的路径创建相应的文件夹，<strong>exist_ok=True</strong>用于当上述文件夹已经存在时屏蔽<code>OSError</code> 。<br>
<code>os.path.join(a)</code>函数可以将多个路径分量(父路径以及文件名)通过分隔符<code>'/'</code>连接在一起，本例中将<strong>config.result_dir</strong>与**'example.png’<strong>连接并赋值给</strong>png_filename**，相当于<code>png_filename=&quot;%s/%s&quot;%(config.result_dir,'example.png')</code>。</p>
<h2 id="PIL-Image-fromarray">PIL.Image.fromarray</h2>
<p><code>PIL.Image.fromarray(images[0],'RGB').save(png_filename)</code>将<strong>imgages[0]<strong>以</strong>RGB</strong>格式存储在文件<strong>png_filename</strong>中。</p>
]]></content>
      <categories>
        <category>GAN</category>
      </categories>
      <tags>
        <tag>styleGAN</tag>
      </tags>
  </entry>
</search>
